C51 COMPILER V9.56.0.0   YAOPING                                                           04/28/2017 13:56:56 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE YAOPING
OBJECT MODULE PLACED IN .\Objects\Yaoping.obj
COMPILER INVOKED BY: C:\Keil_C51\C51\BIN\C51.EXE Yaoping.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\keil) DEBUG OBJECTEXTEND P
                    -RINT(.\Listings\Yaoping.lst) TABS(2) OBJECT(.\Objects\Yaoping.obj)

line level    source

   1          //7.28灌云下载版本，主要 修改了高空输送线的运行时间，以及提升机构的极限位置。
   2          
   3          #include <c8051f040.h>                 // SFR declaration
   4          #include <math.h>
   5          #include "Yaoping.h"
   6          #include "CAN1.h"
   7          #define T2RUN  temppage= SFRPAGE; SFRPAGE=0X00;TR2=1;SFRPAGE=temppage;  //允许定时器运行
   8          #define T2STOP temppage= SFRPAGE; SFRPAGE=0X00;TR2=0;SFRPAGE=temppage   //禁止定时器运行
   9          
  10          bit volatile Receive_command_finished = NO;
  11          bit Receive485_command_finished = YES;
  12          bit Time_FLAG = YES;
  13          bit Time_FLAG1 = YES;
  14          bit AUTO_FLAG = NO;
  15          bit Step_FLAG = NO;
  16          bit CANINFOR_FLAG = NO;
  17          bit ONCE_FLAG = NO;
  18          xdata volatile unsigned char Runmode = 0;
  19          //定义定时器的软件计数器
  20          xdata unsigned char  T0Counter5 = 0; //
  21          xdata unsigned char  T0Counter2 = 0;
  22          xdata volatile unsigned char  T0Counter3 = 0; //
  23          xdata unsigned char  T0Counter4 = 0; //
  24          xdata unsigned int  T0Counter6 = 0; //
  25          xdata unsigned char  T0Counter8 = 0;
  26          xdata unsigned int   T0Counter9 = 0;
  27          xdata unsigned int   T0Counter10 = 0; //高空输送线定时器
  28          xdata unsigned char  GAOKONG_COUT = 0; //高空输送线计数器
  29          xdata unsigned char  YAOPINGTISH_COUT = 0; //药品提升计数器
  30          xdata unsigned char  CANcomand = 0;  //CAN命令字
  31          xdata volatile unsigned char  nCANcomand = 0;   //防止CAN中断修改运行中的命令
  32          xdata unsigned char  AUTOCANcomand = 0;
  33          xdata unsigned char  AUTOCMD_STATE = 0;
  34          xdata unsigned char  AUTOCMD_TIME = 0;
  35          xdata volatile unsigned char  AUTOCMD_CHECK = 0;
  36          xdata unsigned char  temppage = 0;
  37          xdata unsigned char BPSSET = 0;
  38          xdata unsigned char IDSET = 0;
  39          xdata unsigned char Shaft1_Run_mode = 0x00;
  40          xdata unsigned long Shaft1_aim_pulse = 0;
  41          xdata unsigned char Sampleperiod = 0;
  42          xdata unsigned int ShowTime1 = 0;
  43          //xdata FLASH Flash;            //定义Flash 缓冲区
  44          xdata CANTRANSDATBUF CANTXBUF_ZKB;
  45          xdata unsigned  int Pulse1 = 0;
  46          xdata unsigned char Shaft1_Base_Speed_Value = 0;
  47          xdata long int Shaft1_Velocity_Subsection_Parameter = 0;
  48          xdata long int motor1_out = 0;                      //步进电机1实际的转速
  49          xdata unsigned char Shaft1_ADD_Speed_Time_Base = 0;
  50          xdata unsigned char Shaft1_SUB_Speed_Time_Base = 0;
  51          xdata unsigned  long Pulse1_Cnt = 0;
  52          xdata unsigned int  Shaft1_Add_Speed = 0;
  53          xdata unsigned int  Shaft1_Speed_max = 0;
  54          xdata long int Vel1 = 0;
C51 COMPILER V9.56.0.0   YAOPING                                                           04/28/2017 13:56:56 PAGE 2   

  55          xdata unsigned long speed_value = 0;
  56          xdata unsigned char buf[30];
  57          xdata unsigned char Rec1[30];
  58          xdata unsigned  char RecPointer1 = 0;
  59          //xdata  RECBUF1 RxBuf1;
  60          xdata unsigned  long Servoparadisplace = 0;
  61          xdata unsigned  long Servoparaspeed = 0;
  62          xdata unsigned  long Servoparaaddtime = 0;
  63          xdata unsigned  long Servoparasubtime = 0;
  64          xdata unsigned  long ShowTime = 0;
  65          xdata unsigned  char Servopara[107];
  66          xdata volatile unsigned  char CANTRASTEMINFOR[20];
  67          xdata unsigned  char repair_flag = 0;
  68          xdata unsigned  char Servomotor_original = 0; //伺服原点标志位
  69          xdata volatile systemcrtl system_crtl;
  70          xdata Servomotordisplace  Servomotor_displace;
  71          xdata Servomotorspeed     Servomotor_speed;
  72          xdata Servomotoraddtime   Servomotor_addtime;
  73          xdata Servomotorsubtime   Servomotor_subtime;
  74          code unsigned int Speedvalue[2000] = { 60560,
  75                                                 60657, 60751, 60842, 60929, 61012, 61093, 61171, 61246, 61319, 6138
             -9, 61457, 61523, 61587, 61649, 61708, 61766, 61823, 61877, 61930, 61982, 62032, 62081, 62128, 62174, 62219, 62262, 62305
             -, 62346, 62387, 62426, 62465, 62502, 62539, 62574, 62609, 62643, 62676, 62709, 62741, 62772, 62802, 62832, 62861, 62889,
             - 62917, 62945, 62971, 62997, 63023, 63048, 63073, 63097, 63121, 63144, 63167, 63189, 63211, 63233, 63254, 63274, 63295, 
             -63315, 63334, 63354, 63373, 63391, 63410, 63428, 63445, 63463, 63480, 63497, 63513, 63530, 63546, 63562, 63577, 63593, 6
             -3608, 63622, 63637, 63651, 63666, 63680, 63693, 63707, 63720, 63733, 63746, 63759, 63772, 63784, 63796, 63809, 63820, 63
             -832, 63844, 63855, 63866, 63878,
  76                                                 63889, 63899, 63910, 63921, 63931, 63941, 63952, 63962, 63972, 6398
             -1, 63991, 64001, 64010, 64019, 64028, 64038, 64046, 64055, 64064, 64073, 64081, 64090, 64098, 64106, 64115, 64123, 64131
             -, 64139, 64146, 64154, 64162, 64169, 64177, 64184, 64191, 64199, 64206, 64213, 64220, 64227, 64234, 64241, 64247, 64254,
             - 64260, 64267, 64273, 64280, 64286, 64292, 64299, 64305, 64311, 64317, 64323, 64329, 64334, 64340, 64346, 64352, 64357, 
             -64363, 64368, 64374, 64379, 64385, 64390, 64395, 64400, 64405, 64411, 64416, 64421, 64426, 64431, 64435, 64440, 64445, 6
             -4450, 64455, 64459, 64464, 64469, 64473, 64478, 64482, 64487, 64491, 64495, 64500, 64504, 64508, 64513, 64517, 64521, 64
             -525, 64529, 64533, 64537, 64541,
  77                                                 64545, 64549, 64553, 64557, 64561, 64565, 64568, 64572, 64576, 6457
             -9, 64583, 64587, 64590, 64594, 64598, 64601, 64605, 64608, 64611, 64615, 64618, 64622, 64625, 64628, 64632, 64635, 64638
             -, 64641, 64645, 64648, 64651, 64654, 64657, 64660, 64663, 64666, 64669, 64673, 64675, 64678, 64681, 64684, 64687, 64690,
             - 64693, 64696, 64699, 64701, 64704, 64707, 64710, 64713, 64715, 64718, 64721, 64723, 64726, 64729, 64731, 64734, 64736, 
             -64739, 64742, 64744, 64747, 64749, 64752, 64754, 64756, 64759, 64761, 64764, 64766, 64769, 64771, 64773, 64776, 64778, 6
             -4780, 64782, 64785, 64787, 64789, 64791, 64794, 64796, 64798, 64800, 64802, 64805, 64807, 64809, 64811, 64813, 64815, 64
             -817, 64819, 64821, 64824, 64826,
  78                                                 64828, 64830, 64832, 64834, 64836, 64838, 64839, 64841, 64843, 6484
             -5, 64847, 64849, 64851, 64853, 64855, 64857, 64858, 64860, 64862, 64864, 64866, 64868, 64869, 64871, 64873, 64875, 64876
             -, 64878, 64880, 64882, 64883, 64885, 64887, 64889, 64890, 64892, 64894, 64895, 64897, 64898, 64900, 64902, 64903, 64905,
             - 64907, 64908, 64910, 64911, 64913, 64914, 64916, 64918, 64919, 64921, 64922, 64924, 64925, 64927, 64928, 64930, 64931, 
             -64933, 64934, 64935, 64937, 64938, 64940, 64941, 64943, 64944, 64945, 64947, 64948, 64950, 64951, 64952, 64954, 64955, 6
             -4956, 64958, 64959, 64961, 64962, 64963, 64964, 64966, 64967, 64968, 64970, 64971, 64972, 64974, 64975, 64976, 64977, 64
             -979, 64980, 64981, 64982, 64984,
  79                                                 64985, 64986, 64987, 64988, 64990, 64991, 64992, 64993, 64994, 6499
             -6, 64997, 64998, 64999, 65000, 65001, 65003, 65004, 65005, 65006, 65007, 65008, 65009, 65010, 65012, 65013, 65014, 65015
             -, 65016, 65017, 65018, 65019, 65020, 65021, 65022, 65023, 65025, 65026, 65027, 65028, 65029, 65030, 65031, 65032, 65033,
             - 65034, 65035, 65036, 65037, 65038, 65039, 65040, 65041, 65042, 65043, 65044, 65045, 65046, 65047, 65048, 65049, 65050, 
             -65051, 65051, 65052, 65053, 65054, 65055, 65056, 65057, 65058, 65059, 65060, 65061, 65062, 65063, 65063, 65064, 65065, 6
             -5066, 65067, 65068, 65069, 65070, 65071, 65071, 65072, 65073, 65074, 65075, 65076, 65077, 65077, 65078, 65079, 65080, 65
             -081, 65082, 65082, 65083, 65084,
  80                                                 65085, 65086, 65087, 65087, 65088, 65089, 65090, 65091, 65091, 6509
             -2, 65093, 65094, 65095, 65095, 65096, 65097, 65098, 65098, 65099, 65100, 65101, 65101, 65102, 65103, 65104, 65105, 65105
             -, 65106, 65107, 65107, 65108, 65109, 65110, 65110, 65111, 65112, 65113, 65113, 65114, 65115, 65115, 65116, 65117, 65118,
             - 65118, 65119, 65120, 65120, 65121, 65122, 65122, 65123, 65124, 65125, 65125, 65126, 65127, 65127, 65128, 65129, 65129, 
             -65130, 65131, 65131, 65132, 65133, 65133, 65134, 65135, 65135, 65136, 65136, 65137, 65138, 65138, 65139, 65140, 65140, 6
             -5141, 65142, 65142, 65143, 65143, 65144, 65145, 65145, 65146, 65146, 65147, 65148, 65148, 65149, 65150, 65150, 65151, 65
             -151, 65152, 65153, 65153, 65154,
C51 COMPILER V9.56.0.0   YAOPING                                                           04/28/2017 13:56:56 PAGE 3   

  81                                                 65154, 65155, 65155, 65156, 65157, 65157, 65158, 65158, 65159, 6515
             -9, 65160, 65161, 65161, 65162, 65162, 65163, 65163, 65164, 65165, 65165, 65166, 65166, 65167, 65167, 65168, 65168, 65169
             -, 65169, 65170, 65171, 65171, 65172, 65172, 65173, 65173, 65174, 65174, 65175, 65175, 65176, 65176, 65177, 65177, 65178,
             - 65178, 65179, 65179, 65180, 65181, 65181, 65182, 65182, 65183, 65183, 65184, 65184, 65185, 65185, 65186, 65186, 65187, 
             -65187, 65188, 65188, 65188, 65189, 65189, 65190, 65190, 65191, 65191, 65192, 65192, 65193, 65193, 65194, 65194, 65195, 6
             -5195, 65196, 65196, 65197, 65197, 65197, 65198, 65198, 65199, 65199, 65200, 65200, 65201, 65201, 65202, 65202, 65202, 65
             -203, 65203, 65204, 65204, 65205,
  82                                                 65205, 65206, 65206, 65206, 65207, 65207, 65208, 65208, 65209, 6520
             -9, 65210, 65210, 65210, 65211, 65211, 65212, 65212, 65213, 65213, 65213, 65214, 65214, 65215, 65215, 65215, 65216, 65216
             -, 65217, 65217, 65217, 65218, 65218, 65219, 65219, 65220, 65220, 65220, 65221, 65221, 65222, 65222, 65222, 65223, 65223,
             - 65224, 65224, 65224, 65225, 65225, 65225, 65226, 65226, 65227, 65227, 65227, 65228, 65228, 65229, 65229, 65229, 65230, 
             -65230, 65230, 65231, 65231, 65232, 65232, 65232, 65233, 65233, 65233, 65234, 65234, 65235, 65235, 65235, 65236, 65236, 6
             -5236, 65237, 65237, 65237, 65238, 65238, 65238, 65239, 65239, 65240, 65240, 65240, 65241, 65241, 65241, 65242, 65242, 65
             -242, 65243, 65243, 65243, 65244,
  83                                                 65244, 65244, 65245, 65245, 65245, 65246, 65246, 65246, 65247, 6524
             -7, 65247, 65248, 65248, 65249, 65249, 65249, 65249, 65250, 65250, 65250, 65251, 65251, 65251, 65252, 65252, 65252, 65253
             -, 65253, 65253, 65254, 65254, 65254, 65255, 65255, 65255, 65256, 65256, 65256, 65257, 65257, 65257, 65258, 65258, 65258,
             - 65258, 65259, 65259, 65259, 65260, 65260, 65260, 65261, 65261, 65261, 65262, 65262, 65262, 65262, 65263, 65263, 65263, 
             -65264, 65264, 65264, 65265, 65265, 65265, 65265, 65266, 65266, 65266, 65267, 65267, 65267, 65267, 65268, 65268, 65268, 6
             -5269, 65269, 65269, 65270, 65270, 65270, 65270, 65271, 65271, 65271, 65272, 65272, 65272, 65272, 65273, 65273, 65273, 65
             -273, 65274, 65274, 65274, 65275,
  84                                                 65275, 65275, 65275, 65276, 65276, 65276, 65276, 65277, 65277, 6527
             -7, 65278, 65278, 65278, 65278, 65279, 65279, 65279, 65279, 65280, 65280, 65280, 65281, 65281, 65281, 65281, 65282, 65282
             -, 65282, 65282, 65283, 65283, 65283, 65283, 65284, 65284, 65284, 65284, 65285, 65285, 65285, 65285, 65286, 65286, 65286,
             - 65286, 65287, 65287, 65287, 65287, 65288, 65288, 65288, 65288, 65289, 65289, 65289, 65289, 65290, 65290, 65290, 65290, 
             -65291, 65291, 65291, 65291, 65292, 65292, 65292, 65292, 65293, 65293, 65293, 65293, 65294, 65294, 65294, 65294, 65294, 6
             -5295, 65295, 65295, 65295, 65296, 65296, 65296, 65296, 65297, 65297, 65297, 65297, 65297, 65298, 65298, 65298, 65298, 65
             -299, 65299, 65299, 65299, 65300,
  85                                                 65300, 65300, 65300, 65300, 65301, 65301, 65301, 65301, 65302, 6530
             -2, 65302, 65302, 65302, 65303, 65303, 65303, 65303, 65304, 65304, 65304, 65304, 65304, 65305, 65305, 65305, 65305, 65305
             -, 65306, 65306, 65306, 65306, 65307, 65307, 65307, 65307, 65307, 65308, 65308, 65308, 65308, 65308, 65309, 65309, 65309,
             - 65309, 65309, 65310, 65310, 65310, 65310, 65310, 65311, 65311, 65311, 65311, 65312, 65312, 65312, 65312, 65312, 65313, 
             -65313, 65313, 65313, 65313, 65314, 65314, 65314, 65314, 65314, 65315, 65315, 65315, 65315, 65315, 65316, 65316, 65316, 6
             -5316, 65316, 65316, 65317, 65317, 65317, 65317, 65317, 65318, 65318, 65318, 65318, 65318, 65319, 65319, 65319, 65319, 65
             -319, 65320, 65320, 65320, 65320,
  86                                                 65320, 65321, 65321, 65321, 65321, 65321, 65321, 65322, 65322, 6532
             -2, 65322, 65322, 65323, 65323, 65323, 65323, 65323, 65323, 65324, 65324, 65324, 65324, 65324, 65325, 65325, 65325, 65325
             -, 65325, 65325, 65326, 65326, 65326, 65326, 65326, 65327, 65327, 65327, 65327, 65327, 65327, 65328, 65328, 65328, 65328,
             - 65328, 65328, 65329, 65329, 65329, 65329, 65329, 65329, 65330, 65330, 65330, 65330, 65330, 65331, 65331, 65331, 65331, 
             -65331, 65331, 65332, 65332, 65332, 65332, 65332, 65332, 65333, 65333, 65333, 65333, 65333, 65333, 65334, 65334, 65334, 6
             -5334, 65334, 65334, 65335, 65335, 65335, 65335, 65335, 65335, 65336, 65336, 65336, 65336, 65336, 65336, 65336, 65337, 65
             -337, 65337, 65337, 65337, 65337,
  87                                                 65338, 65338, 65338, 65338, 65338, 65338, 65339, 65339, 65339, 6533
             -9, 65339, 65339, 65339, 65340, 65340, 65340, 65340, 65340, 65340, 65341, 65341, 65341, 65341, 65341, 65341, 65341, 65342
             -, 65342, 65342, 65342, 65342, 65342, 65343, 65343, 65343, 65343, 65343, 65343, 65343, 65344, 65344, 65344, 65344, 65344,
             - 65344, 65345, 65345, 65345, 65345, 65345, 65345, 65345, 65346, 65346, 65346, 65346, 65346, 65346, 65346, 65347, 65347, 
             -65347, 65347, 65347, 65347, 65347, 65348, 65348, 65348, 65348, 65348, 65348, 65348, 65349, 65349, 65349, 65349, 65349, 6
             -5349, 65349, 65350, 65350, 65350, 65350, 65350, 65350, 65350, 65351, 65351, 65351, 65351, 65351, 65351, 65351, 65351, 65
             -352, 65352, 65352, 65352, 65352,
  88                                                 65352, 65352, 65353, 65353, 65353, 65353, 65353, 65353, 65353, 6535
             -4, 65354, 65354, 65354, 65354, 65354, 65354, 65354, 65355, 65355, 65355, 65355, 65355, 65355, 65355, 65356, 65356, 65356
             -, 65356, 65356, 65356, 65356, 65356, 65357, 65357, 65357, 65357, 65357, 65357, 65357, 65357, 65358, 65358, 65358, 65358,
             - 65358, 65358, 65358, 65359, 65359, 65359, 65359, 65359, 65359, 65359, 65359, 65360, 65360, 65360, 65360, 65360, 65360, 
             -65360, 65360, 65361, 65361, 65361, 65361, 65361, 65361, 65361, 65361, 65362, 65362, 65362, 65362, 65362, 65362, 65362, 6
             -5362, 65362, 65363, 65363, 65363, 65363, 65363, 65363, 65363, 65363, 65364, 65364, 65364, 65364, 65364, 65364, 65364, 65
             -364, 65365, 65365, 65365, 65365,
  89                                                 65365, 65365, 65365, 65365, 65365, 65366, 65366, 65366, 65366, 6536
             -6, 65366, 65366, 65366, 65367, 65367, 65367, 65367, 65367, 65367, 65367, 65367, 65367, 65368, 65368, 65368, 65368, 65368
             -, 65368, 65368, 65368, 65368, 65369, 65369, 65369, 65369, 65369, 65369, 65369, 65369, 65369, 65370, 65370, 65370, 65370,
             - 65370, 65370, 65370, 65370, 65371, 65371, 65371, 65371, 65371, 65371, 65371, 65371, 65371, 65371, 65372, 65372, 65372, 
             -65372, 65372, 65372, 65372, 65372, 65372, 65373, 65373, 65373, 65373, 65373, 65373, 65373, 65373, 65373, 65374, 65374, 6
             -5374, 65374, 65374, 65374, 65374, 65374, 65374, 65375, 65375, 65375, 65375, 65375, 65375, 65375, 65375, 65375, 65375, 65
C51 COMPILER V9.56.0.0   YAOPING                                                           04/28/2017 13:56:56 PAGE 4   

             -376, 65376, 65376, 65376, 65376,
  90                                                 65376, 65376, 65376, 65376, 65376, 65377, 65377, 65377, 65377, 6537
             -7, 65377, 65377, 65377, 65377, 65378, 65378, 65378, 65378, 65378, 65378, 65378, 65378, 65378, 65378, 65379, 65379, 65379
             -, 65379, 65379, 65379, 65379, 65379, 65379, 65379, 65380, 65380, 65380, 65380, 65380, 65380, 65380, 65380, 65380, 65380,
             - 65380, 65381, 65381, 65381, 65381, 65381, 65381, 65381, 65381, 65381, 65381, 65382, 65382, 65382, 65382, 65382, 65382, 
             -65382, 65382, 65382, 65382, 65383, 65383, 65383, 65383, 65383, 65383, 65383, 65383, 65383, 65383, 65383, 65384, 65384, 6
             -5384, 65384, 65384, 65384, 65384, 65384, 65384, 65384, 65384, 65385, 65385, 65385, 65385, 65385, 65385, 65385, 65385, 65
             -385, 65385, 65386, 65386, 65386,
  91                                                 65386, 65386, 65386, 65386, 65386, 65386, 65386, 65386, 65387, 6538
             -7, 65387, 65387, 65387, 65387, 65387, 65387, 65387, 65387, 65387, 65387, 65388, 65388, 65388, 65388, 65388, 65388, 65388
             -, 65388, 65388, 65388, 65388, 65389, 65389, 65389, 65389, 65389, 65389, 65389, 65389, 65389, 65389, 65389, 65390, 65390,
             - 65390, 65390, 65390, 65390, 65390, 65390, 65390, 65390, 65390, 65390, 65391, 65391, 65391, 65391, 65391, 65391, 65391, 
             -65391, 65391, 65391, 65391, 65391, 65392, 65392, 65392, 65392, 65392, 65392, 65392, 65392, 65392, 65392, 65392, 65393, 6
             -5393, 65393, 65393, 65393, 65393, 65393, 65393, 65393, 65393, 65393, 65393, 65393, 65394, 65394, 65394, 65394, 65394, 65
             -394, 65394, 65394, 65394, 65394,
  92                                                 65394, 65394, 65395, 65395, 65395, 65395, 65395, 65395, 65395, 6539
             -5, 65395, 65395, 65395, 65395, 65396, 65396, 65396, 65396, 65396, 65396, 65396, 65396, 65396, 65396, 65396, 65396, 65396
             -, 65397, 65397, 65397, 65397, 65397, 65397, 65397, 65397, 65397, 65397, 65397, 65397, 65397, 65398, 65398, 65398, 65398,
             - 65398, 65398, 65398, 65398, 65398, 65398, 65398, 65398, 65398, 65399, 65399, 65399, 65399, 65399, 65399, 65399, 65399, 
             -65399, 65399, 65399, 65399, 65399, 65400, 65400, 65400, 65400, 65400, 65400, 65400, 65400, 65400, 65400, 65400, 65400, 6
             -5400, 65401, 65401, 65401, 65401, 65401, 65401, 65401, 65401, 65401, 65401, 65401, 65401, 65401, 65401, 65402, 65402, 65
             -402, 65402, 65402, 65402, 65402,
  93                                                 65402, 65402, 65402, 65402, 65402, 65402, 65403, 65403, 65403, 6540
             -3, 65403, 65403, 65403, 65403, 65403, 65403, 65403, 65403, 65403, 65403, 65404, 65404, 65404, 65404, 65404, 65404, 65404
             -, 65404, 65404, 65404, 65404, 65404, 65404, 65404, 65404, 65405, 65405, 65405, 65405, 65405, 65405, 65405, 65405, 65405,
             - 65405, 65405, 65405, 65405, 65405, 65406, 65406, 65406, 65406, 65406, 65406, 65406, 65406, 65406, 65406, 65406, 65406, 
             -65406, 65406, 65406, 65407, 65407, 65407, 65407, 65407, 65407, 65407, 65407, 65407, 65407, 65407, 65407, 65407, 65407, 6
             -5408, 65408, 65408, 65408, 65408, 65408, 65408, 65408, 65408, 65408, 65408, 65408, 65408, 65408, 65408, 65409, 65409, 65
             -409, 65409, 65409, 65409, 65409,
  94                                                 65409, 65409, 65409, 65409, 65409, 65409, 65409, 65409, 65409, 6541
             -0, 65410, 65410, 65410, 65410, 65410, 65410, 65410, 65410, 65410, 65410, 65410, 65410, 65410, 65410, 65411, 65411, 65411
             -, 65411, 65411, 65411, 65411, 65411, 65411, 65411, 65411, 65411, 65411, 65411, 65411, 65411, 65412, 65412, 65412, 65412,
             - 65412, 65412, 65412, 65412, 65412, 65412, 65412, 65412, 65412, 65412, 65412, 65412, 65413, 65413, 65413, 65413, 65413, 
             -65413, 65413, 65413, 65413, 65413, 65413, 65413, 65413, 65413, 65413, 65413, 65413, 65414, 65414, 65414, 65414, 65414, 6
             -5414, 65414, 65414, 65414, 65414, 65414, 65414, 65414, 65414, 65414, 65414, 65415, 65415, 65415, 65415, 65415, 65415, 65
             -415, 65415, 65415, 65415
  95                                               };
  96          
  97          void Dir_ZZ()
  98          {
  99   1          Motor1_Dir = 1; //正转
 100   1      }
 101          void Dir_FZ()
 102          {
 103   1          Motor1_Dir = 0; //反转
 104   1      }
 105          
 106          /**************************************************************************/
 107          void delay_ms(unsigned int ms)
 108          {
 109   1          unsigned int us = 1000;
 110   1          while(ms--)
 111   1          {
 112   2              WDTCN = 0xA5;
 113   2              delay1(us);
 114   2          }
 115   1      }
 116          /**************************************************************************/
 117          void Watchdog_Init (void)
 118          {
 119   1          WDTCN &= ~0x80;                     // WDTCN.7 must be logic 0 when setting
 120   1          // the interval.
C51 COMPILER V9.56.0.0   YAOPING                                                           04/28/2017 13:56:56 PAGE 5   

 121   1          WDTCN |= 0x07;                      // Set the WDTCN[2-0] to 111b
 122   1      }
 123          //------------------------------------------------------
 124          // 名    称：Initial
 125          // 功    能：初始化模块
 126          //------------------------------------------------------
 127          void Initial(void)
 128          {
 129   1          OSCILLATOR_Init ();
 130   1          Watchdog_Init ();
 131   1          PORT_Init ();
 132   1          Timer01_Init();
 133   1          //init_T2 ();
 134   1          //init_INT0();
 135   1          //init_INT1();
 136   1          SFRPAGE  = CONFIG_PAGE;
 137   1      
 138   1          repair_flag = P7 & 0x03 ;
 139   1          //IDSET = 0x02;        //CAN接受地址
 140   1          IDSET = P7 & 0x7F ;
 141   1          IDSET = IDSET >> 4;
 142   1          BPSSET = 0x00;       //CAN波特率设置
 143   1          init_para();
 144   1          //PT2=1;
 145   1          PT0 = 1;
 146   1          //E2PROM初始化
 147   1          WDTCN = 0xA5;  //看门狗复位
 148   1          EA = 1; //开中断
 149   1          //motor1_ENB=0;
 150   1      }
 151          void Timer01_Init(void)
 152          {
 153   1          char SFRPAGE_SAVE = SFRPAGE;        // Save Current SFR page
 154   1          SFRPAGE = TIMER01_PAGE;             // Set SFR page
 155   1          TMOD = (TMOD & 0x00) | 0x21; //T0工作于方式1，T1工作于方式2
 156   1          PCON = 0x00;    //电源和SMOD控制字
 157   1          TH1  = 0xfd;    //9600 bit band:TH1=0xfd;1200 bit:TH1=0xe8
 158   1          TL1  = 0xfd;    //T1常数设置bt=11059200/(32*12*(256-TH1))
 159   1          TF1  = 0;   //定时器1溢出标志位清零
 160   1          TR1  = 1;   //T1开始计数 bt=28800/(256-TH1)
 161   1          TH0  = 0xDC;      //Reset 10ms interrupt
 162   1          TL0  = 00;
 163   1          TF0  = 0;
 164   1          TR0  = 1;
 165   1          ET0 = 1;
 166   1          SCON0 = 0x50;   //串行通讯方式一：起始位(L)、8位数据位、无校验位、停止位(H)
 167   1      //    SCON0 = 0xD0;       // Serial Port Control Register
 168   1          //SCON = 0x40;    //串行通讯方式一：起始位(L)、8位数据位、无校验位、停止位(H)
 169   1          ES0 = 1;  //串行中断允许
 170   1          SFRPAGE = SFRPAGE_SAVE;             // Restore SFR page
 171   1      }
 172          
 173          
 174          /////////////////////////////
 175          //定时0中断,模式1,16位定时计数器, 时钟4分频 ,高优先级
 176          //T0=65536-1000us*11.0592/4=0xF533      时钟4分频下的1毫秒
 177          //T0=65536-1000us*11.0592/12=0xFC66     时钟12分频下的1毫秒
 178          //T0=65536-10000us*11.0592/12=0xDC00    时钟12分频下的10毫秒
 179          void Timer0_ISR (void) interrupt 1
 180          {
 181   1          char SFRPAGE_SAVE = SFRPAGE;     // Save Current SFR page
 182   1      
C51 COMPILER V9.56.0.0   YAOPING                                                           04/28/2017 13:56:56 PAGE 6   

 183   1          WDTCN = 0xA5;                    // 喂狗
 184   1      
 185   1          T0Counter2++;
 186   1          T0Counter3++;
 187   1          T0Counter4++;
 188   1          T0Counter5++;
 189   1          T0Counter6++;
 190   1          T0Counter8++;
 191   1          T0Counter9++;
 192   1          T0Counter10++;  //高空输送线定时器
 193   1          SFRPAGE = 0x0F;  //关闭高空输送线
 194   1      
 195   1          //高空输送线运行定时
 196   1          if(T0Counter10 > GAOKONG_TIMER)
 197   1          {
 198   2              if(Motor2 == 0) //已启动
 199   2              {
 200   3                  if((CANTRASTEMINFOR[8] & 0x04) == 0x04) //高空输送线传感器检测到药品
 201   3                  {
 202   4                      T0Counter10 = 0;
 203   4                      GAOKONG_COUT = GAOKONG_COUT + 1;
 204   4                      if(GAOKONG_COUT > 3)  //超出等待次数
 205   4                      {
 206   5                          Motor2 = 1; //关闭高空输送线
 207   5                          AUTOCMD_STATE = 0XC4;
 208   5                          T0Counter8 = 51;
 209   5                          AUTOCMD_TIME = 0;
 210   5                      }//报警*/
 211   4                  }
 212   3                  else  //高空输送线传感器未检测到药品
 213   3                  {
 214   4                      Motor2 = 1;
 215   4                      T0Counter10 = 0;
 216   4                      GAOKONG_COUT = 0;
 217   4                  }
 218   3              }
 219   2              else  //未启动
 220   2              {
 221   3                  T0Counter10 = 0;
 222   3                  GAOKONG_COUT = 0;
 223   3              }
 224   2          }
 225   1          //提升输送线传感器信号检测并写入
 226   1          if(MONITOR_INPUT2 == 1)
 227   1          {
 228   2              /*SFRPAGE = 0x0F;
 229   2              Motor1_B=1;
 230   2              SFRPAGE = SFRPAGE_SAVE;*/
 231   2              CANTRASTEMINFOR[8] = CANTRASTEMINFOR[8] | 0x08;
 232   2          }
 233   1          else
 234   1          {
 235   2              CANTRASTEMINFOR[8] = CANTRASTEMINFOR[8] & 0xF7;
 236   2          }
 237   1          //高空输送线传感器信号检测并写入
 238   1          if(MONITOR_INPUT1 == 1)
 239   1          {
 240   2              //SFRPAGE = 0x0F;
 241   2              //Motor1_Power=1;
 242   2              //SFRPAGE = SFRPAGE_SAVE;
 243   2              CANTRASTEMINFOR[8] = CANTRASTEMINFOR[8] | 0x04;
 244   2          }
C51 COMPILER V9.56.0.0   YAOPING                                                           04/28/2017 13:56:56 PAGE 7   

 245   1          else
 246   1          {
 247   2              CANTRASTEMINFOR[8] = CANTRASTEMINFOR[8] & 0xFB;
 248   2          }
 249   1          //
 250   1          SFRPAGE = SFRPAGE_SAVE;
 251   1          //
 252   1          SFRPAGE = TIMER01_PAGE;
 253   1          TH0 = 0xDC; //重新装载定时值
 254   1          TL0 = 0x00;
 255   1          SFRPAGE = SFRPAGE_SAVE;             // Restore SFR page
 256   1          return;
 257   1      }
 258          
 259          //-----------------------------------------------------------------------------
 260          // Port_Init ()
 261          //-----------------------------------------------------------------------------
 262          
 263          void PORT_Init (void)
 264          {
 265   1          // Configure the XBRn Registers
 266   1          char SFRPAGE_SAVE = SFRPAGE;        // Save Current SFR page
 267   1          SFRPAGE = CONFIG_PAGE;              // Set SFR page
 268   1          // Configure the XBRn Registers
 269   1      
 270   1          SFRPAGE = 0x0F;
 271   1          XBR0 = 0x04;  // XBAR0: Initial Reset Value  串口0
 272   1          XBR1 = 0x34;  // XBAR1: Initial Reset Value  T2定时器输出、外部中断1 和 外部中断0
 273   1          XBR2 = 0x40;  // XBAR2: Initial Reset Value  交叉总开关
 274   1          // XBR3 = 0x01;    // XBAR3: Initial Reset Value  T3定时器输出
 275   1          // Select Pin I/0
 276   1      
 277   1          // NOTE: Some peripheral I/O pins can function as either inputs or
 278   1          // outputs, depending on the configuration of the peripheral. By default,
 279   1          // the configuration utility will configure these I/O pins as push-pull
 280   1          // outputs.
 281   1          // Port configuration (1 = Push Pull Output)
 282   1          SFRPAGE = 0x0F;
 283   1          P0MDOUT = 0xF1; // 1111 1001b Output configuration for P0
 284   1          P1MDOUT = 0x00; // Output configuration for P1
 285   1          P2MDOUT = 0x00; // Output configuration for P2
 286   1          P3MDOUT = 0x00; // Output configuration for P3
 287   1      
 288   1          P4MDOUT = 0xFF; // Output configuration for P4
 289   1          P5MDOUT = 0xFF; // Output configuration for P5
 290   1          P6MDOUT = 0x00; // Output configuration for P6
 291   1          P7MDOUT = 0x00; // Output configuration for P7
 292   1      
 293   1          P1MDIN = 0xFF;  // Input configuration for P1
 294   1          P2MDIN = 0xFF;  // Input configuration for P2
 295   1          P3MDIN = 0xFF;  // Input configuration for P3
 296   1      
 297   1          // View port pinout
 298   1      
 299   1          // The current Crossbar configuration results in the
 300   1          // following port pinout assignment:
 301   1          // Port 0
 302   1          // P0.0 = UART0 TX        (Push-Pull Output)(Digital)
 303   1          // P0.1 = UART0 RX        (Open-Drain Output/Input)(Digital)
 304   1          // P0.2 = UART1 TX        (Push-Pull Output)(Digital)
 305   1          // P0.3 = UART1 RX        (Open-Drain Output/Input)(Digital)
 306   1          // P0.4 = GP I/O          (Open-Drain Output/Input)(Digital)
C51 COMPILER V9.56.0.0   YAOPING                                                           04/28/2017 13:56:56 PAGE 8   

 307   1          // P0.5 = GP I/O          (Open-Drain Output/Input)(Digital)
 308   1          // P0.6 = GP I/O          (Open-Drain Output/Input)(Digital)
 309   1          // P0.7 = GP I/O          (Open-Drain Output/Input)(Digital)
 310   1      
 311   1          // Port 1
 312   1          // P1.0 = GP I/O          (Open-Drain Output/Input)(Digital)
 313   1          // P1.1 = GP I/O          (Open-Drain Output/Input)(Digital)
 314   1          // P1.2 = GP I/O          (Open-Drain Output/Input)(Digital)
 315   1          // P1.3 = GP I/O          (Open-Drain Output/Input)(Digital)
 316   1          // P1.4 = GP I/O          (Open-Drain Output/Input)(Digital)
 317   1          // P1.5 = GP I/O          (Open-Drain Output/Input)(Digital)
 318   1          // P1.6 = GP I/O          (Open-Drain Output/Input)(Digital)
 319   1          // P1.7 = GP I/O          (Open-Drain Output/Input)(Digital)
 320   1      
 321   1          // Port 2
 322   1          // P2.0 = GP I/O          (Open-Drain Output/Input)(Digital)
 323   1          // P2.1 = GP I/O          (Open-Drain Output/Input)(Digital)
 324   1          // P2.2 = GP I/O          (Open-Drain Output/Input)(Digital)
 325   1          // P2.3 = GP I/O          (Open-Drain Output/Input)(Digital)
 326   1          // P2.4 = GP I/O          (Open-Drain Output/Input)(Digital)
 327   1          // P2.5 = GP I/O          (Open-Drain Output/Input)(Digital)
 328   1          // P2.6 = GP I/O          (Open-Drain Output/Input)(Digital)
 329   1          // P2.7 = GP I/O          (Open-Drain Output/Input)(Digital)
 330   1      
 331   1          // Port 3
 332   1          // P3.0 = GP I/O          (Open-Drain Output/Input)(Digital)
 333   1          // P3.1 = GP I/O          (Open-Drain Output/Input)(Digital)
 334   1          // P3.2 = GP I/O          (Open-Drain Output/Input)(Digital)
 335   1          // P3.3 = GP I/O          (Open-Drain Output/Input)(Digital)
 336   1          // P3.4 = GP I/O          (Open-Drain Output/Input)(Digital)
 337   1          // P3.5 = GP I/O          (Open-Drain Output/Input)(Digital)
 338   1          // P3.6 = GP I/O          (Open-Drain Output/Input)(Digital)
 339   1          // P3.7 = GP I/O          (Open-Drain Output/Input)(Digital)
 340   1          SFRPAGE = 0x00;
 341   1          EMI0CF = 0x27;//27  // External Memory Configuration Register
 342   1          SFRPAGE = SFRPAGE_SAVE;             // Restore SFR page
 343   1      }
 344          //-----------------------------------------------------------------------------
 345          // OSCILLATOR_Init
 346          //-----------------------------------------------------------------------------
 347          //
 348          // Return Value : None
 349          // Parameters   : None
 350          //
 351          // This function initializes the system clock to use an external 22.1184MHz
 352          // crystal.
 353          //
 354          //-----------------------------------------------------------------------------
 355          void OSCILLATOR_Init (void)
 356          {
 357   1          int i;                              // Software timer
 358   1          char SFRPAGE_SAVE = SFRPAGE;        // Save Current SFR page
 359   1          SFRPAGE = CONFIG_PAGE;              // Set SFR page
 360   1          OSCXCN = 0x67;                      // Enable external crystal osc.
 361   1          for (i = 0; i < 256; i++);          // Wait at least 1ms
 362   1      
 363   1          while (!(OSCXCN & 0x80));           // Wait for crystal osc to settle
 364   1      
 365   1          CLKSEL = 0x01;
 366   1          // Select external crystal as SYSTEMCLOCK source
 367   1      
 368   1          SFRPAGE = SFRPAGE_SAVE;             // Restore SFRPAGE
C51 COMPILER V9.56.0.0   YAOPING                                                           04/28/2017 13:56:56 PAGE 9   

 369   1      }
 370          
 371          //////////////////////////
 372          //初始化变量
 373          //////////////////////////
 374          void init_para(void)
 375          {
 376   1          unsigned char i;
 377   1          for(i = 0; i < 8; i++)
 378   1          {
 379   2              CANTXBUF_ZKB.buf[i] = 0;
 380   2          }
 381   1          for(i = 0; i < 30; i++)
 382   1          {
 383   2              Rec1[i] = 0;
 384   2          }
 385   1          for(i = 0; i < 4; i++) //清伺服运行参数
 386   1          {
 387   2              Servomotor_displace.buf[i] = 0;
 388   2              Servomotor_speed.buf[i] = 0;;
 389   2              Servomotor_addtime.buf[i] = 0;;
 390   2              Servomotor_subtime.buf[i] = 0;;
 391   2          }
 392   1          Board_Parameter_Setup();    //各驱动板参数初始化
 393   1          AUTOCMD_CHECK = 0;
 394   1          Runmode = 2;
 395   1          /***********************************/
 396   1          //初始化步进电机1参数
 397   1          /**********************************/
 398   1          Shaft1_Run_mode = 0x00;
 399   1          Shaft1_aim_pulse = 0;
 400   1          RE1 = 0;
 401   1          DE1 = 0;
 402   1          Servoparadisplace = 500000;
 403   1          Servoparaspeed = 50000;
 404   1          Servoparaaddtime = 100;
 405   1          Servoparasubtime = 100;
 406   1          /*for(i=0;i<5;i++)
 407   1          {
 408   1          station[i]=0;
 409   1          }*/
 410   1          for(i = 0; i < 107; i++)
 411   1          {
 412   2              Servopara[i] = 0;
 413   2          }
 414   1      
 415   1          for(i = 0; i < 20; i++)
 416   1          {
 417   2              CANTRASTEMINFOR[i] = 0;
 418   2          }
 419   1          read_from_flash();
 420   1          system_crtl.AUTOsystem_command = 0;
 421   1          system_crtl.AUTOsystem_alarm1 = 0;
 422   1          //system_crtl.AUTOsystem_alarm2=0;
 423   1      
 424   1      
 425   1          Receive485_command_finished = YES;
 426   1      }
 427          void Board_Parameter_Setup(void)
 428          {
 429   1          switch(IDSET)
 430   1          {
C51 COMPILER V9.56.0.0   YAOPING                                                           04/28/2017 13:56:56 PAGE 10  

 431   2          case 01:    //X 轴参数
 432   2              init_can1_1();   //初始化c8051f040自带CAN
 433   2      
 434   2              //Current_Shaft1_Code=0x01;
 435   2              Shaft1_ADD_Speed_Time_Base = 10;
 436   2              Shaft1_SUB_Speed_Time_Base = 10;
 437   2              Shaft1_Base_Speed_Value = 50;
 438   2              Shaft1_Velocity_Subsection_Parameter = 248830;
 439   2              Shaft1_Add_Speed = 15;
 440   2              Shaft1_Speed_max = 400;   //40
 441   2              break;
 442   2          case 02:    //Y 轴参数          {
 443   2              init_can1_1();   //初始化c8051f040自带CAN
 444   2              break;
 445   2          case 03:    //Y 轴参数          {
 446   2              init_can1_1();   //初始化c8051f040自带CAN
 447   2              break;
 448   2          case 04:    //Y 轴参数          {
 449   2              init_can1_1();   //初始化c8051f040自带CAN
 450   2              break;
 451   2          default:
 452   2              break;
 453   2          }
 454   1      }
 455          
 456          
 457          /* 步进电机1驱动控制
 458          在此函数中，正转代表为电机离开原点运行；反转代表为电机背离原点运行
 459          */
 460          void Shaft1_CTL(void)
 461          {
 462   1          //long int speed_value=0;
 463   1      
 464   1          if(Step_FLAG == YES)
 465   1          {
 466   2              T2STOP;
 467   2              Step_FLAG = YES;
 468   2              if(Shaft1_Run_mode == 0x01 || Shaft1_Run_mode == 0x02 || Shaft1_Run_mode == 0x03)
 469   2              {
 470   3                  Shaft1_aim_pulse = 0;
 471   3                  Pulse1_Cnt = 0;
 472   3                  motor1_out = 0;
 473   3                  T0Counter4 = 0;
 474   3                  CANTRASTEMINFOR[8] = CANTRASTEMINFOR[8] & 0XFD; //清除运行标志
 475   3                  Shaft1_Run_mode = 0x00;
 476   3      
 477   3                  CANTRASTEMINFOR[13] = (unsigned char)((ShowTime & 0x0000FF00) >> 8);
 478   3                  CANTRASTEMINFOR[14] = (unsigned char)(ShowTime & 0x000000FF);
 479   3              }
 480   2              return;
 481   2          }
 482   1      }
 483          /////////////////////////////////////////////////////////////////
 484          //int ramp(int max,int step)  电机1 缓加减速
 485          // 带有急停功能的子程序
 486          // 单位为°/秒
 487          ////////////////////////////////////////////////////////////////
 488          void  ramp1_1(long int max)
 489          {
 490   1          //unsigned int nstep=0;
 491   1          /*if(!run_sign)
 492   1          {
C51 COMPILER V9.56.0.0   YAOPING                                                           04/28/2017 13:56:56 PAGE 11  

 493   1          motor1_out =0;
 494   1          }
 495   1          else
 496   1          {*/
 497   1          if(motor1_out >= (max + Shaft1_Add_Speed))
 498   1          {
 499   2              //nstep=nstep+15000;
 500   2              motor1_out -= Shaft1_Add_Speed;
 501   2          }
 502   1          else if(motor1_out <= (max - Shaft1_Add_Speed))
 503   1          {
 504   2              if( T0Counter4 >= Shaft1_ADD_Speed_Time_Base )        //加速时加速度时间参数
 505   2              {
 506   3                  T0Counter4 = 0;
 507   3                  motor1_out += Shaft1_Add_Speed;
 508   3              }
 509   2          }
 510   1          else {
 511   2              motor1_out = max;
 512   2          }
 513   1          //}
 514   1          //return motor1_out;
 515   1      }
 516          
 517          //-----------------------------------------------------------
 518          // 名    称：Serial_Port_Interrupt
 519          // 功    能：串口中断服务程序
 520          //-----------------------------------------------------------
 521          //# pragma disable
 522          # pragma enable
*** WARNING C245 IN LINE 522 OF Yaoping.c: unknown #pragma, line ignored
 523          void Serial_Port_Interrupt(void) interrupt 4
 524          {
 525   1          //unsigned int   TEMP,K=0;
 526   1          //unsigned char   xdata TEMP1,TEMP2,len=0,j=0,Check_Sum=0;
 527   1          xdata unsigned int   K = 0;
 528   1          xdata unsigned char  j = 0;
 529   1          char SFRPAGE_SAVE = SFRPAGE;
 530   1      
 531   1          SFRPAGE = UART0_PAGE;
 532   1          if(!RI0)    return ;    //误动作，退出
 533   1          WDTCN = 0xA5;
 534   1          //接收文件头
 535   1          RI0 = 0;
 536   1          Rec1[j] = SBUF0;  //接收的第一字节
 537   1          //TEMP1 = Receiv_Msg[j];
 538   1          //Check_Sum += Receiv_Msg[j];
 539   1          j++;
 540   1          K = 0;
 541   1      
 542   1          while(!RI0)     //超时处理
 543   1          {
 544   2              K++;
 545   2              WDTCN = 0xA5;
 546   2              if(K > Delay_Times)
 547   2                  goto END_ISR;
 548   2          }
 549   1          RI0 = 0;
 550   1          Rec1[j] = SBUF0;    //接收的第二字节
 551   1      
 552   1          //TEMP2 = Receiv_Msg[j];
 553   1          //Check_Sum += Receiv_Msg[j];
C51 COMPILER V9.56.0.0   YAOPING                                                           04/28/2017 13:56:56 PAGE 12  

 554   1          j++;
 555   1          /*TEMP=((UINT)TEMP1<<8)+TEMP2;  //合成接收的文件头
 556   1      
 557   1          if(TEMP != 0xEFEF)    //查接收的文件头
 558   1            goto END_ISR;
 559   1          接收长度字节
 560   1          K=0;
 561   1          while(!RI0)
 562   1          {
 563   1            K++;
 564   1            if(K>Delay_Times)
 565   1              goto END_ISR;
 566   1          }
 567   1          RI0=0;
 568   1          Receiv_Msg[j]=SBUF0;
 569   1          len=Receiv_Msg[j];
 570   1          Check_Sum += Receiv_Msg[j];
 571   1          j++;*/
 572   1          //接收数据、指令字节
 573   1          if((Rec1[0] == 0x01) && (Rec1[1] == 0x10))
 574   1          {
 575   2      //        for(; j < 6 + 2; j++)
 576   2      //        {
 577   2      //            K = 0;
 578   2      //            while(!RI0)
 579   2      //            {
 580   2      //                K++;
 581   2      //                WDTCN = 0xA5;
 582   2      //                if(K > Delay_Times)
 583   2      //                    goto END_ISR ;
 584   2      //            }
 585   2      //            RI0 = 0;
 586   2      //            Rec1[j] = SBUF0;
 587   2      //            //Check_Sum += Receiv_Msg[j];
 588   2      
 589   2      //        }
 590   2          }
 591   1          else if((Rec1[0] == 0x01) && (Rec1[1] == 0x03))
 592   1          {
 593   2              for(; j < 7 + 2; j++)
 594   2              {
 595   3                  K = 0;
 596   3                  while(!RI0)
 597   3                  {
 598   4                      K++;
 599   4                      WDTCN = 0xA5;
 600   4                      if(K > Delay_Times)
 601   4                      {
 602   5      //                      Receive_command_finished = YES;
 603   5                          goto END_ISR ;
 604   5                      }
 605   4                  }
 606   3                  RI0 = 0;
 607   3                  Rec1[j] = SBUF0;
 608   3                  //Check_Sum += Receiv_Msg[j];
 609   3              }
 610   2      //        Receive_command_finished = YES;
 611   2          }
 612   1          else
 613   1          {
 614   2              ;
 615   2          }
C51 COMPILER V9.56.0.0   YAOPING                                                           04/28/2017 13:56:56 PAGE 13  

 616   1          Receive_command_finished = YES;
 617   1      END_ISR:
 618   1          RI0  = 0;
 619   1          ES0  = 1;
 620   1          SFRPAGE = SFRPAGE_SAVE;             // Restore SFRPAGE
 621   1          return;
 622   1      }
 623          
 624          /*void init_T2 (void)
 625          {
 626            /////////////////////////////////////////////////////////////////////////////////////////////
 627            /// Timer2工作在电平切换输出方式
 628            /// 产生的方波步进电机的控制脉冲
 629            /// 使用系统时钟，自动重装载方式计时
 630            /// 方波频率：1MHz  0xFFFA；500kHz   0xFFF4
 631            /////////////////////////////////////////////////////////////////////////////////////////////
 632              char SFRPAGE_SAVE = SFRPAGE;        // Save Current SFR page
 633              SFRPAGE = 0x00;
 634              TMR2CF  = 0x0A; //  00001010b;  // Timer 3 Configuration
 635            //  位7-5：000  // 保留
 636            //  位4-3：01 // SYSCLK
 637            //  位2  ：0  // 切换输出状态位；写时产生强制输出
 638            //  位1  ：1  // 电平切换输出在为定时器被分配的端口引脚可用
 639            //  位0  ：0  // 定时器向上计数，与TnEX 的状态无关
 640              RCAP2L  = 0x00;         // Timer 3 Reload Register Low Byte
 641              RCAP2H  = 0x00;         // Timer 3 Reload Register High Byte
 642              TMR2H   = 0x00;         // Timer 3 High Byte
 643              TMR2L   = 0x00;         // Timer 3 Low Byte
 644              TMR2CN  = 0x00; //  00001010b;  // Timer 3 Control Register
 645            //  位7  ：0  // 定时器上溢/下溢标志；本项目不用
 646            //  位6  ：0  // 定时器外部标志；本项目不用
 647            //  位5-4：00 // 保留
 648            //  位3  ：0  // TnEX上的跳变被忽略
 649            //  位2  ：0  // 定时器禁止
 650            //  位1  ：0  // 定时器功能
 651            //  位0  ：0  // 定时器工作在自动重装载方式
 652          
 653              ET2=1;
 654              SFRPAGE = SFRPAGE_SAVE;             // Restore SFRPAGE
 655          }*/
 656          /*void init_INT0 (void)
 657          {
 658          SFRPAGE  = CONFIG_PAGE;        //Port SFR's on Configuration page
 659          XBR1  |= 0x04;                 //配置INT0管脚
 660          SFRPAGE  = LEGACY_PAGE;
 661          EA=0;
 662          EX0 = 1;    //使能INT0
 663          PX0 = 1;    //高优先级
 664          IT0=1;      //下降沿触发中断
 665          EA=1;
 666          }
 667          //对应于X轴为左边的限位开关，对应于Y轴为上边的限位开关
 668          //外部中断INT0 ，高优先级
 669          void INT0_ISR (void) interrupt 0
 670          {
 671          unsigned char temp;
 672          temp=SFRPAGE;
 673          SFRPAGE  = LEGACY_PAGE;
 674          EX0 = 0 ;   //关外部中断0
 675          Pulse1_Cnt=0;        //在此处进行清零电机1,当回到原点位置时，清零步进脉冲计数。
 676          Shaft1_Run_mode=0x00;
 677          Motor1_Begin_Run_Sign =NO;
C51 COMPILER V9.56.0.0   YAOPING                                                           04/28/2017 13:56:56 PAGE 14  

 678          IE0=0;      //INT0中断复位
 679          EX0 = 1 ;   //开外部中断0
 680          SFRPAGE=temp;
 681          }*/
 682          /*void init_INT0 (void)
 683          {
 684          SFRPAGE  = CONFIG_PAGE;        //Port SFR's on Configuration page
 685          XBR1  |= 0x04;                 //配置INT0管脚
 686          SFRPAGE  = LEGACY_PAGE;
 687          EA=0;
 688          EX0 = 1;    //使能INT0
 689          PX0 = 1;    //高优先级
 690          IT0=1;      //下降沿触发中断
 691          EA=1;
 692          }
 693          //对应于X轴为左边的限位开关，对应于Y轴为上边的限位开关
 694          //外部中断INT0 ，高优先级
 695          void INT0_ISR (void) interrupt 0
 696          {
 697          unsigned char temp;
 698          temp=SFRPAGE;
 699          SFRPAGE  = LEGACY_PAGE;
 700          EX0 = 0 ;   //关外部中断0
 701          IE0=0;      //INT0中断复位
 702          EX0 = 1 ;   //开外部中断0
 703          SFRPAGE=temp;
 704          }
 705          
 706           void init_INT1 (void)
 707           {
 708          
 709             SFRPAGE  = CONFIG_PAGE; //Port SFR's on Configuration page
 710             XBR1  |= 0x10;          //配置INT0管脚
 711             SFRPAGE  = LEGACY_PAGE;
 712             EA=0;
 713             EX1 = 1;               //使能INT1
 714             PX1 = 1;               //高优先级
 715             IT1=1;                 //下降沿触发中断
 716             EA=1;
 717             }
 718          
 719              //外部中断INT1 ，高优先级
 720              //对应于X轴为右边的限位开关，对应于Y轴为下边的限位开关
 721              void INT1_ISR (void) interrupt 2
 722              {
 723              unsigned char temp;
 724              temp=SFRPAGE;
 725              SFRPAGE  = LEGACY_PAGE;
 726              EX1 = 0 ;           //关外部中断1
 727          
 728               IE1=0;               //INT1中断复位
 729               EX1 = 1 ;            //开外部中断1
 730               SFRPAGE=temp;
 731          }*/
 732          
 733          //////////////////////////////////////////////////////////////////////
 734          //T2溢出中断    电机1用
 735          //为计输出脉冲数
 736          //根据实际接线情况判断：步进电机控制没有使用T2输出脉冲，即定时器2未起作用
 737          //////////////////////////////////////////////////////////////////////
 738          void  ISR_T2(void)  interrupt 5
 739          {
C51 COMPILER V9.56.0.0   YAOPING                                                           04/28/2017 13:56:56 PAGE 15  

 740   1          unsigned char temp;
 741   1          temp = SFRPAGE;
 742   1          SFRPAGE = 0x00;
 743   1          TF2 = 0;
 744   1          Pulse1++;
 745   1          if (Pulse1 >= 10)
 746   1          {
 747   2              Pulse1 = 0;
 748   2              Pulse1_Cnt++;
 749   2              //T2STOP;
 750   2              switch(Shaft1_Run_mode)
 751   2              {
 752   3              case 1:
 753   3                  if(Shaft1_aim_pulse >= Pulse1_Cnt)
 754   3                  {
 755   4                      ramp1_1((Shaft1_aim_pulse - Pulse1_Cnt) * 2);
 756   4                      speed_value = motor1_out + Shaft1_Base_Speed_Value;
 757   4                      //speed_value=1000;
 758   4                      motor1_dir = 1;
 759   4                      Vel1 = speed_value;
 760   4                      Motor1_CTL();
 761   4                  }
 762   3                  break;
 763   3      
 764   3              case 2:
 765   3                  if(Shaft1_aim_pulse >= Pulse1_Cnt)
 766   3                  {
 767   4                      ramp1_1((Shaft1_aim_pulse - Pulse1_Cnt) * 2);
 768   4                      speed_value = motor1_out + Shaft1_Base_Speed_Value;
 769   4                      motor1_dir = 0;
 770   4                      Vel1 = speed_value;
 771   4                      Motor1_CTL();
 772   4                  }
 773   3                  break;
 774   3      
 775   3              case 3:
 776   3                  if(Shaft1_aim_pulse >= Pulse1_Cnt)
 777   3                  {
 778   4                      ramp1_1((Shaft1_aim_pulse - Pulse1_Cnt) * 2);
 779   4                      speed_value = motor1_out + Shaft1_Base_Speed_Value;
 780   4                      motor1_dir = 0;
 781   4                      Vel1 = speed_value;
 782   4                      Motor1_CTL();
 783   4                  }
 784   3                  break;
 785   3      
 786   3              default:
 787   3                  speed_value = 0;
 788   3                  break;
 789   3              }
 790   2          }
 791   1          SFRPAGE = temp;
 792   1      }
 793          ///////////////////////////////////// /////////////////////////////////
 794          //电机1转速表达:°/秒.
 795          //输入范围:0~6000°/S;  （相当于步进电机1000r/min）
 796          //T2=65536-1000000*11.0592*360/(200*800*Vel)=65536-24883/Vel
 797          //T2=65536-1000000*11.0592*360/(200*400*Vel)=65536-49766/Vel
 798          //T2=65536-1000000*11.0592*360/(200*64*Vel)=65536-311040/Vel
 799          //T2=65536-1000000*11.0592*360/(200*16*Vel)=65536-1244160/Vel
 800          
 801          
C51 COMPILER V9.56.0.0   YAOPING                                                           04/28/2017 13:56:56 PAGE 16  

 802          //电机1转速表达:r/min.
 803          //T2=65536-1000000*11.0592*3/(2*10*16*Vel)=65536-103680/Vel
 804          //T2=65536-1000000*11.0592*3/(2*10*64*Vel)=65536-25920/Vel
 805          //T2=65536-1000000*11.0592*3/(2*10*400*Vel)=65536-4147/Vel
 806          
 807          //////////////////////////////////////////////////////////////////////
 808          void Motor1_CTL(void)     //T2输出，控制电机1
 809          {
 810   1          unsigned int temp1;
 811   1          //  long int motor1_v;
 812   1          //unsigned long ShowTime;
 813   1      
 814   1          if(Vel1 <= Shaft1_Base_Speed_Value)             //避免低速时出现啸叫
 815   1          {
 816   2              T2STOP;
 817   2              Time_FLAG1 = YES;
 818   2              Step_FLAG = YES;
 819   2              ShowTime = T0Counter6 * 10;
 820   2              return;
 821   2          } else
 822   1          {
 823   2              if(Vel1 > Shaft1_Speed_max)
 824   2                  Vel1 = Shaft1_Speed_max;          //限制最大速度，
 825   2              //temp1 = (65536 -Shaft1_Velocity_Subsection_Parameter/Vel1);
 826   2              temp1 = Speedvalue[Vel1 - 50];
 827   2              SFRPAGE = 0x00;
 828   2              RCAP2L = temp1 & 0x00FF;
 829   2              temp1   = temp1 >> 8;
 830   2              RCAP2H = temp1 & 0x00FF;
 831   2              //T2RUN;
 832   2          }
 833   1          //else if(Vel1<50)
 834   1          //Vel1=50;
 835   1          // motor1_v = Vel1;
 836   1      }
 837          //仅配为RS485模式  与RS422的区别就是在发送程序中，增加了发送前，关闭接受端口；发送完即打开接受端口。
 838          void Uart0Send(unsigned char *buf, unsigned char bufsize )
 839          {
 840   1          unsigned char i = 0;
 841   1          unsigned int k = 0;
 842   1          unsigned int crc_z = 0;
 843   1          char SFRPAGE_SAVE = SFRPAGE;        // Save Current SFR page
 844   1      
 845   1          SFRPAGE = CONFIG_PAGE;
 846   1      
 847   1          RE1 = 1;
 848   1          DE1 = 1;
 849   1          crc_z = crc_chk(buf, bufsize); //crc校验结果
 850   1          k = crc_z & 0x00ff;
 851   1      
 852   1          buf[bufsize] = (unsigned char)(k); //+CRC_Hi
 853   1          bufsize++;
 854   1          k = crc_z & 0xff00;
 855   1          k = k >> 8;
 856   1          buf[bufsize] = (unsigned char)(k); //+CRC_Li
 857   1          bufsize++;
 858   1          i = 0;
 859   1          delay_ms(10);
 860   1          ES0 = 0;
 861   1          SFRPAGE = UART0_PAGE;
 862   1          do
 863   1          {
C51 COMPILER V9.56.0.0   YAOPING                                                           04/28/2017 13:56:56 PAGE 17  

 864   2      //        ACC = buf[i];
 865   2      //        TB80 = P;
 866   2              SBUF0 = buf[i];
 867   2              while(!TI0);
 868   2              TI0 = 0;
 869   2              i++;
 870   2          } while(i < bufsize);
 871   1          ES0 = 1;
 872   1          SFRPAGE = CONFIG_PAGE ;
 873   1          RE1 = 0;
 874   1          DE1 = 0;
 875   1          delay_ms(10);
 876   1      
 877   1          SFRPAGE = SFRPAGE_SAVE;             // Restore SFR page
 878   1      }
 879          
 880          
 881          
 882          //-----------------------------------------------------------------------------
 883          //自定义延时
 884          //延时时间约为(us N10)毫秒
 885          //-----------------------------------------------------------------------------
 886          void delay1( unsigned int us)
 887          {
 888   1          unsigned int i = us;
 889   1          while(i--) ;
 890   1      }
 891          
 892          /*
 893          **将设定的5个立即值数据写入伺服驱动器
 894          **para1-para5:立即值状态、立即值位置、立即值速度、加速时间、减速时间
 895          */
 896          void send_to_motor(void)
 897          {
 898   1          unsigned char i;
 899   1      
 900   1          delay_ms(50);
 901   1          WDTCN = 0xA5;
 902   1          ES0 = 0;
 903   1          buf[0] = 0X01; //站点地址
 904   1          buf[1] = 0x10; //写
 905   1          buf[2] = 0x51; //寄存器地址高位
 906   1          buf[3] = 0x00; //寄存器地址低位
 907   1          buf[4] = 0x00; //所写内容高位
 908   1          buf[5] = 0x0A; //所写内容低位-5个寄存器
 909   1          buf[6] = 0x14;
 910   1      
 911   1          //#1 立即值状态
 912   1          if(Runmode == 1)
 913   1          {
 914   2              buf[7] = 0x00;
 915   2          }
 916   1          else
 917   1          {
 918   2              buf[7] = 0x01;
 919   2          }
 920   1          buf[8] = 0x00;
 921   1          buf[9] = 0x00;
 922   1          buf[10] = 0x00;
 923   1          //#2 立即值位置
 924   1          buf[11] = Servomotor_displace.buf[0];
 925   1          buf[12] = Servomotor_displace.buf[1];
C51 COMPILER V9.56.0.0   YAOPING                                                           04/28/2017 13:56:56 PAGE 18  

 926   1          buf[13] = Servomotor_displace.buf[2];
 927   1          buf[14] = Servomotor_displace.buf[3];
 928   1          //#3 立即值速度
 929   1          buf[15] = Servomotor_speed.buf[0];
 930   1          buf[16] = Servomotor_speed.buf[1];
 931   1          buf[17] = Servomotor_speed.buf[2];
 932   1          buf[18] = Servomotor_speed.buf[3];
 933   1          //#4 立即值加速时间
 934   1          buf[19] = Servomotor_addtime.buf[0];
 935   1          buf[20] = Servomotor_addtime.buf[1];
 936   1          buf[21] = Servomotor_addtime.buf[2];
 937   1          buf[22] = Servomotor_addtime.buf[3];
 938   1          //#5 立即值减速时间
 939   1          buf[23] = Servomotor_subtime.buf[0];
 940   1          buf[24] = Servomotor_subtime.buf[1];
 941   1          buf[25] = Servomotor_subtime.buf[2];
 942   1          buf[26] = Servomotor_subtime.buf[3];
 943   1      
 944   1          for(i = 0; i < 30; i++)
 945   1          {
 946   2              Rec1[i] = 0;
 947   2          }
 948   1          Uart0Send(buf, 27);
 949   1          ES0 = 1;
 950   1          delay_ms(300);
 951   1          if(Receive_command_finished == YES) //暂时不做过多的检查和校验，后期补上，加强安全性
 952   1          {
 953   2              Receive_command_finished = NO;
 954   2          }
 955   1      }
 956          
 957          
 958          //-----------------------------------------------------------------------------
 959          // 发送给伺服电机驱动器的通信CONT信号
 960          //command:通信CONT信号-CONT9-CONT24（bit0-byte15）
 961          //通过将CONT9-24绑定相应功能，从而通过modbus控制伺服驱动器
 962          //-----------------------------------------------------------------------------
 963          void Send_to_Motordriver_CTL(unsigned char command )
 964          {
 965   1          UINTUNION temp;
 966   1          unsigned char i;
 967   1      
 968   1          temp.value = command;
 969   1          WDTCN = 0xA5;
 970   1          buf[0] = 0x01; //站点地址
 971   1          buf[1] = 0x10; //写
 972   1      
 973   1          buf[2] = 0x00; //寄存器地址高位   针对CONT输入信号地址
 974   1          buf[3] = 0x00; //寄存器地址低位
 975   1      
 976   1          buf[4] = 0x00; //记录数
 977   1          buf[5] = 0x02; //记录数
 978   1      
 979   1          buf[6] = 0x04; //字节数
 980   1      
 981   1          buf[7] = 0x00; //所写内容最高字节
 982   1          buf[8] = 0x00; //所写内容次高字节
 983   1          buf[9] = temp.buf[0]; //所写内容次低字节
 984   1          buf[10] = temp.buf[1]; //所写内容最低字节
 985   1          for(i = 0; i < 30; i++)
 986   1          {
 987   2              Rec1[i] = 0;
C51 COMPILER V9.56.0.0   YAOPING                                                           04/28/2017 13:56:56 PAGE 19  

 988   2          }
 989   1          Uart0Send(buf, 11);
 990   1          delay_ms(300);
 991   1          if(Receive_command_finished == YES) //暂时不做过多的检查和校验，后期补上，加强安全性
 992   1          {
 993   2              Receive_command_finished = NO;
 994   2          }
 995   1      }
 996          
 997          //
 998          void RunLEDDIS(void)//运行显示
 999          {
1000   1          if(T0Counter5 >= 20) //200ms时间定时
1001   1          {
1002   2              T0Counter5 = 0 ;
1003   2              LED2 = !LED2;
1004   2          }
1005   1      }
1006          
1007          //直流电机控制
1008          void DCmotorCTRL(void)
1009          {
1010   1          char SFRPAGE_SAVE = SFRPAGE;        // Save Current SFR page
1011   1      
1012   1          switch(CANcomand)
1013   1          {
1014   2              /****************高空输送线直流电机*****************/
1015   2          case 0xD6:
1016   2              SFRPAGE = 0x0F;
1017   2              Motor2 = 0;
1018   2              SFRPAGE = SFRPAGE_SAVE;
1019   2              Time_FLAG1 = NO;
1020   2      
1021   2              CANTRASTEMINFOR[13] = 0;
1022   2              CANTRASTEMINFOR[14] = 0;
1023   2              Step_FLAG = NO;
1024   2              nCANcomand = 0;
1025   2              CANcomand = 0x00;
1026   2              T0Counter6 = 0;
1027   2              T0Counter10 = 0;
1028   2              break;
1029   2      
1030   2          case 0xD7:
1031   2              SFRPAGE = 0x0F;
1032   2              Motor2 = 1;
1033   2              SFRPAGE = SFRPAGE_SAVE;
1034   2              Time_FLAG1 = NO;
1035   2      
1036   2              CANTRASTEMINFOR[13] = 0;
1037   2              CANTRASTEMINFOR[14] = 0;
1038   2              Step_FLAG = NO;
1039   2              nCANcomand = 0;
1040   2              CANcomand = 0x00;
1041   2              T0Counter6 = 0;
1042   2              break;
1043   2              /*************************************************/
1044   2      
1045   2              /****************倾倒步进电机*****************/
1046   2          case 0xD8:
1047   2              switch(CANINDEX)
1048   2              {
1049   3              case 0:
C51 COMPILER V9.56.0.0   YAOPING                                                           04/28/2017 13:56:56 PAGE 20  

1050   3                  SFRPAGE = 0x0F;
1051   3                  Motor1_Power = 0;
1052   3                  Motor1_Dir = 1;
1053   3                  SFRPAGE = SFRPAGE_SAVE;
1054   3                  break;
1055   3      
1056   3              default:
1057   3                  break;
1058   3              }
1059   2              Time_FLAG1 = NO;
1060   2              CANTRASTEMINFOR[13] = 0;
1061   2              CANTRASTEMINFOR[14] = 0;
1062   2              Step_FLAG = NO;
1063   2              nCANcomand = 0;
1064   2              CANcomand = 0x00;
1065   2              T0Counter6 = 0;
1066   2              break;
1067   2      
1068   2          case 0xD9:
1069   2              Motor1_Power = 0;
1070   2              Motor1_Dir = 0;
1071   2              nCANcomand = 0;
1072   2              CANcomand = 0x00;
1073   2              break;
1074   2              /*************************************************/
1075   2      
1076   2          default:
1077   2              break;
1078   2          }
1079   1      }
1080          
1081          //步进电机控制
1082          /*根据实际接线判断：滚筒步进电机没有使用T2输出信号，
1083          而是由Motor1_Power输出信号直接控制中间继电器通断电实现转动，
1084          要实现反转还需要增加一个中间继电器和一个数字信号输出（电机驱动板）*/
1085          void SteppermotorCTRL(void)
1086          {
1087   1          switch(CANcomand)
1088   1          {
1089   2          case 0xD5:
1090   2              Shaft1_aim_pulse = Servopara[CANINDEX * 9 + 80];
1091   2              Shaft1_aim_pulse = Shaft1_aim_pulse << 8;
1092   2              Shaft1_aim_pulse = Shaft1_aim_pulse + Servopara[CANINDEX * 9 + 81];
1093   2              Shaft1_aim_pulse = Shaft1_aim_pulse << 8;
1094   2              Shaft1_aim_pulse = Shaft1_aim_pulse + Servopara[CANINDEX * 9 + 82];
1095   2              Shaft1_aim_pulse = Shaft1_aim_pulse << 8;;
1096   2              Shaft1_aim_pulse = Shaft1_aim_pulse + Servopara[CANINDEX * 9 + 83];
1097   2              Shaft1_Speed_max = Servopara[CANINDEX * 9 + 84];
1098   2              Shaft1_Speed_max = Shaft1_Speed_max << 8;
1099   2              Shaft1_Speed_max = Shaft1_Speed_max + Servopara[CANINDEX * 9 + 85];
1100   2              Shaft1_Add_Speed = Servopara[CANINDEX * 9 + 86];
1101   2              Shaft1_Add_Speed = Shaft1_Add_Speed << 8;
1102   2              Shaft1_Add_Speed = Shaft1_Add_Speed + Servopara[CANINDEX * 9 + 87];
1103   2              Shaft1_ADD_Speed_Time_Base = Servopara[CANINDEX * 9 + 88];
1104   2              switch(CANINDEX)
1105   2              {
1106   3              case 0:
1107   3                  Shaft1_Run_mode = 0x01;
1108   3                  break;
1109   3              case 1:
1110   3                  Shaft1_Run_mode = 0x02;
1111   3                  break;
C51 COMPILER V9.56.0.0   YAOPING                                                           04/28/2017 13:56:56 PAGE 21  

1112   3              case 2:
1113   3                  Shaft1_Run_mode = 0x03;
1114   3                  break;
1115   3              default:
1116   3                  Shaft1_Run_mode = 0x00;
1117   3                  break;
1118   3              }
1119   2              Time_FLAG1 = NO;
1120   2              Pulse1_Cnt = 0;
1121   2              motor1_out = 0;
1122   2              T2RUN;
1123   2      
1124   2              CANTRASTEMINFOR[13] = 0;
1125   2              CANTRASTEMINFOR[14] = 0;
1126   2              Step_FLAG = NO;
1127   2              nCANcomand = 0;
1128   2              CANcomand = 0x00;
1129   2              T0Counter6 = 0;
1130   2              T0Counter4 = 100;
1131   2              break;
1132   2      
1133   2          case 0x22:
1134   2              T2STOP;
1135   2              Shaft1_aim_pulse = 0;
1136   2              Pulse1_Cnt = 0;
1137   2              motor1_out = 0;
1138   2              T0Counter4 = 0;
1139   2              Shaft1_Run_mode = 0x00;
1140   2              nCANcomand = 0;
1141   2              CANcomand = 0x00;
1142   2              break;
1143   2      
1144   2          default:
1145   2              break;
1146   2          }
1147   1          Shaft1_CTL();    //1号电机
1148   1      
1149   1      }
1150          /*******************************************************************************************************
1151          //伺服电机运行函数包括报警量采集
1152          /*******************************************************************************************************/
1153          void ServomotorCRTL(unsigned char comand)//伺服电机控制
1154          {
1155   1          unsigned char CALU_m_pra = 0;
1156   1      
1157   1          CALU_m_pra = CANINDEX * 16;
1158   1          switch(comand)
1159   1          {
1160   2          case 0xD0:
1161   2              TR0  = 0;
1162   2              WDTCN = 0xA5;
1163   2              Send_to_Motordriver_CTL(0x01);
1164   2              Servomotor_displace.displace = Servoparadisplace;
1165   2              Servomotor_speed.speed = Servoparaspeed;
1166   2              Servomotor_addtime.addtime = 1000;
1167   2              Servomotor_subtime.subtime = 1000;
1168   2              send_to_motor();
1169   2              Send_to_Motordriver_CTL(0x03);
1170   2              Send_to_Motordriver_CTL(0x01);
1171   2              CANcomand = 0x00;
1172   2              nCANcomand = 0;
1173   2              TR0  = 1;
C51 COMPILER V9.56.0.0   YAOPING                                                           04/28/2017 13:56:56 PAGE 22  

1174   2              break;
1175   2      
1176   2          case 0xD2:
1177   2              TR0  = 0;
1178   2              WDTCN = 0xA5;
1179   2              Send_to_Motordriver_CTL(0x00);
1180   2              nCANcomand = 0;
1181   2              CANcomand = 0x00;
1182   2              TR0  = 1;
1183   2              break;
1184   2      
1185   2          case 0x11:
1186   2              TR0  = 0;
1187   2              WDTCN = 0xA5;
1188   2              Send_to_Motordriver_CTL(0x01);
1189   2              nCANcomand = 0;
1190   2              CANcomand = 0x00;
1191   2              TR0  = 1;
1192   2              break;
1193   2      
1194   2          case 0xD3:
1195   2              TR0  = 0;
1196   2              WDTCN = 0xA5;
1197   2              Receive485_command_finished = NO;
1198   2              //
1199   2              Servomotor_displace.buf[0] = Servopara[CALU_m_pra];
1200   2              Servomotor_displace.buf[1] = Servopara[CALU_m_pra + 1];
1201   2              Servomotor_displace.buf[2] = Servopara[CALU_m_pra + 2];
1202   2              Servomotor_displace.buf[3] = Servopara[CALU_m_pra + 3];
1203   2              //
1204   2              Servomotor_speed.buf[0] = Servopara[CALU_m_pra + 4];
1205   2              Servomotor_speed.buf[1] = Servopara[CALU_m_pra + 5];
1206   2              Servomotor_speed.buf[2] = Servopara[CALU_m_pra + 6];
1207   2              Servomotor_speed.buf[3] = Servopara[CALU_m_pra + 7];
1208   2              //
1209   2              Servomotor_addtime.buf[0] = Servopara[CALU_m_pra + 8];
1210   2              Servomotor_addtime.buf[1] = Servopara[CALU_m_pra + 9];
1211   2              Servomotor_addtime.buf[2] = Servopara[CALU_m_pra + 10];
1212   2              Servomotor_addtime.buf[3] = Servopara[CALU_m_pra + 11];
1213   2              //
1214   2              Servomotor_subtime.buf[0] = Servopara[CALU_m_pra + 12];
1215   2              Servomotor_subtime.buf[1] = Servopara[CALU_m_pra + 13];
1216   2              Servomotor_subtime.buf[2] = Servopara[CALU_m_pra + 14];
1217   2              Servomotor_subtime.buf[3] = Servopara[CALU_m_pra + 15];
1218   2              //
1219   2              CANTRASTEMINFOR[13] = 0;
1220   2              CANTRASTEMINFOR[14] = 0;
1221   2              Send_to_Motordriver_CTL(0x01);
1222   2              send_to_motor();
1223   2              Send_to_Motordriver_CTL(0x03);
1224   2              Send_to_Motordriver_CTL(0x01);
1225   2              T0Counter6 = 0;
1226   2              CANcomand = 0x00;
1227   2              nCANcomand = 0;
1228   2              Time_FLAG = NO;
1229   2              CANTRASTEMINFOR[8] = CANTRASTEMINFOR[8] | 0X01; //置运行标志
1230   2              Receive485_command_finished = YES;
1231   2              TR0  = 1;
1232   2              break;
1233   2      
1234   2          case 0xD4:
1235   2              TR0  = 0;
C51 COMPILER V9.56.0.0   YAOPING                                                           04/28/2017 13:56:56 PAGE 23  

1236   2              WDTCN = 0xA5;
1237   2              Returntopoint();
1238   2              CANcomand = 0x00;
1239   2              nCANcomand = 0;
1240   2              TR0  = 1;
1241   2              break;
1242   2      
1243   2          default:
1244   2              break;
1245   2          }
1246   1      //上传命令反馈数据
1247   1      }
1248          /*******************************************************************************************************
1249          //自动运行
1250          /*******************************************************************************************************/
1251          void AUTORUNMODE0(unsigned char comand)
1252          {
1253   1          char SFRPAGE_SAVE = SFRPAGE;        // Save Current SFR page
1254   1      
1255   1          switch(comand)
1256   1          {
1257   2          case 0xE0:
1258   2              Returntopoint();
1259   2              break;
1260   2      
1261   2          case 0xE1:
1262   2              /*if((CANTRASTEMINFOR[8]&0x08)==0x00)
1263   2              {
1264   2              SFRPAGE = 0x0F;
1265   2              if(Motor1_Power==0)
1266   2              {
1267   2              Motor1_Power=1;
1268   2              delay_ms(1000);
1269   2              Motor1_B=0;
1270   2              T0Counter6=0;
1271   2              }
1272   2              else
1273   2              {
1274   2              Motor1_Power=1;
1275   2              Motor1_B=0;
1276   2              T0Counter6=0;
1277   2              }
1278   2      
1279   2              }*/
1280   2              WDTCN = 0xA5;
1281   2              TR0  = 0;
1282   2              Send_to_Motordriver_CTL(0x00);//关闭伺服
1283   2              TR0  = 1;
1284   2              break;
1285   2      
1286   2          default:
1287   2              break;
1288   2          }
1289   1          SFRPAGE = SFRPAGE_SAVE;
1290   1      }
1291          /*******************************************************************************************************
1292          //自动运行
1293          /*******************************************************************************************************/
1294          
1295          void AUTORUNMODE1(unsigned char comand)
1296          {
1297   1          unsigned char CALU_m_pra = 0;
C51 COMPILER V9.56.0.0   YAOPING                                                           04/28/2017 13:56:56 PAGE 24  

1298   1          char SFRPAGE_SAVE = SFRPAGE;        // Save Current SFR page
1299   1      
1300   1          CALU_m_pra = CANINDEX * 16;
1301   1          if(CANINDEX >= 4) {
1302   2              CANINDEX = 4;
1303   2          }
1304   1          switch(comand)
1305   1          {
1306   2          case 0xF0:  //
1307   2              TR0  = 0;
1308   2              WDTCN = 0xA5;
1309   2              /*SFRPAGE = 0x0F;
1310   2              Motor2=0;
1311   2              SFRPAGE = SFRPAGE_SAVE;*/
1312   2      
1313   2              //开启提升伺服
1314   2              Receive485_command_finished = NO;
1315   2              Servomotor_displace.displace = 6000;
1316   2              Servomotor_speed.speed = 40000;
1317   2              Servomotor_addtime.addtime = 200;
1318   2              Servomotor_subtime.subtime = 200;
1319   2          
1320   2      //        //
1321   2      //        Servomotor_displace.buf[0] = Servopara[CALU_m_pra];
1322   2      //        Servomotor_displace.buf[1] = Servopara[CALU_m_pra + 1];
1323   2      //        Servomotor_displace.buf[2] = Servopara[CALU_m_pra + 2];
1324   2      //        Servomotor_displace.buf[3] = Servopara[CALU_m_pra + 3];
1325   2      //        if(Servomotor_displace.displace > Max_displace)
1326   2      //        {
1327   2      //            Servomotor_displace.displace = Max_displace;
1328   2      //        }
1329   2      //        //
1330   2      //        Servomotor_speed.buf[0] = Servopara[CALU_m_pra + 4];
1331   2      //        Servomotor_speed.buf[1] = Servopara[CALU_m_pra + 5];
1332   2      //        Servomotor_speed.buf[2] = Servopara[CALU_m_pra + 6];
1333   2      //        Servomotor_speed.buf[3] = Servopara[CALU_m_pra + 7];
1334   2      //        if(Servomotor_speed.speed > Max_speedvalue)
1335   2      //        {
1336   2      //            Servomotor_speed.speed = Max_speedvalue;
1337   2      //        }
1338   2      //        //
1339   2      //        Servomotor_addtime.buf[0] = Servopara[CALU_m_pra + 8];
1340   2      //        Servomotor_addtime.buf[1] = Servopara[CALU_m_pra + 9];
1341   2      //        Servomotor_addtime.buf[2] = Servopara[CALU_m_pra + 10];
1342   2      //        Servomotor_addtime.buf[3] = Servopara[CALU_m_pra + 11];
1343   2      //        //
1344   2      //        Servomotor_subtime.buf[0] = Servopara[CALU_m_pra + 12];
1345   2      //        Servomotor_subtime.buf[1] = Servopara[CALU_m_pra + 13];
1346   2      //        Servomotor_subtime.buf[2] = Servopara[CALU_m_pra + 14];
1347   2      //        Servomotor_subtime.buf[3] = Servopara[CALU_m_pra + 15];
1348   2              //
1349   2              CANTRASTEMINFOR[13] = 0;
1350   2              CANTRASTEMINFOR[14] = 0;
1351   2              Send_to_Motordriver_CTL(0x01);//伺服S-ON
1352   2              send_to_motor();//设定立即值数据
1353   2              Send_to_Motordriver_CTL(0x03);//伺服S-ON并自动启动伺服
1354   2              Send_to_Motordriver_CTL(0x01);//伺服S-ON
1355   2              T0Counter6 = 0;
1356   2              Time_FLAG = NO;
1357   2              Servomotor_original = 0;  //原点位置标志清零
1358   2              CANTRASTEMINFOR[8] = CANTRASTEMINFOR[8] | 0X01; //置运行标志
1359   2              Receive485_command_finished = YES;  //485数据接收完成
C51 COMPILER V9.56.0.0   YAOPING                                                           04/28/2017 13:56:56 PAGE 25  

1360   2              TR0  = 1;
1361   2              break;
1362   2      
1363   2          case 0xF1:    //开启提升输送线和高空输送线
1364   2              WDTCN = 0xA5;
1365   2              SFRPAGE = 0x0F;
1366   2              Motor1_Power = 0; //供电
1367   2              Dir_ZZ(); //正转
1368   2      //        Motor2 = 0; //启动高空输送线
1369   2              /*if(Motor1_B==0)
1370   2              {
1371   2                Motor1_B=1;
1372   2                delay_ms(1000);
1373   2                Motor1_Power=0;
1374   2              }
1375   2              else
1376   2              {
1377   2                Motor1_B=1;
1378   2                Motor1_Power=0;
1379   2              }*/
1380   2              T0Counter10 = 0; //高空输送线定时器
1381   2              GAOKONG_COUT = 0; //高空输送线计数器
1382   2              SFRPAGE = SFRPAGE_SAVE;
1383   2              break;
1384   2      
1385   2          case 0xF2://回归药品倾倒、回归伺服
1386   2              WDTCN = 0xA5;
1387   2              SFRPAGE = 0x0F;
1388   2              Motor1_Power = 1; //断电
1389   2              Dir_ZZ(); //正转
1390   2              /*if(Motor1_Power==0)
1391   2              {
1392   2              Motor1_Power=1;
1393   2              delay_ms(1000);
1394   2              Motor1_B=0;
1395   2              T0Counter6=0;
1396   2              }
1397   2              else
1398   2              {
1399   2              Motor1_Power=1;
1400   2              Motor1_B=0;
1401   2              T0Counter6=0;
1402   2              }*/
1403   2              TR0  = 0;
1404   2              SFRPAGE = SFRPAGE_SAVE;
1405   2              Receive485_command_finished = NO;
1406   2              Servomotor_displace.displace = Zero_backdisplace;//设置原点位置
1407   2              CANTRASTEMINFOR[13] = 0;
1408   2              CANTRASTEMINFOR[14] = 0;
1409   2              Send_to_Motordriver_CTL(0x01);//伺服S-ON
1410   2              send_to_motor();  //设定立即值
1411   2              Send_to_Motordriver_CTL(0x03);//伺服自动启动
1412   2              Send_to_Motordriver_CTL(0x01);//伺服S-ON
1413   2              T0Counter6 = 0;
1414   2              Time_FLAG = NO;
1415   2              CANTRASTEMINFOR[8] = CANTRASTEMINFOR[8] | 0X01; //置运行标志
1416   2              Receive485_command_finished = YES;
1417   2              TR0  = 1;
1418   2              break;
1419   2      
1420   2          case 0xF3:  //关闭伺服
1421   2              WDTCN = 0xA5;
C51 COMPILER V9.56.0.0   YAOPING                                                           04/28/2017 13:56:56 PAGE 26  

1422   2              TR0  = 0;
1423   2              Send_to_Motordriver_CTL(0x00);
1424   2              TR0  = 1;
1425   2              break;
1426   2      
1427   2          case 0xF4:  //停止高空输送线
1428   2              WDTCN = 0xA5;
1429   2              SFRPAGE = 0x0F;  //关闭高空输送线
1430   2      //        Motor2 = 1;
1431   2              SFRPAGE = SFRPAGE_SAVE;
1432   2              break;
1433   2      
1434   2          case 0xF5:  //回原点
1435   2              Returntopoint();
1436   2              break;
1437   2      
1438   2              //added begin
1439   2          case 0xF6:    //倾倒输送线反转
1440   2              WDTCN = 0xA5;
1441   2              SFRPAGE = 0x0F;
1442   2              Motor1_Power = 0; //启动翻转输送线
1443   2              Dir_FZ(); //反转
1444   2              SFRPAGE = SFRPAGE_SAVE;
1445   2              break;
1446   2      
1447   2          case 0xF7:    //倾倒输送线反转
1448   2              WDTCN = 0xA5;
1449   2              SFRPAGE = 0x0F;
1450   2              Motor1_Power = 1; //停止翻转输送线
1451   2              Dir_ZZ(); //反转
1452   2              SFRPAGE = SFRPAGE_SAVE;
1453   2              break;
1454   2              //added end
1455   2      
1456   2          default:
1457   2              break;
1458   2          }
1459   1          //Shaft1_CTL( Shaft1_Run_mode,Shaft1_aim_pulse);    //1号电机
1460   1          SFRPAGE = SFRPAGE_SAVE;
1461   1      }
1462          unsigned int crc_chk(unsigned char *puchMsg, unsigned char length)
1463          {
1464   1          int j;
1465   1          unsigned int crc_reg = 0xFFFF;
1466   1          while(length--)
1467   1          {
1468   2              crc_reg ^= *puchMsg++;
1469   2      
1470   2      
1471   2              for(j = 0; j < 8; j++)
1472   2              {
1473   3                  if(crc_reg & 0x01)
1474   3                  {
1475   4                      crc_reg = (crc_reg >> 1) ^ 0xA001;
1476   4                  }
1477   3                  else
1478   3                  {
1479   4                      crc_reg = crc_reg >> 1;
1480   4                  }
1481   3              }
1482   2          }
1483   1          return crc_reg;
C51 COMPILER V9.56.0.0   YAOPING                                                           04/28/2017 13:56:56 PAGE 27  

1484   1      }
1485          
1486          //伺服回原点
1487          void Returntopoint(void)
1488          {
1489   1          TR0  = 0;
1490   1          WDTCN = 0xA5;
1491   1      //    Send_to_Motordriver_CTL(0x01);//伺服S-ON
1492   1          Send_to_Motordriver_CTL(0x05);//原点复归
1493   1      //    Send_to_Motordriver_CTL(0x01);//伺服S-ON
1494   1          Time_FLAG = NO;
1495   1          CANTRASTEMINFOR[8] = CANTRASTEMINFOR[8] | 0X40; //置运行标志
1496   1          TR0  = 1;
1497   1      }
1498          
1499          //伺服电机数据采集
1500          void ServomotorDataacquisition(unsigned char addressID)
1501          {
1502   1          //if(ENABFLAG==YES)
1503   1          //{
1504   1          unsigned char i;
1505   1      
1506   1          if(Time_FLAG == YES) return;
1507   1          delay_ms(50);
1508   1          buf[0] = addressID; //站点地址
1509   1          buf[1] = 0x03; //读
1510   1          buf[2] = 0x10; //寄存器地址高位
1511   1          buf[3] = 0x03; //寄存器地址低位
1512   1          buf[4] = 0x00; //所写内容高位
1513   1          buf[5] = 0x06; //所写内容低位
1514   1          Uart0Send(buf, 6);
1515   1          AUTO_FLAG = YES;
1516   1          for(i = 0; i < 30; i++)
1517   1          {
1518   2              Rec1[i] = 0;
1519   2          }
1520   1          delay_ms(300);
1521   1          if(Receive_command_finished == YES)
1522   1          {
1523   2              //以后总传
1524   2              Receive_command_finished = NO;
1525   2              CANTRASTEMINFOR[0] = Rec1[7];
1526   2              CANTRASTEMINFOR[1] = Rec1[8];
1527   2              CANTRASTEMINFOR[2] = Rec1[9];
1528   2              CANTRASTEMINFOR[3] = Rec1[10];
1529   2              CANTRASTEMINFOR[4] = Rec1[11];
1530   2              CANTRASTEMINFOR[5] = Rec1[12];
1531   2              CANTRASTEMINFOR[6] = Rec1[13];
1532   2              CANTRASTEMINFOR[7] = Rec1[14];
1533   2      
1534   2          }
1535   1          AUTO_FLAG = NO;
1536   1      }
1537          
1538          //伺服电机电流采集
1539          void CurrentCollection(void)
1540          {
1541   1          //if(ENABFLAG==YES)
1542   1          //{
1543   1          unsigned char i;
1544   1      
1545   1          if(Time_FLAG1 == YES) return;
C51 COMPILER V9.56.0.0   YAOPING                                                           04/28/2017 13:56:56 PAGE 28  

1546   1          delay_ms(50);
1547   1          buf[0] = 2; //站点地址
1548   1          buf[1] = 0x03; //读
1549   1          buf[2] = 0x00;
1550   1          buf[3] = 0x00;
1551   1          buf[4] = 0x00;
1552   1          buf[5] = 0x08;
1553   1          for(i = 0; i < 30; i++)
1554   1          {
1555   2              Rec1[i] = 0;
1556   2          }
1557   1          Uart0Send(buf, 6);
1558   1          AUTO_FLAG = YES;
1559   1          delay_ms(300);
1560   1          if(Receive_command_finished == YES)
1561   1          {
1562   2              //以后总传
1563   2              Receive_command_finished = NO;
1564   2              CANTRASTEMINFOR[9] = Rec1[3];
1565   2              CANTRASTEMINFOR[10] = Rec1[4];
1566   2              CANTRASTEMINFOR[11] = Rec1[5];
1567   2              CANTRASTEMINFOR[12] = Rec1[6];
1568   2          }
1569   1          AUTO_FLAG = NO;;
1570   1      
1571   1          //}
1572   1      }
1573          
1574          //数据采集
1575          void Dataacquisition()
1576          {
1577   1          //没有处理命令时，可以执行数据采集任务
1578   1          if((CANcomand == 0 && nCANcomand == 0) || (nCANcomand == 0xFE) || (CANcomand == 0xFE))
1579   1          {
1580   2              //if(T0Counter3>=20)  //200ms时间定时
1581   2              //{
1582   2              //T0Counter3=0;
1583   2              ServomotorINP(0);
1584   2              switch(Sampleperiod)
1585   2              {
1586   3              case 0:
1587   3                  ServomotorDataacquisition(1);//伺服电机数据采集
1588   3                  break;
1589   3      
1590   3              case 1:
1591   3                  CurrentCollection();//伺服电机电流采集
1592   3                  break;
1593   3      
1594   3              default:
1595   3                  break;
1596   3              }
1597   2              //采集对象循环交替
1598   2              Sampleperiod = Sampleperiod + 1;
1599   2              if(Sampleperiod >= 2)
1600   2              {
1601   3                  Sampleperiod = 0;
1602   3              }
1603   2      
1604   2              //}
1605   2          }
1606   1      }
1607          
C51 COMPILER V9.56.0.0   YAOPING                                                           04/28/2017 13:56:56 PAGE 29  

1608          
1609          //-----------------------------------------------------------------------------
1610          //从伺服电机驱动器查询通信OUT信号
1611          //get_value:通信OUT信号-OUT6-CONT21（bit0-byte15）
1612          //通过将out6-21绑定相应功能，从而通过modbus获取伺服驱动器状态
1613          //伺服电机定位运行结束(OUT6)、原点复归结束信号(OUT7)查询函数
1614          //-----------------------------------------------------------------------------
1615          void ServomotorINP(unsigned char mode)
1616          {
1617   1          //unsigned int ShowTime1;
1618   1          unsigned char i;
1619   1      
1620   1          //if(ENABFLAG==YES)
1621   1          //{
1622   1        //暂时屏蔽
1623   1        if(mode==0)
1624   1        {
1625   2          if(Time_FLAG == YES) return;
1626   2        }
1627   1          WDTCN = 0xA5;
1628   1          delay_ms(50);
1629   1          buf[0] = 0x01; //站点地址
1630   1          buf[1] = 0x03; //读
1631   1          buf[2] = 0x01; //寄存器地址高位
1632   1          buf[3] = 0x00; //寄存器地址低位
1633   1          buf[4] = 0x00; //所写内容高位
1634   1          buf[5] = 0x02; //所写内容低位
1635   1          for(i = 0; i < 30; i++)
1636   1          {
1637   2              Rec1[i] = 0;
1638   2          }
1639   1          Uart0Send(buf, 6);
1640   1          AUTO_FLAG = YES;
1641   1          delay_ms(300);
1642   1          if(Receive_command_finished == YES)
1643   1          {
1644   2              Receive_command_finished = NO;
1645   2              ShowTime1 = T0Counter6 * 10;
1646   2              if((Rec1[6] & 0x01) == 0x01)//定位结束
1647   2              {
1648   3                  if(mode==0)Time_FLAG = YES;
1649   3                  CANTRASTEMINFOR[13] = (unsigned char)((ShowTime1 & 0xFF00) >> 8);
1650   3                  CANTRASTEMINFOR[14] = (unsigned char)(ShowTime1 & 0x00FF);
1651   3                  CANTRASTEMINFOR[8] = CANTRASTEMINFOR[8] & 0XFE; //清除运行标志
1652   3              }
1653   2              if((Rec1[6] & 0x02) == 0x02)//归位结束
1654   2              {
1655   3                  if(mode==1)Time_FLAG = YES;
1656   3                  CANTRASTEMINFOR[8] = CANTRASTEMINFOR[8] & 0XBF; //清除运行标志
1657   3              }
1658   2          }
1659   1          AUTO_FLAG = NO;
1660   1      }
1661          
1662          //系统控制
1663          /*系统有手动运行模式和自动运行模式两种Runmode；
1664          每种模式再根据CANcomand指令执行响应动作
1665          CANINDEX作为辅助参数使用
1666          */
1667          void SystemControl(void)
1668          {
1669   1          switch(Runmode)
C51 COMPILER V9.56.0.0   YAOPING                                                           04/28/2017 13:56:56 PAGE 30  

1670   1          {
1671   2          case 0:
1672   2              if(CANcomand == 0)
1673   2              {
1674   3                  CANcomand = nCANcomand;
1675   3              }
1676   2              SteppermotorCTRL();  //步进电机控制
1677   2              DCmotorCTRL();       //直流电机控制
1678   2              if(Receive485_command_finished == YES) //防止连续发控制命令
1679   2              {
1680   3                  ServomotorCRTL(CANcomand);//伺服电机控制
1681   3              }
1682   2              break;
1683   2      
1684   2          case 1:
1685   2              if(CANcomand == 0)
1686   2              {
1687   3                  CANcomand = nCANcomand;
1688   3              }
1689   2              /****************************/
1690   2              //检查命令的合法性
1691   2              /****************************/
1692   2              else if(CANcomand == 0xFE)
1693   2              {
1694   3                  AUTOCANcomand = AUTOTaskassignment1(); //自动运行任务安排
1695   3                  AUTORUNMODE1(AUTOCANcomand);
1696   3              }
1697   2              else if(CANcomand == 0xFB)
1698   2              {
1699   3                  AUTOCANcomand = AUTOTaskassignment0(); //原点复归
1700   3                  AUTORUNMODE0(AUTOCANcomand);
1701   3              }
1702   2              //ADDED BEGIN
1703   2              else if(CANcomand == 0xB0)
1704   2              {
1705   3                  AUTOCANcomand = AUTOTaskassignment1(); //
1706   3                  AUTORUNMODE1(AUTOCANcomand);
1707   3              }
1708   2              //ADDED END
1709   2              else {}
1710   2              break;
1711   2      
1712   2          default:
1713   2              break;
1714   2      
1715   2          }
1716   1      }
1717          
1718          #define   QDM_FZ_RUNTIME    300 //单位：10ms
1719          /********************************************************
1720          ////自动运行任务安排
1721          ********************************************************/
1722          unsigned char AUTOTaskassignment1(void)
1723          {
1724   1          unsigned char returnvalue = 0;
1725   1          char SFRPAGE_SAVE = SFRPAGE;        // Save Current SFR page
1726   1      
1727   1          switch(system_crtl.AUTOsystem_command)//做到每步运行检查判断给出命令
1728   1          {
1729   2          case 1:
1730   2              //检查命令执行可行性
1731   2              returnvalue = 0xF0; //开启提升伺服
C51 COMPILER V9.56.0.0   YAOPING                                                           04/28/2017 13:56:56 PAGE 31  

1732   2              CANTRASTEMINFOR[8] = CANTRASTEMINFOR[8] | 0X01; //置运行标志
1733   2              system_crtl.AUTOsystem_command = 2;
1734   2              break;
1735   2          case 2:
1736   2              //检查命令执行可行性
1737   2              //倾倒药品
1738   2              ServomotorINP(0);//查询伺服是否运行结束
1739   2              //  ServomotorDataacquisition(1);//伺服电机数据采集
1740   2              if(((CANTRASTEMINFOR[8] & 0X01) == 0x00)) //伺服提升结束
1741   2              {
1742   3                  returnvalue = 0xF1; //直流电机运行倾倒药品 开启高空输送线
1743   3                  T0Counter9 = 0;  //倾倒定时
1744   3                  YAOPINGTISH_COUT = 0; //计数清0
1745   3                  system_crtl.AUTOsystem_command = 4;
1746   3              }
1747   2              break;
1748   2      
1749   2          case 4:
1750   2              if(T0Counter9 > 200) //计时结束
1751   2              {
1752   3                  if((CANTRASTEMINFOR[8] & 0x08) == 0x08) //提升输送线传感器检测
1753   3                  {
1754   4                      YAOPINGTISH_COUT = YAOPINGTISH_COUT + 1;
1755   4                      if(YAOPINGTISH_COUT < 3)
1756   4                      {
1757   5                          T0Counter9 = 0;  //倾倒定时 如果NPN低电平计时重来
1758   5                      }
1759   4                      else
1760   4                      {
1761   5                          SFRPAGE = 0x0F;
1762   5                          Motor1_Power = 1;
1763   5                          Dir_ZZ(); //正转
1764   5                          SFRPAGE = SFRPAGE_SAVE;
1765   5                          system_crtl.AUTOsystem_command = 7;
1766   5                      }
1767   4                  }
1768   3                  else
1769   3                  {
1770   4                      returnvalue = 0xF2; //倾倒电机停机伺服回归
1771   4                      CANTRASTEMINFOR[8] = CANTRASTEMINFOR[8] | 0X01; //置运行标志
1772   4                      system_crtl.AUTOsystem_command = 5;
1773   4                  }
1774   3              }
1775   2              break;
1776   2          case 5:
1777   2              ServomotorINP(0);//查询伺服是否运行结束
1778   2              //   ServomotorDataacquisition(1);//伺服电机数据采集
1779   2              if((CANTRASTEMINFOR[8] & 0X01) == 0x00)
1780   2              {
1781   3                  returnvalue = 0xF5; //归零
1782   3                  // T0Counter9=0;//启动延时停机
1783   3                  system_crtl.AUTOsystem_command = 6; //
1784   3              }
1785   2              break;
1786   2      
1787   2          case 6:
1788   2              ServomotorINP(1);//查询伺服是否运行结束
1789   2              if((CANTRASTEMINFOR[8] & 0x40) == 0x00) //原点复归结束
1790   2              {
1791   3                  Servomotor_original = 1; //伺服原点标志建立
1792   3                  returnvalue = 0xF3; //关闭伺服
1793   3                  system_crtl.AUTOsystem_command = 8; //
C51 COMPILER V9.56.0.0   YAOPING                                                           04/28/2017 13:56:56 PAGE 32  

1794   3              }
1795   2              break;
1796   2          case 7:
1797   2              returnvalue = 0xF3; //关闭伺服
1798   2              system_crtl.AUTOsystem_command = 8;
1799   2              break;
1800   2          case 8:
1801   2              // T0Counter10=0;  //高空输送线定时器
1802   2              //  GAOKONG_COUT=0; //高空输送线计数器
1803   2              system_crtl.AUTOsystem_command = 0;
1804   2              CANcomand = 0x00;
1805   2              nCANcomand = 0x00;
1806   2              CANINDEX = 0;
1807   2              //nCANDate1=0;
1808   2              //自动运行结束上报信息参数
1809   2      
1810   2              AUTOCMD_STATE = 0XC2;
1811   2              T0Counter8 = 51;
1812   2              AUTOCMD_TIME = 0;
1813   2              break;
1814   2      
1815   2              //added begin
1816   2          case 9: //倾倒输送线反转，在正转时被关闭，无运行时间设定
1817   2              switch(CANINDEX)
1818   2              {
1819   3              case 1:
1820   3                  returnvalue = 0xF6;//提升输送线反转
1821   3                  break;
1822   3      
1823   3              case 2:
1824   3                  returnvalue = 0xF7;//提升输送线停止
1825   3                  break;
1826   3      
1827   3              default:
1828   3                  break;
1829   3              }
1830   2              system_crtl.AUTOsystem_command = 0;
1831   2              break;
1832   2              //added end
1833   2      
1834   2          default:
1835   2              break;
1836   2          }
1837   1      
1838   1          return  returnvalue;
1839   1      }
1840          /********************************************************
1841          ////自动运行任务安排模块系统复位-伺服回原点
1842          ********************************************************/
1843          unsigned char AUTOTaskassignment0(void)
1844          {
1845   1          unsigned char returnvalue = 0;
1846   1      
1847   1          switch(system_crtl.AUTOsystem_command)//做到每步运行检查判断给出命令
1848   1          {
1849   2          case 1:
1850   2              returnvalue = 0xE0; //伺服原点复归
1851   2              system_crtl.AUTOsystem_command = 2;
1852   2              break;
1853   2      
1854   2          case 2:
1855   2              ServomotorINP(1);//查询伺服是否运行结束
C51 COMPILER V9.56.0.0   YAOPING                                                           04/28/2017 13:56:56 PAGE 33  

1856   2              if((CANTRASTEMINFOR[8] & 0x40) == 0x00) //原点复归结束
1857   2              {
1858   3                  Servomotor_original = 1; //伺服原点标志建立
1859   3                  returnvalue = 0xE1; //关闭使能，复归倾倒电机，复归步进电机
1860   3                  system_crtl.AUTOsystem_command = 3;
1861   3              }
1862   2              break;
1863   2      
1864   2          case 3:
1865   2              //if(((CANTRASTEMINFOR[8]&0x08)==0x08)&&((CANTRASTEMINFOR[8]&0x20)==0x20))
1866   2              //if((CANTRASTEMINFOR[8]&0x08)==0x08)
1867   2              //{
1868   2              system_crtl.AUTOsystem_command = 0;
1869   2              CANcomand = 0x00;
1870   2              nCANcomand = 0;
1871   2              CANINDEX = 0;
1872   2              //nCANDate1=0;
1873   2              //自动运行结束上报信息参数
1874   2              AUTOCMD_STATE = 0XC3;
1875   2              T0Counter8 = 21;
1876   2              AUTOCMD_TIME = 0;
1877   2              //}
1878   2              break;
1879   2      
1880   2          default:
1881   2              break;
1882   2          }
1883   1          return returnvalue;
1884   1      }
1885          
1886          //
1887          void CANsetpraback(void)
1888          {
1889   1          unsigned char i;
1890   1          unsigned char sum;
1891   1      
1892   1          switch(AUTOCMD_CHECK)
1893   1          {
1894   2          case 0xFC:
1895   2              CANTXBUF_ZKB.normal_buf.address1 = CANaddress1;
1896   2              CANTXBUF_ZKB.normal_buf.index = CANINDEX;
1897   2              CANTXBUF_ZKB.normal_buf.command = AUTOCMD_CHECK;
1898   2              CANTXBUF_ZKB.normal_buf.data1 = CANTRASTEMINFOR[8]; //伺服状态传感器状态
1899   2              CANTXBUF_ZKB.normal_buf.data2 = Servomotor_original;
1900   2              CANTXBUF_ZKB.normal_buf.data3 = system_crtl.AUTOsystem_command; //模块运行情况
1901   2              CANTXBUF_ZKB.normal_buf.data4 = system_crtl.AUTOsystem_alarm1; //运行状态报警
1902   2              break;
1903   2      
1904   2          default:
1905   2              CANTXBUF_ZKB.normal_buf.address1 = CANaddress1;
1906   2              CANTXBUF_ZKB.normal_buf.index = CANINDEX;
1907   2              CANTXBUF_ZKB.normal_buf.command = CANcomand;
1908   2              CANTXBUF_ZKB.normal_buf.data1 = Runmode;
1909   2              CANTXBUF_ZKB.normal_buf.data2 = 0X22;
1910   2              CANTXBUF_ZKB.normal_buf.data3 = 0X33;
1911   2              CANTXBUF_ZKB.normal_buf.data4 = 0;
1912   2              break;
1913   2          }
1914   1          sum = 0;
1915   1          i = 0;
1916   1          do
1917   1          {
C51 COMPILER V9.56.0.0   YAOPING                                                           04/28/2017 13:56:56 PAGE 34  

1918   2              sum += CANTXBUF_ZKB.buf[i];
1919   2              i++;
1920   2          } while(i < 7);
1921   1          CANTXBUF_ZKB.normal_buf.checkout = sum;
1922   1          can1_transmit(TX_MSGNUM_ZKB, CANTXBUF_ZKB.buf);
1923   1      }
1924          
1925          //
1926          void CANsteminforback(void)
1927          {
1928   1          unsigned char i;
1929   1          unsigned char sum;
1930   1          unsigned char mj;
1931   1          if(T0Counter3 >= 50) //200ms时间定时
1932   1          {
1933   2              T0Counter3 = 0;
1934   2              for(mj = 0; mj < 5; mj++)
1935   2              {
1936   3                  CANTXBUF_ZKB.normal_buf.address1 = 0X01;
1937   3                  CANTXBUF_ZKB.normal_buf.index = mj;
1938   3                  CANTXBUF_ZKB.normal_buf.command = 0XC1;
1939   3                  CANTXBUF_ZKB.normal_buf.data1 = CANTRASTEMINFOR[4 * mj + 0];
1940   3                  CANTXBUF_ZKB.normal_buf.data2 = CANTRASTEMINFOR[4 * mj + 1];
1941   3                  CANTXBUF_ZKB.normal_buf.data3 = CANTRASTEMINFOR[4 * mj + 2];
1942   3                  CANTXBUF_ZKB.normal_buf.data4 = CANTRASTEMINFOR[4 * mj + 3];
1943   3                  sum = 0;
1944   3                  i = 0;
1945   3                  do
1946   3                  {
1947   4                      sum += CANTXBUF_ZKB.buf[i];
1948   4                      i++;
1949   4                  } while(i < 7);
1950   3                  CANTXBUF_ZKB.normal_buf.checkout = sum;
1951   3                  can1_transmit(TX_MSGNUM_ZKB, CANTXBUF_ZKB.buf);
1952   3              }
1953   2              LED3 = !LED3;
1954   2          }
1955   1      }
1956          
1957          //主动上传信息
1958          void ActiveCANtransfer(void)//CAN参数主动上传
1959          {
1960   1          unsigned char i = 0;
1961   1          unsigned char sum = 0;
1962   1          if(repair_flag == 0x00) return;
1963   1          if(T0Counter8 > 50)
1964   1          {
1965   2              T0Counter8 = 0;
1966   2              //if(AUTOCMD_STATE==0Xc2||AUTOCMD_STATE==0Xc3||AUTOCMD_STATE==0Xc4)
1967   2              if(AUTOCMD_STATE != 0)
1968   2              {
1969   3                  TR0  = 0;
1970   3                  WDTCN = 0xA5;
1971   3                  CANTXBUF_ZKB.normal_buf.address1 = CANaddress1;
1972   3                  CANTXBUF_ZKB.normal_buf.index = CANINDEX;
1973   3                  CANTXBUF_ZKB.normal_buf.command = AUTOCMD_STATE;
1974   3                  CANTXBUF_ZKB.normal_buf.data1 = CANTRASTEMINFOR[8]; //伺服状态传感器状态
1975   3                  CANTXBUF_ZKB.normal_buf.data2 = Servomotor_original;
1976   3                  CANTXBUF_ZKB.normal_buf.data3 = system_crtl.AUTOsystem_command; //模块运行情况
1977   3                  CANTXBUF_ZKB.normal_buf.data4 = system_crtl.AUTOsystem_alarm1; //运行状态报警
1978   3                  sum = 0;
1979   3                  i = 0;
C51 COMPILER V9.56.0.0   YAOPING                                                           04/28/2017 13:56:56 PAGE 35  

1980   3                  do
1981   3                  {
1982   4                      sum = sum + CANTXBUF_ZKB.buf[i];
1983   4                      i++;
1984   4                  } while(i < 7);
1985   3                  CANTXBUF_ZKB.normal_buf.checkout = sum;
1986   3                  //EIE2 &= 0xDF;
1987   3                  can1_transmit(TX_MSGNUM_ZKB, CANTXBUF_ZKB.buf);
1988   3                  //EIE2 |= 0x20;
1989   3                  AUTOCMD_TIME = AUTOCMD_TIME + 1;
1990   3                  //if(AUTOCMD_TIME>=3)
1991   3                  //{
1992   3                  AUTOCMD_STATE = 0;
1993   3                  AUTOCMD_TIME = 0;
1994   3                  //}
1995   3                  TR0  = 1;
1996   3      
1997   3              }
1998   2      
1999   2          }
2000   1      }
2001          
2002          //非主动上传信息
2003          void UnactiveCANtransfer(void)//CAN参数应答上传
2004          {
2005   1          switch(CANcomand)
2006   1          {
2007   2      
2008   2          case 0xA0:
2009   2              CANsetpraback();
2010   2              CANcomand = 0;
2011   2              nCANcomand = 0;
2012   2              CANINFOR_FLAG = NO;
2013   2              break;
2014   2          case 0xA1:
2015   2              CANsetpraback();
2016   2              CANcomand = 0;
2017   2              nCANcomand = 0;
2018   2              CANINFOR_FLAG = NO;
2019   2              break;
2020   2      
2021   2          case 0xA4:
2022   2              CANsetpraback();
2023   2              CANcomand = 0;
2024   2              nCANcomand = 0;
2025   2              CANINFOR_FLAG = NO;
2026   2              break;
2027   2          case 0xA5:
2028   2              CANsetpraback();
2029   2              CANcomand = 0;
2030   2              nCANcomand = 0;
2031   2              CANINFOR_FLAG = NO;
2032   2              break;
2033   2          case 0xA6:
2034   2              CANsetpraback();
2035   2              CANcomand = 0;
2036   2              nCANcomand = 0;
2037   2              CANINFOR_FLAG = NO;
2038   2              break;
2039   2          case 0xA7:
2040   2              CANsetpraback();
2041   2              CANcomand = 0;
C51 COMPILER V9.56.0.0   YAOPING                                                           04/28/2017 13:56:56 PAGE 36  

2042   2              nCANcomand = 0;
2043   2              CANINFOR_FLAG = NO;
2044   2              break;
2045   2          case 0xA8:
2046   2              CANsetpraback();
2047   2              CANcomand = 0;
2048   2              nCANcomand = 0;
2049   2              CANINFOR_FLAG = NO;
2050   2              break;
2051   2          case 0xA9:
2052   2              CANsetpraback();
2053   2              CANcomand = 0;
2054   2              nCANcomand = 0;
2055   2              CANINFOR_FLAG = NO;
2056   2              break;
2057   2          case 0xAA:
2058   2              CANsetpraback();
2059   2              CANcomand = 0;
2060   2              nCANcomand = 0;
2061   2              CANINFOR_FLAG = NO;
2062   2              break;
2063   2          case 0xAB:
2064   2              CANsetpraback();
2065   2              CANcomand = 0;
2066   2              nCANcomand = 0;
2067   2              CANINFOR_FLAG = NO;
2068   2              break;
2069   2          case 0xAC:
2070   2              CANsetpraback();
2071   2              CANcomand = 0;
2072   2              nCANcomand = 0;
2073   2              CANINFOR_FLAG = NO;
2074   2              break;
2075   2          case 0xC0://读取所有工位信息
2076   2              TRANFORSATATIONINFOR();
2077   2              CANcomand = 0;
2078   2              nCANcomand = 0;
2079   2              break;
2080   2          default:
2081   2              break;
2082   2          }
2083   1          switch(AUTOCMD_CHECK)
2084   1          {
2085   2          case 1:
2086   2              CANsetpraback();
2087   2              AUTOCMD_CHECK = 0;
2088   2      
2089   2              break;
2090   2          case 0xFC://自动模式查询
2091   2              if(repair_flag != 0x00) //如果等于零 查询模式不返回信息
2092   2              {
2093   3                  CANsetpraback();
2094   3              }
2095   2              AUTOCMD_CHECK = 0;
2096   2              //CANcomand=0;
2097   2              //nCANcomand=0;
2098   2              CANINFOR_FLAG = NO;
2099   2              break;
2100   2          default:
2101   2              break;
2102   2          }
2103   1      }
C51 COMPILER V9.56.0.0   YAOPING                                                           04/28/2017 13:56:56 PAGE 37  

2104          
2105          //
2106          void TRANFORSATATIONINFOR(void)//读取所有工位信息
2107          {
2108   1          unsigned char i;
2109   1          unsigned char sum;
2110   1          CANTXBUF_ZKB.normal_buf.address1 = CANaddress1;
2111   1          CANTXBUF_ZKB.normal_buf.index = 0;
2112   1          CANTXBUF_ZKB.normal_buf.command = CANcomand;
2113   1          CANTXBUF_ZKB.normal_buf.data1 = Servopara[0];
2114   1          CANTXBUF_ZKB.normal_buf.data2 = Servopara[1];
2115   1          CANTXBUF_ZKB.normal_buf.data3 = Servopara[2];
2116   1          CANTXBUF_ZKB.normal_buf.data4 = Servopara[3];
2117   1          sum = 0;
2118   1          i = 0;
2119   1          do
2120   1          {
2121   2              sum += CANTXBUF_ZKB.buf[i];
2122   2              i++;
2123   2          } while(i < 7);
2124   1          CANTXBUF_ZKB.normal_buf.checkout = sum;
2125   1          can1_transmit(TX_MSGNUM_ZKB, CANTXBUF_ZKB.buf);
2126   1      
2127   1          CANTXBUF_ZKB.normal_buf.address1 = CANaddress1;
2128   1          CANTXBUF_ZKB.normal_buf.index = 1;
2129   1          CANTXBUF_ZKB.normal_buf.command = CANcomand;
2130   1          CANTXBUF_ZKB.normal_buf.data1 = Servopara[4];
2131   1          CANTXBUF_ZKB.normal_buf.data2 = Servopara[5];
2132   1          CANTXBUF_ZKB.normal_buf.data3 = Servopara[6];
2133   1          CANTXBUF_ZKB.normal_buf.data4 = Servopara[7];
2134   1          sum = 0;
2135   1          i = 0;
2136   1          do
2137   1          {
2138   2              sum += CANTXBUF_ZKB.buf[i];
2139   2              i++;
2140   2          } while(i < 7);
2141   1          CANTXBUF_ZKB.normal_buf.checkout = sum;
2142   1          can1_transmit(TX_MSGNUM_ZKB, CANTXBUF_ZKB.buf);
2143   1          CANTXBUF_ZKB.normal_buf.address1 = CANaddress1;
2144   1          CANTXBUF_ZKB.normal_buf.index = 2;
2145   1          CANTXBUF_ZKB.normal_buf.command = CANcomand;
2146   1          CANTXBUF_ZKB.normal_buf.data1 = Servopara[8];
2147   1          CANTXBUF_ZKB.normal_buf.data2 = Servopara[9];
2148   1          CANTXBUF_ZKB.normal_buf.data3 = Servopara[10];
2149   1          CANTXBUF_ZKB.normal_buf.data4 = Servopara[11];
2150   1          sum = 0;
2151   1          i = 0;
2152   1          do
2153   1          {
2154   2              sum += CANTXBUF_ZKB.buf[i];
2155   2              i++;
2156   2          } while(i < 7);
2157   1          CANTXBUF_ZKB.normal_buf.checkout = sum;
2158   1          can1_transmit(TX_MSGNUM_ZKB, CANTXBUF_ZKB.buf);
2159   1          CANTXBUF_ZKB.normal_buf.address1 = CANaddress1;
2160   1          CANTXBUF_ZKB.normal_buf.index = 3;
2161   1          CANTXBUF_ZKB.normal_buf.command = CANcomand;
2162   1          CANTXBUF_ZKB.normal_buf.data1 = Servopara[12];
2163   1          CANTXBUF_ZKB.normal_buf.data2 = Servopara[13];
2164   1          CANTXBUF_ZKB.normal_buf.data3 = Servopara[14];
2165   1          CANTXBUF_ZKB.normal_buf.data4 = Servopara[15];
C51 COMPILER V9.56.0.0   YAOPING                                                           04/28/2017 13:56:56 PAGE 38  

2166   1          sum = 0;
2167   1          i = 0;
2168   1          do
2169   1          {
2170   2              sum += CANTXBUF_ZKB.buf[i];
2171   2              i++;
2172   2          } while(i < 7);
2173   1          CANTXBUF_ZKB.normal_buf.checkout = sum;
2174   1          can1_transmit(TX_MSGNUM_ZKB, CANTXBUF_ZKB.buf);
2175   1      
2176   1      
2177   1      
2178   1      
2179   1      
2180   1          CANTXBUF_ZKB.normal_buf.address1 = CANaddress1;
2181   1          CANTXBUF_ZKB.normal_buf.index = 4;
2182   1          CANTXBUF_ZKB.normal_buf.command = CANcomand;
2183   1          CANTXBUF_ZKB.normal_buf.data1 = Servopara[16];
2184   1          CANTXBUF_ZKB.normal_buf.data2 = Servopara[17];
2185   1          CANTXBUF_ZKB.normal_buf.data3 = Servopara[18];
2186   1          CANTXBUF_ZKB.normal_buf.data4 = Servopara[19];
2187   1          sum = 0;
2188   1          i = 0;
2189   1          do
2190   1          {
2191   2              sum += CANTXBUF_ZKB.buf[i];
2192   2              i++;
2193   2          } while(i < 7);
2194   1          CANTXBUF_ZKB.normal_buf.checkout = sum;
2195   1          can1_transmit(TX_MSGNUM_ZKB, CANTXBUF_ZKB.buf);
2196   1      
2197   1          CANTXBUF_ZKB.normal_buf.address1 = CANaddress1;
2198   1          CANTXBUF_ZKB.normal_buf.index = 5;
2199   1          CANTXBUF_ZKB.normal_buf.command = CANcomand;
2200   1          CANTXBUF_ZKB.normal_buf.data1 = Servopara[20];
2201   1          CANTXBUF_ZKB.normal_buf.data2 = Servopara[21];
2202   1          CANTXBUF_ZKB.normal_buf.data3 = Servopara[22];
2203   1          CANTXBUF_ZKB.normal_buf.data4 = Servopara[23];
2204   1          sum = 0;
2205   1          i = 0;
2206   1          do
2207   1          {
2208   2              sum += CANTXBUF_ZKB.buf[i];
2209   2              i++;
2210   2          } while(i < 7);
2211   1          CANTXBUF_ZKB.normal_buf.checkout = sum;
2212   1          can1_transmit(TX_MSGNUM_ZKB, CANTXBUF_ZKB.buf);
2213   1          CANTXBUF_ZKB.normal_buf.address1 = CANaddress1;
2214   1          CANTXBUF_ZKB.normal_buf.index = 6;
2215   1          CANTXBUF_ZKB.normal_buf.command = CANcomand;
2216   1          CANTXBUF_ZKB.normal_buf.data1 = Servopara[24];
2217   1          CANTXBUF_ZKB.normal_buf.data2 = Servopara[25];
2218   1          CANTXBUF_ZKB.normal_buf.data3 = Servopara[26];
2219   1          CANTXBUF_ZKB.normal_buf.data4 = Servopara[27];
2220   1          sum = 0;
2221   1          i = 0;
2222   1          do
2223   1          {
2224   2              sum += CANTXBUF_ZKB.buf[i];
2225   2              i++;
2226   2          } while(i < 7);
2227   1          CANTXBUF_ZKB.normal_buf.checkout = sum;
C51 COMPILER V9.56.0.0   YAOPING                                                           04/28/2017 13:56:56 PAGE 39  

2228   1          can1_transmit(TX_MSGNUM_ZKB, CANTXBUF_ZKB.buf);
2229   1          CANTXBUF_ZKB.normal_buf.address1 = CANaddress1;
2230   1          CANTXBUF_ZKB.normal_buf.index = 7;
2231   1          CANTXBUF_ZKB.normal_buf.command = CANcomand;
2232   1          CANTXBUF_ZKB.normal_buf.data1 = Servopara[28];
2233   1          CANTXBUF_ZKB.normal_buf.data2 = Servopara[29];
2234   1          CANTXBUF_ZKB.normal_buf.data3 = Servopara[30];
2235   1          CANTXBUF_ZKB.normal_buf.data4 = Servopara[31];
2236   1          sum = 0;
2237   1          i = 0;
2238   1          do
2239   1          {
2240   2              sum += CANTXBUF_ZKB.buf[i];
2241   2              i++;
2242   2          } while(i < 7);
2243   1          CANTXBUF_ZKB.normal_buf.checkout = sum;
2244   1          can1_transmit(TX_MSGNUM_ZKB, CANTXBUF_ZKB.buf);
2245   1      
2246   1      
2247   1      
2248   1          CANTXBUF_ZKB.normal_buf.address1 = CANaddress1;
2249   1          CANTXBUF_ZKB.normal_buf.index = 8;
2250   1          CANTXBUF_ZKB.normal_buf.command = CANcomand;
2251   1          CANTXBUF_ZKB.normal_buf.data1 = Servopara[32];
2252   1          CANTXBUF_ZKB.normal_buf.data2 = Servopara[33];
2253   1          CANTXBUF_ZKB.normal_buf.data3 = Servopara[34];
2254   1          CANTXBUF_ZKB.normal_buf.data4 = Servopara[35];
2255   1          sum = 0;
2256   1          i = 0;
2257   1          do
2258   1          {
2259   2              sum += CANTXBUF_ZKB.buf[i];
2260   2              i++;
2261   2          } while(i < 7);
2262   1          CANTXBUF_ZKB.normal_buf.checkout = sum;
2263   1          can1_transmit(TX_MSGNUM_ZKB, CANTXBUF_ZKB.buf);
2264   1      
2265   1          CANTXBUF_ZKB.normal_buf.address1 = CANaddress1;
2266   1          CANTXBUF_ZKB.normal_buf.index = 9;
2267   1          CANTXBUF_ZKB.normal_buf.command = CANcomand;
2268   1          CANTXBUF_ZKB.normal_buf.data1 = Servopara[36];
2269   1          CANTXBUF_ZKB.normal_buf.data2 = Servopara[37];
2270   1          CANTXBUF_ZKB.normal_buf.data3 = Servopara[38];
2271   1          CANTXBUF_ZKB.normal_buf.data4 = Servopara[39];
2272   1          sum = 0;
2273   1          i = 0;
2274   1          do
2275   1          {
2276   2              sum += CANTXBUF_ZKB.buf[i];
2277   2              i++;
2278   2          } while(i < 7);
2279   1          CANTXBUF_ZKB.normal_buf.checkout = sum;
2280   1          can1_transmit(TX_MSGNUM_ZKB, CANTXBUF_ZKB.buf);
2281   1          CANTXBUF_ZKB.normal_buf.address1 = CANaddress1;
2282   1          CANTXBUF_ZKB.normal_buf.index = 10;
2283   1          CANTXBUF_ZKB.normal_buf.command = CANcomand;
2284   1          CANTXBUF_ZKB.normal_buf.data1 = Servopara[40];
2285   1          CANTXBUF_ZKB.normal_buf.data2 = Servopara[41];
2286   1          CANTXBUF_ZKB.normal_buf.data3 = Servopara[42];
2287   1          CANTXBUF_ZKB.normal_buf.data4 = Servopara[43];
2288   1          sum = 0;
2289   1          i = 0;
C51 COMPILER V9.56.0.0   YAOPING                                                           04/28/2017 13:56:56 PAGE 40  

2290   1          do
2291   1          {
2292   2              sum += CANTXBUF_ZKB.buf[i];
2293   2              i++;
2294   2          } while(i < 7);
2295   1          CANTXBUF_ZKB.normal_buf.checkout = sum;
2296   1          can1_transmit(TX_MSGNUM_ZKB, CANTXBUF_ZKB.buf);
2297   1          CANTXBUF_ZKB.normal_buf.address1 = CANaddress1;
2298   1          CANTXBUF_ZKB.normal_buf.index = 11;
2299   1          CANTXBUF_ZKB.normal_buf.command = CANcomand;
2300   1          CANTXBUF_ZKB.normal_buf.data1 = Servopara[44];
2301   1          CANTXBUF_ZKB.normal_buf.data2 = Servopara[45];
2302   1          CANTXBUF_ZKB.normal_buf.data3 = Servopara[46];
2303   1          CANTXBUF_ZKB.normal_buf.data4 = Servopara[47];
2304   1          sum = 0;
2305   1          i = 0;
2306   1          do
2307   1          {
2308   2              sum += CANTXBUF_ZKB.buf[i];
2309   2              i++;
2310   2          } while(i < 7);
2311   1          CANTXBUF_ZKB.normal_buf.checkout = sum;
2312   1          can1_transmit(TX_MSGNUM_ZKB, CANTXBUF_ZKB.buf);
2313   1      
2314   1          CANTXBUF_ZKB.normal_buf.address1 = CANaddress1;
2315   1          CANTXBUF_ZKB.normal_buf.index = 12;
2316   1          CANTXBUF_ZKB.normal_buf.command = CANcomand;
2317   1          CANTXBUF_ZKB.normal_buf.data1 = Servopara[48];
2318   1          CANTXBUF_ZKB.normal_buf.data2 = Servopara[49];
2319   1          CANTXBUF_ZKB.normal_buf.data3 = Servopara[50];
2320   1          CANTXBUF_ZKB.normal_buf.data4 = Servopara[51];
2321   1          sum = 0;
2322   1          i = 0;
2323   1          do
2324   1          {
2325   2              sum += CANTXBUF_ZKB.buf[i];
2326   2              i++;
2327   2          } while(i < 7);
2328   1          CANTXBUF_ZKB.normal_buf.checkout = sum;
2329   1          can1_transmit(TX_MSGNUM_ZKB, CANTXBUF_ZKB.buf);
2330   1      
2331   1          CANTXBUF_ZKB.normal_buf.address1 = CANaddress1;
2332   1          CANTXBUF_ZKB.normal_buf.index = 13;
2333   1          CANTXBUF_ZKB.normal_buf.command = CANcomand;
2334   1          CANTXBUF_ZKB.normal_buf.data1 = Servopara[52];
2335   1          CANTXBUF_ZKB.normal_buf.data2 = Servopara[53];
2336   1          CANTXBUF_ZKB.normal_buf.data3 = Servopara[54];
2337   1          CANTXBUF_ZKB.normal_buf.data4 = Servopara[55];
2338   1          sum = 0;
2339   1          i = 0;
2340   1          do
2341   1          {
2342   2              sum += CANTXBUF_ZKB.buf[i];
2343   2              i++;
2344   2          } while(i < 7);
2345   1          CANTXBUF_ZKB.normal_buf.checkout = sum;
2346   1          can1_transmit(TX_MSGNUM_ZKB, CANTXBUF_ZKB.buf);
2347   1          CANTXBUF_ZKB.normal_buf.address1 = CANaddress1;
2348   1          CANTXBUF_ZKB.normal_buf.index = 14;
2349   1          CANTXBUF_ZKB.normal_buf.command = CANcomand;
2350   1          CANTXBUF_ZKB.normal_buf.data1 = Servopara[56];
2351   1          CANTXBUF_ZKB.normal_buf.data2 = Servopara[57];
C51 COMPILER V9.56.0.0   YAOPING                                                           04/28/2017 13:56:56 PAGE 41  

2352   1          CANTXBUF_ZKB.normal_buf.data3 = Servopara[58];
2353   1          CANTXBUF_ZKB.normal_buf.data4 = Servopara[59];
2354   1          sum = 0;
2355   1          i = 0;
2356   1          do
2357   1          {
2358   2              sum += CANTXBUF_ZKB.buf[i];
2359   2              i++;
2360   2          } while(i < 7);
2361   1          CANTXBUF_ZKB.normal_buf.checkout = sum;
2362   1          can1_transmit(TX_MSGNUM_ZKB, CANTXBUF_ZKB.buf);
2363   1          CANTXBUF_ZKB.normal_buf.address1 = CANaddress1;
2364   1          CANTXBUF_ZKB.normal_buf.index = 15;
2365   1          CANTXBUF_ZKB.normal_buf.command = CANcomand;
2366   1          CANTXBUF_ZKB.normal_buf.data1 = Servopara[60];
2367   1          CANTXBUF_ZKB.normal_buf.data2 = Servopara[61];
2368   1          CANTXBUF_ZKB.normal_buf.data3 = Servopara[62];
2369   1          CANTXBUF_ZKB.normal_buf.data4 = Servopara[63];
2370   1          sum = 0;
2371   1          i = 0;
2372   1          do
2373   1          {
2374   2              sum += CANTXBUF_ZKB.buf[i];
2375   2              i++;
2376   2          } while(i < 7);
2377   1          CANTXBUF_ZKB.normal_buf.checkout = sum;
2378   1          can1_transmit(TX_MSGNUM_ZKB, CANTXBUF_ZKB.buf);
2379   1      
2380   1          CANTXBUF_ZKB.normal_buf.address1 = CANaddress1;
2381   1          CANTXBUF_ZKB.normal_buf.index = 16;
2382   1          CANTXBUF_ZKB.normal_buf.command = CANcomand;
2383   1          CANTXBUF_ZKB.normal_buf.data1 = Servopara[64];
2384   1          CANTXBUF_ZKB.normal_buf.data2 = Servopara[65];
2385   1          CANTXBUF_ZKB.normal_buf.data3 = Servopara[66];
2386   1          CANTXBUF_ZKB.normal_buf.data4 = Servopara[67];
2387   1          sum = 0;
2388   1          i = 0;
2389   1          do
2390   1          {
2391   2              sum += CANTXBUF_ZKB.buf[i];
2392   2              i++;
2393   2          } while(i < 7);
2394   1          CANTXBUF_ZKB.normal_buf.checkout = sum;
2395   1          can1_transmit(TX_MSGNUM_ZKB, CANTXBUF_ZKB.buf);
2396   1      
2397   1          CANTXBUF_ZKB.normal_buf.address1 = CANaddress1;
2398   1          CANTXBUF_ZKB.normal_buf.index = 17;
2399   1          CANTXBUF_ZKB.normal_buf.command = CANcomand;
2400   1          CANTXBUF_ZKB.normal_buf.data1 = Servopara[68];
2401   1          CANTXBUF_ZKB.normal_buf.data2 = Servopara[69];
2402   1          CANTXBUF_ZKB.normal_buf.data3 = Servopara[70];
2403   1          CANTXBUF_ZKB.normal_buf.data4 = Servopara[71];
2404   1          sum = 0;
2405   1          i = 0;
2406   1          do
2407   1          {
2408   2              sum += CANTXBUF_ZKB.buf[i];
2409   2              i++;
2410   2          } while(i < 7);
2411   1          CANTXBUF_ZKB.normal_buf.checkout = sum;
2412   1          can1_transmit(TX_MSGNUM_ZKB, CANTXBUF_ZKB.buf);
2413   1          CANTXBUF_ZKB.normal_buf.address1 = CANaddress1;
C51 COMPILER V9.56.0.0   YAOPING                                                           04/28/2017 13:56:56 PAGE 42  

2414   1          CANTXBUF_ZKB.normal_buf.index = 18;
2415   1          CANTXBUF_ZKB.normal_buf.command = CANcomand;
2416   1          CANTXBUF_ZKB.normal_buf.data1 = Servopara[72];
2417   1          CANTXBUF_ZKB.normal_buf.data2 = Servopara[73];
2418   1          CANTXBUF_ZKB.normal_buf.data3 = Servopara[74];
2419   1          CANTXBUF_ZKB.normal_buf.data4 = Servopara[75];
2420   1          sum = 0;
2421   1          i = 0;
2422   1          do
2423   1          {
2424   2              sum += CANTXBUF_ZKB.buf[i];
2425   2              i++;
2426   2          } while(i < 7);
2427   1          CANTXBUF_ZKB.normal_buf.checkout = sum;
2428   1          can1_transmit(TX_MSGNUM_ZKB, CANTXBUF_ZKB.buf);
2429   1          CANTXBUF_ZKB.normal_buf.address1 = CANaddress1;
2430   1          CANTXBUF_ZKB.normal_buf.index = 19;
2431   1          CANTXBUF_ZKB.normal_buf.command = CANcomand;
2432   1          CANTXBUF_ZKB.normal_buf.data1 = Servopara[76];
2433   1          CANTXBUF_ZKB.normal_buf.data2 = Servopara[77];
2434   1          CANTXBUF_ZKB.normal_buf.data3 = Servopara[78];
2435   1          CANTXBUF_ZKB.normal_buf.data4 = Servopara[79];
2436   1          sum = 0;
2437   1          i = 0;
2438   1          do
2439   1          {
2440   2              sum += CANTXBUF_ZKB.buf[i];
2441   2              i++;
2442   2          } while(i < 7);
2443   1          CANTXBUF_ZKB.normal_buf.checkout = sum;
2444   1          can1_transmit(TX_MSGNUM_ZKB, CANTXBUF_ZKB.buf);
2445   1      
2446   1          CANTXBUF_ZKB.normal_buf.address1 = CANaddress1;
2447   1          CANTXBUF_ZKB.normal_buf.index = 20;
2448   1          CANTXBUF_ZKB.normal_buf.command = CANcomand;
2449   1          CANTXBUF_ZKB.normal_buf.data1 = Servopara[80];
2450   1          CANTXBUF_ZKB.normal_buf.data2 = Servopara[81];
2451   1          CANTXBUF_ZKB.normal_buf.data3 = Servopara[82];
2452   1          CANTXBUF_ZKB.normal_buf.data4 = Servopara[83];
2453   1          sum = 0;
2454   1          i = 0;
2455   1          do
2456   1          {
2457   2              sum += CANTXBUF_ZKB.buf[i];
2458   2              i++;
2459   2          } while(i < 7);
2460   1          CANTXBUF_ZKB.normal_buf.checkout = sum;
2461   1          can1_transmit(TX_MSGNUM_ZKB, CANTXBUF_ZKB.buf);
2462   1      
2463   1          CANTXBUF_ZKB.normal_buf.address1 = CANaddress1;
2464   1          CANTXBUF_ZKB.normal_buf.index = 21;
2465   1          CANTXBUF_ZKB.normal_buf.command = CANcomand;
2466   1          CANTXBUF_ZKB.normal_buf.data1 = Servopara[84];
2467   1          CANTXBUF_ZKB.normal_buf.data2 = Servopara[85];
2468   1          CANTXBUF_ZKB.normal_buf.data3 = Servopara[86];
2469   1          CANTXBUF_ZKB.normal_buf.data4 = Servopara[87];
2470   1          sum = 0;
2471   1          i = 0;
2472   1          do
2473   1          {
2474   2              sum += CANTXBUF_ZKB.buf[i];
2475   2              i++;
C51 COMPILER V9.56.0.0   YAOPING                                                           04/28/2017 13:56:56 PAGE 43  

2476   2          } while(i < 7);
2477   1          CANTXBUF_ZKB.normal_buf.checkout = sum;
2478   1          can1_transmit(TX_MSGNUM_ZKB, CANTXBUF_ZKB.buf);
2479   1      
2480   1          CANTXBUF_ZKB.normal_buf.address1 = CANaddress1;
2481   1          CANTXBUF_ZKB.normal_buf.index = 22;
2482   1          CANTXBUF_ZKB.normal_buf.command = CANcomand;
2483   1          CANTXBUF_ZKB.normal_buf.data1 = Servopara[88];
2484   1          CANTXBUF_ZKB.normal_buf.data2 = Servopara[89];
2485   1          CANTXBUF_ZKB.normal_buf.data3 = Servopara[90];
2486   1          CANTXBUF_ZKB.normal_buf.data4 = Servopara[91];
2487   1          sum = 0;
2488   1          i = 0;
2489   1          do
2490   1          {
2491   2              sum += CANTXBUF_ZKB.buf[i];
2492   2              i++;
2493   2          } while(i < 7);
2494   1          CANTXBUF_ZKB.normal_buf.checkout = sum;
2495   1          can1_transmit(TX_MSGNUM_ZKB, CANTXBUF_ZKB.buf);
2496   1          CANTXBUF_ZKB.normal_buf.address1 = CANaddress1;
2497   1          CANTXBUF_ZKB.normal_buf.index = 23;
2498   1          CANTXBUF_ZKB.normal_buf.command = CANcomand;
2499   1          CANTXBUF_ZKB.normal_buf.data1 = Servopara[92];
2500   1          CANTXBUF_ZKB.normal_buf.data2 = Servopara[93];
2501   1          CANTXBUF_ZKB.normal_buf.data3 = Servopara[94];
2502   1          CANTXBUF_ZKB.normal_buf.data4 = Servopara[95];
2503   1          sum = 0;
2504   1          i = 0;
2505   1          do
2506   1          {
2507   2              sum += CANTXBUF_ZKB.buf[i];
2508   2              i++;
2509   2          } while(i < 7);
2510   1          CANTXBUF_ZKB.normal_buf.checkout = sum;
2511   1          can1_transmit(TX_MSGNUM_ZKB, CANTXBUF_ZKB.buf);
2512   1          CANTXBUF_ZKB.normal_buf.address1 = CANaddress1;
2513   1          CANTXBUF_ZKB.normal_buf.index = 24;
2514   1          CANTXBUF_ZKB.normal_buf.command = CANcomand;
2515   1          CANTXBUF_ZKB.normal_buf.data1 = Servopara[96];
2516   1          CANTXBUF_ZKB.normal_buf.data2 = Servopara[97];
2517   1          CANTXBUF_ZKB.normal_buf.data3 = Servopara[98];
2518   1          CANTXBUF_ZKB.normal_buf.data4 = Servopara[99];
2519   1          sum = 0;
2520   1          i = 0;
2521   1          do
2522   1          {
2523   2              sum += CANTXBUF_ZKB.buf[i];
2524   2              i++;
2525   2          } while(i < 7);
2526   1          CANTXBUF_ZKB.normal_buf.checkout = sum;
2527   1          can1_transmit(TX_MSGNUM_ZKB, CANTXBUF_ZKB.buf);
2528   1          CANTXBUF_ZKB.normal_buf.address1 = CANaddress1;
2529   1          CANTXBUF_ZKB.normal_buf.index = 25;
2530   1          CANTXBUF_ZKB.normal_buf.command = CANcomand;
2531   1          CANTXBUF_ZKB.normal_buf.data1 = Servopara[100];
2532   1          CANTXBUF_ZKB.normal_buf.data2 = Servopara[101];
2533   1          CANTXBUF_ZKB.normal_buf.data3 = Servopara[102];
2534   1          CANTXBUF_ZKB.normal_buf.data4 = Servopara[103];
2535   1          sum = 0;
2536   1          i = 0;
2537   1          do
C51 COMPILER V9.56.0.0   YAOPING                                                           04/28/2017 13:56:56 PAGE 44  

2538   1          {
2539   2              sum += CANTXBUF_ZKB.buf[i];
2540   2              i++;
2541   2          } while(i < 7);
2542   1          CANTXBUF_ZKB.normal_buf.checkout = sum;
2543   1          can1_transmit(TX_MSGNUM_ZKB, CANTXBUF_ZKB.buf);
2544   1          CANTXBUF_ZKB.normal_buf.address1 = CANaddress1;
2545   1          CANTXBUF_ZKB.normal_buf.index = 26;
2546   1          CANTXBUF_ZKB.normal_buf.command = CANcomand;
2547   1          CANTXBUF_ZKB.normal_buf.data1 = Servopara[104];
2548   1          CANTXBUF_ZKB.normal_buf.data2 = Servopara[105];
2549   1          CANTXBUF_ZKB.normal_buf.data3 = Servopara[106];
2550   1          CANTXBUF_ZKB.normal_buf.data4 = 0;
2551   1          sum = 0;
2552   1          i = 0;
2553   1          do
2554   1          {
2555   2              sum += CANTXBUF_ZKB.buf[i];
2556   2              i++;
2557   2          } while(i < 7);
2558   1          CANTXBUF_ZKB.normal_buf.checkout = sum;
2559   1          can1_transmit(TX_MSGNUM_ZKB, CANTXBUF_ZKB.buf);
2560   1      }
2561          //////////////////////////
2562          //将定义的Flash缓冲区写入Flash
2563          //////////////////////////
2564          void write_to_flash(void)
2565          {
2566   1          unsigned char xdata *pwrite ;
2567   1          unsigned char i;
2568   1          char SFRPAGE_SAVE = SFRPAGE;        // Save Current SFR page
2569   1          EA = 0; //关中断
2570   1          SFRPAGE = LEGACY_PAGE;
2571   1          FLSCL = FLSCL | 0x01; //允许写擦除flash
2572   1          PSCTL = PSCTL | 0x07; //允许写擦除flash
2573   1          pwrite = 0x00;
2574   1          *pwrite = 0;  //擦除flash
2575   1          PSCTL = PSCTL & 0xFD; //禁止擦除
2576   1          i = 0;
2577   1          do {
2578   2              *pwrite++ = Servopara[i];
2579   2              i++;
2580   2          } while(i < 107);
2581   1          PSCTL = PSCTL & 0xFA; //禁止flash写
2582   1          FLSCL = FLSCL & 0xFE; //禁止写擦除flash
2583   1          EA = 1; //开中断
2584   1          SFRPAGE = SFRPAGE_SAVE;             // Restore SFR page
2585   1      }
2586          
2587          //////////////////////////
2588          //将Flash中保存的数据读入Flash缓冲区
2589          //////////////////////////
2590          void read_from_flash(void)
2591          {
2592   1          unsigned char code *pread ;
2593   1          unsigned char i;
2594   1          char SFRPAGE_SAVE = SFRPAGE;        // Save Current SFR page
2595   1          EA = 0;
2596   1          SFRPAGE = LEGACY_PAGE;
2597   1          PSCTL = PSCTL | 0x04; //指向flash地址0～0x7f
2598   1          pread = 0x00;
2599   1          i = 0;
C51 COMPILER V9.56.0.0   YAOPING                                                           04/28/2017 13:56:56 PAGE 45  

2600   1          do {
2601   2              Servopara[i] = *pread++;
2602   2              i++;
2603   2          } while(i < 107);
2604   1          PSCTL = PSCTL & 0xFB; //恢复 64k flash
2605   1          EA = 1; // 允许全局中断
2606   1          SFRPAGE = SFRPAGE_SAVE;             // Restore SFR page
2607   1      }
2608          
2609          
2610          /*void Deviationremoval(void)//偏差清除
2611          {
2612          Send_to_Motordriver_CTL(0x01);//保持S-ON
2613          Send_to_Motordriver_CTL(0x09);//
2614          Send_to_Motordriver_CTL(0x01);//
2615          Time_FLAG=NO;
2616          
2617          }*/
2618          void init_machine(void)
2619          {
2620   1          CANaddress1 = 0x01;
2621   1          nCANcomand = 0xFB;
2622   1          CANINDEX = 0X00;
2623   1          system_crtl.AUTOsystem_command = 1;     //AUTOCMD_CHECK=1;
2624   1          T0Counter3 = 51; //尽快的定时发送清除状态类表
2625   1          Runmode = 1; //自动运行
2626   1      }
2627          //////////////////////////
2628          //         主程序
2629          //////////////////////////
2630          unsigned char buffer[8];
2631          
2632          //右侧翻转输送线反转
2633          //发送对象：2
2634          //signal:1-start、2-stop
2635          void FZSSXRightFZ(unsigned char signal)
2636          {
2637   1          unsigned char i, sum;
2638   1      
2639   1          //----------------向底层驱动板发送准备好指令---------------------------------
2640   1          CANTXBUF_ZKB.normal_buf.address1 = 0X01;
2641   1          CANTXBUF_ZKB.normal_buf.command = 0xB0;
2642   1          CANTXBUF_ZKB.normal_buf.index = signal;
2643   1          CANTXBUF_ZKB.normal_buf.data1 = 0X00;
2644   1          CANTXBUF_ZKB.normal_buf.data2 = 0X00;
2645   1          CANTXBUF_ZKB.normal_buf.data3 = 0X00;
2646   1          CANTXBUF_ZKB.normal_buf.data4 = 0X00;
2647   1          sum = 0;
2648   1          i = 0;
2649   1          do
2650   1          {
2651   2              sum += CANTXBUF_ZKB.buf[i];
2652   2              i++;
2653   2          } while(i < 7);
2654   1          CANTXBUF_ZKB.normal_buf.checkout = sum;
2655   1          can1_transmit(TX_MSGNUM_ZKB, CANTXBUF_ZKB.buf);
2656   1      }
2657          
2658          void main (void)
2659          {
2660   1          SFRPAGE = CONFIG_PAGE;
2661   1          Initial();
C51 COMPILER V9.56.0.0   YAOPING                                                           04/28/2017 13:56:56 PAGE 46  

2662   1          delay_ms(1000);
2663   1          init_machine();//上电系统复位
2664   1        
2665   1          while(1)
2666   1          {
2667   2      
2668   2              SystemControl();              //系统控制（控制信息来源，can\RS485\中断信号）
2669   2              UnactiveCANtransfer();        //CAN参数应答上传
2670   2              ActiveCANtransfer();          //CAN参数主动上传
2671   2      
2672   2            
2673   2              //Dataacquisition();            //数据采集
2674   2              /*if((CANINFOR_FLAG==NO)&&(Runmode==0x00))//CAN主动连续上传
2675   2              {
2676   2                //EIE2 &= 0xDF;
2677   2                CANsteminforback();            //系统信息上传
2678   2                //EIE2 |= 0x20;
2679   2              }*/
2680   2              RunLEDDIS();                  //运行显示
2681   2          }
2682   1      }
2683          
2684          
2685          
2686          
2687          
2688          
2689          
2690          
2691          
2692          
2693          
2694          
2695          
2696          
2697          
2698          
2699          
2700          
2701          
2702          
2703          
2704          
2705          
2706          
2707          
2708          
2709          
2710          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   8411    ----
   CONSTANT SIZE    =   4000    ----
   XDATA SIZE       =    296       3
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      8      35
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      8    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
