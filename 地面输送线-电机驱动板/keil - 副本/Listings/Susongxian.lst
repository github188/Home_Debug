C51 COMPILER V9.56.0.0   SUSONGXIAN                                                        04/28/2017 13:56:01 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE SUSONGXIAN
OBJECT MODULE PLACED IN .\Objects\Susongxian.obj
COMPILER INVOKED BY: C:\Keil_C51\C51\BIN\C51.EXE Susongxian.C OPTIMIZE(8,SPEED) BROWSE INCDIR(..\keil) DEBUG OBJECTEXTEN
                    -D PRINT(.\Listings\Susongxian.lst) TABS(2) OBJECT(.\Objects\Susongxian.obj)

line level    source

   1          /*****************************************************
   2          2016 7.26  //CANTRASTEMINFOR[13]=0x00; 注释掉增加程序响应时间
   3          增加LED4和LED5作为左右闸门原位传感器的指示灯
   4          ******************************************************/
   5          #include <c8051f040.h>                 // SFR declaration
   6          #include <math.h>
   7          #include "Susongxian.h"
   8          #include "CAN1.h"
   9          #include "intrins.h"
  10          
  11          #define CMD_CHK_MAX 10
  12          
  13          xdata unsigned char Runmode = 0;
  14          //定义定时器的软件计数器
  15          //xdata unsigned int  T0Counter1=0;  //主程序运行定时器1
  16          xdata unsigned char  T0Counter5 = 0; //
  17          xdata unsigned char  T0Counter2 = 0; //
  18          xdata unsigned char  T0Counter3 = 0; //
  19          
  20          xdata unsigned int  T0Counter6 = 0; //
  21          xdata unsigned int  T0Counter7 = 0; //故障计时器
  22          xdata unsigned char  T0Counter8 = 0;
  23          //unsigned int  T0Counter9=0;  //补药数据发送，计时用
  24          //unsigned int  T0Counter10=0; //在补药计数时使用，计数每次补药的间隔时间
  25          xdata volatile unsigned char  timer0_cn = 0;  //modbus 通讯计时用
  26          xdata unsigned char  CANcomand = 0;  //CAN命令字
  27          xdata unsigned char  nCANcomand = 0;   //防止CAN中断修改运行中的命令
  28          xdata unsigned char  AUTOnCANcomand = 0;
  29          xdata unsigned char  AUTOCMD_STATE = 0;
  30          xdata unsigned char  AUTOCMD_TIME = 0;
  31          xdata unsigned char  AUTOCMD_CHECK = 0;
  32          xdata unsigned char  temppage = 0;
  33          xdata unsigned char  strlen = 0;
  34          xdata unsigned char BPSSET = 0;
  35          xdata unsigned char IDSET = 0;
  36          xdata unsigned char Shaft1_Run_mode = 0x00;
  37          xdata unsigned long Shaft1_aim_pulse = 0;
  38          xdata unsigned char Sampleperiod = 0;
  39          xdata unsigned char INDEX_COMAND = 0;
  40          xdata unsigned char Alarm_cout = 0; //报警次数
  41          bit volatile RecFlag1 = NO;
  42          bit volatile Receive_command_finished = NO;
  43          bit Receive485_command_finished = YES;
  44          bit Time_FLAG = YES;
  45          bit Time_FLAG1 = YES;
  46          bit AUTO_FLAG = NO;
  47          bit Step_FLAG = NO;
  48          bit CANINFOR_FLAG = NO;
  49          bit ONCE_FLAG = NO;
  50          bit START_FINISHFLAG = NO;
  51          bit SAMPLE_FLAG = NO;
  52          //xdata FLASH Flash;            //定义Flash 缓冲区
  53          xdata CANTRANSDATBUF CANTXBUF_ZKB;
  54          xdata unsigned char buf[30];
C51 COMPILER V9.56.0.0   SUSONGXIAN                                                        04/28/2017 13:56:01 PAGE 2   

  55          xdata volatile unsigned char Rec1[30];
  56          xdata volatile unsigned  char RecPointer1 = 0;
  57          xdata volatile RECBUF1 RxBuf1;
  58          xdata unsigned  int   cmd_chk_cnt = 0;
  59          xdata unsigned  char Servoparastation = 0;
  60          xdata unsigned  long Servoparadisplace = 0;
  61          xdata unsigned  long Servoparaspeed = 0;
  62          xdata unsigned  long Servoparaaddtime = 0;
  63          xdata unsigned  long Servoparasubtime = 0;
  64          xdata unsigned  int ShowTime = 0;
  65          xdata unsigned  char Servopara[107];
  66          xdata volatile unsigned  char CANTRASTEMINFOR[17];
  67          xdata unsigned  char repair_flag = 0;
  68          xdata systemcrtl system_crtl;
  69          xdata Servomotordisplace  Servomotor_displace;
  70          xdata Servomotorspeed     Servomotor_speed;
  71          xdata Servomotoraddtime   Servomotor_addtime;
  72          xdata Servomotorsubtime   Servomotor_subtime;
  73          /*code unsigned int Speedvalue[2000]= { 60560,
  74          60657, 60751, 60842, 60929, 61012, 61093, 61171, 61246, 61319, 61389, 61457, 61523, 61587, 61649, 61708, 6
             -1766, 61823, 61877, 61930, 61982, 62032, 62081, 62128, 62174, 62219, 62262, 62305, 62346, 62387, 62426, 62465, 62502, 62
             -539, 62574, 62609, 62643, 62676, 62709, 62741, 62772, 62802, 62832, 62861, 62889, 62917, 62945, 62971, 62997, 63023, 630
             -48, 63073, 63097, 63121, 63144, 63167, 63189, 63211, 63233, 63254, 63274, 63295, 63315, 63334, 63354, 63373, 63391, 6341
             -0, 63428, 63445, 63463, 63480, 63497, 63513, 63530, 63546, 63562, 63577, 63593, 63608, 63622, 63637, 63651, 63666, 63680
             -, 63693, 63707, 63720, 63733, 63746, 63759, 63772, 63784, 63796, 63809, 63820, 63832, 63844, 63855, 63866, 63878,
  75          63889, 63899, 63910, 63921, 63931, 63941, 63952, 63962, 63972, 63981, 63991, 64001, 64010, 64019, 64028, 6
             -4038, 64046, 64055, 64064, 64073, 64081, 64090, 64098, 64106, 64115, 64123, 64131, 64139, 64146, 64154, 64162, 64169, 64
             -177, 64184, 64191, 64199, 64206, 64213, 64220, 64227, 64234, 64241, 64247, 64254, 64260, 64267, 64273, 64280, 64286, 642
             -92, 64299, 64305, 64311, 64317, 64323, 64329, 64334, 64340, 64346, 64352, 64357, 64363, 64368, 64374, 64379, 64385, 6439
             -0, 64395, 64400, 64405, 64411, 64416, 64421, 64426, 64431, 64435, 64440, 64445, 64450, 64455, 64459, 64464, 64469, 64473
             -, 64478, 64482, 64487, 64491, 64495, 64500, 64504, 64508, 64513, 64517, 64521, 64525, 64529, 64533, 64537, 64541,
  76          64545, 64549, 64553, 64557, 64561, 64565, 64568, 64572, 64576, 64579, 64583, 64587, 64590, 64594, 64598, 6
             -4601, 64605, 64608, 64611, 64615, 64618, 64622, 64625, 64628, 64632, 64635, 64638, 64641, 64645, 64648, 64651, 64654, 64
             -657, 64660, 64663, 64666, 64669, 64673, 64675, 64678, 64681, 64684, 64687, 64690, 64693, 64696, 64699, 64701, 64704, 647
             -07, 64710, 64713, 64715, 64718, 64721, 64723, 64726, 64729, 64731, 64734, 64736, 64739, 64742, 64744, 64747, 64749, 6475
             -2, 64754, 64756, 64759, 64761, 64764, 64766, 64769, 64771, 64773, 64776, 64778, 64780, 64782, 64785, 64787, 64789, 64791
             -, 64794, 64796, 64798, 64800, 64802, 64805, 64807, 64809, 64811, 64813, 64815, 64817, 64819, 64821, 64824, 64826,
  77          64828, 64830, 64832, 64834, 64836, 64838, 64839, 64841, 64843, 64845, 64847, 64849, 64851, 64853, 64855, 6
             -4857, 64858, 64860, 64862, 64864, 64866, 64868, 64869, 64871, 64873, 64875, 64876, 64878, 64880, 64882, 64883, 64885, 64
             -887, 64889, 64890, 64892, 64894, 64895, 64897, 64898, 64900, 64902, 64903, 64905, 64907, 64908, 64910, 64911, 64913, 649
             -14, 64916, 64918, 64919, 64921, 64922, 64924, 64925, 64927, 64928, 64930, 64931, 64933, 64934, 64935, 64937, 64938, 6494
             -0, 64941, 64943, 64944, 64945, 64947, 64948, 64950, 64951, 64952, 64954, 64955, 64956, 64958, 64959, 64961, 64962, 64963
             -, 64964, 64966, 64967, 64968, 64970, 64971, 64972, 64974, 64975, 64976, 64977, 64979, 64980, 64981, 64982, 64984,
  78          64985, 64986, 64987, 64988, 64990, 64991, 64992, 64993, 64994, 64996, 64997, 64998, 64999, 65000, 65001, 6
             -5003, 65004, 65005, 65006, 65007, 65008, 65009, 65010, 65012, 65013, 65014, 65015, 65016, 65017, 65018, 65019, 65020, 65
             -021, 65022, 65023, 65025, 65026, 65027, 65028, 65029, 65030, 65031, 65032, 65033, 65034, 65035, 65036, 65037, 65038, 650
             -39, 65040, 65041, 65042, 65043, 65044, 65045, 65046, 65047, 65048, 65049, 65050, 65051, 65051, 65052, 65053, 65054, 6505
             -5, 65056, 65057, 65058, 65059, 65060, 65061, 65062, 65063, 65063, 65064, 65065, 65066, 65067, 65068, 65069, 65070, 65071
             -, 65071, 65072, 65073, 65074, 65075, 65076, 65077, 65077, 65078, 65079, 65080, 65081, 65082, 65082, 65083, 65084,
  79          65085, 65086, 65087, 65087, 65088, 65089, 65090, 65091, 65091, 65092, 65093, 65094, 65095, 65095, 65096, 6
             -5097, 65098, 65098, 65099, 65100, 65101, 65101, 65102, 65103, 65104, 65105, 65105, 65106, 65107, 65107, 65108, 65109, 65
             -110, 65110, 65111, 65112, 65113, 65113, 65114, 65115, 65115, 65116, 65117, 65118, 65118, 65119, 65120, 65120, 65121, 651
             -22, 65122, 65123, 65124, 65125, 65125, 65126, 65127, 65127, 65128, 65129, 65129, 65130, 65131, 65131, 65132, 65133, 6513
             -3, 65134, 65135, 65135, 65136, 65136, 65137, 65138, 65138, 65139, 65140, 65140, 65141, 65142, 65142, 65143, 65143, 65144
             -, 65145, 65145, 65146, 65146, 65147, 65148, 65148, 65149, 65150, 65150, 65151, 65151, 65152, 65153, 65153, 65154,
  80          65154, 65155, 65155, 65156, 65157, 65157, 65158, 65158, 65159, 65159, 65160, 65161, 65161, 65162, 65162, 6
             -5163, 65163, 65164, 65165, 65165, 65166, 65166, 65167, 65167, 65168, 65168, 65169, 65169, 65170, 65171, 65171, 65172, 65
             -172, 65173, 65173, 65174, 65174, 65175, 65175, 65176, 65176, 65177, 65177, 65178, 65178, 65179, 65179, 65180, 65181, 651
             -81, 65182, 65182, 65183, 65183, 65184, 65184, 65185, 65185, 65186, 65186, 65187, 65187, 65188, 65188, 65188, 65189, 6518
             -9, 65190, 65190, 65191, 65191, 65192, 65192, 65193, 65193, 65194, 65194, 65195, 65195, 65196, 65196, 65197, 65197, 65197
             -, 65198, 65198, 65199, 65199, 65200, 65200, 65201, 65201, 65202, 65202, 65202, 65203, 65203, 65204, 65204, 65205,
  81          65205, 65206, 65206, 65206, 65207, 65207, 65208, 65208, 65209, 65209, 65210, 65210, 65210, 65211, 65211, 6
C51 COMPILER V9.56.0.0   SUSONGXIAN                                                        04/28/2017 13:56:01 PAGE 3   

             -5212, 65212, 65213, 65213, 65213, 65214, 65214, 65215, 65215, 65215, 65216, 65216, 65217, 65217, 65217, 65218, 65218, 65
             -219, 65219, 65220, 65220, 65220, 65221, 65221, 65222, 65222, 65222, 65223, 65223, 65224, 65224, 65224, 65225, 65225, 652
             -25, 65226, 65226, 65227, 65227, 65227, 65228, 65228, 65229, 65229, 65229, 65230, 65230, 65230, 65231, 65231, 65232, 6523
             -2, 65232, 65233, 65233, 65233, 65234, 65234, 65235, 65235, 65235, 65236, 65236, 65236, 65237, 65237, 65237, 65238, 65238
             -, 65238, 65239, 65239, 65240, 65240, 65240, 65241, 65241, 65241, 65242, 65242, 65242, 65243, 65243, 65243, 65244,
  82          65244, 65244, 65245, 65245, 65245, 65246, 65246, 65246, 65247, 65247, 65247, 65248, 65248, 65249, 65249, 6
             -5249, 65249, 65250, 65250, 65250, 65251, 65251, 65251, 65252, 65252, 65252, 65253, 65253, 65253, 65254, 65254, 65254, 65
             -255, 65255, 65255, 65256, 65256, 65256, 65257, 65257, 65257, 65258, 65258, 65258, 65258, 65259, 65259, 65259, 65260, 652
             -60, 65260, 65261, 65261, 65261, 65262, 65262, 65262, 65262, 65263, 65263, 65263, 65264, 65264, 65264, 65265, 65265, 6526
             -5, 65265, 65266, 65266, 65266, 65267, 65267, 65267, 65267, 65268, 65268, 65268, 65269, 65269, 65269, 65270, 65270, 65270
             -, 65270, 65271, 65271, 65271, 65272, 65272, 65272, 65272, 65273, 65273, 65273, 65273, 65274, 65274, 65274, 65275,
  83          65275, 65275, 65275, 65276, 65276, 65276, 65276, 65277, 65277, 65277, 65278, 65278, 65278, 65278, 65279, 6
             -5279, 65279, 65279, 65280, 65280, 65280, 65281, 65281, 65281, 65281, 65282, 65282, 65282, 65282, 65283, 65283, 65283, 65
             -283, 65284, 65284, 65284, 65284, 65285, 65285, 65285, 65285, 65286, 65286, 65286, 65286, 65287, 65287, 65287, 65287, 652
             -88, 65288, 65288, 65288, 65289, 65289, 65289, 65289, 65290, 65290, 65290, 65290, 65291, 65291, 65291, 65291, 65292, 6529
             -2, 65292, 65292, 65293, 65293, 65293, 65293, 65294, 65294, 65294, 65294, 65294, 65295, 65295, 65295, 65295, 65296, 65296
             -, 65296, 65296, 65297, 65297, 65297, 65297, 65297, 65298, 65298, 65298, 65298, 65299, 65299, 65299, 65299, 65300,
  84          65300, 65300, 65300, 65300, 65301, 65301, 65301, 65301, 65302, 65302, 65302, 65302, 65302, 65303, 65303, 6
             -5303, 65303, 65304, 65304, 65304, 65304, 65304, 65305, 65305, 65305, 65305, 65305, 65306, 65306, 65306, 65306, 65307, 65
             -307, 65307, 65307, 65307, 65308, 65308, 65308, 65308, 65308, 65309, 65309, 65309, 65309, 65309, 65310, 65310, 65310, 653
             -10, 65310, 65311, 65311, 65311, 65311, 65312, 65312, 65312, 65312, 65312, 65313, 65313, 65313, 65313, 65313, 65314, 6531
             -4, 65314, 65314, 65314, 65315, 65315, 65315, 65315, 65315, 65316, 65316, 65316, 65316, 65316, 65316, 65317, 65317, 65317
             -, 65317, 65317, 65318, 65318, 65318, 65318, 65318, 65319, 65319, 65319, 65319, 65319, 65320, 65320, 65320, 65320,
  85          65320, 65321, 65321, 65321, 65321, 65321, 65321, 65322, 65322, 65322, 65322, 65322, 65323, 65323, 65323, 6
             -5323, 65323, 65323, 65324, 65324, 65324, 65324, 65324, 65325, 65325, 65325, 65325, 65325, 65325, 65326, 65326, 65326, 65
             -326, 65326, 65327, 65327, 65327, 65327, 65327, 65327, 65328, 65328, 65328, 65328, 65328, 65328, 65329, 65329, 65329, 653
             -29, 65329, 65329, 65330, 65330, 65330, 65330, 65330, 65331, 65331, 65331, 65331, 65331, 65331, 65332, 65332, 65332, 6533
             -2, 65332, 65332, 65333, 65333, 65333, 65333, 65333, 65333, 65334, 65334, 65334, 65334, 65334, 65334, 65335, 65335, 65335
             -, 65335, 65335, 65335, 65336, 65336, 65336, 65336, 65336, 65336, 65336, 65337, 65337, 65337, 65337, 65337, 65337,
  86          65338, 65338, 65338, 65338, 65338, 65338, 65339, 65339, 65339, 65339, 65339, 65339, 65339, 65340, 65340, 6
             -5340, 65340, 65340, 65340, 65341, 65341, 65341, 65341, 65341, 65341, 65341, 65342, 65342, 65342, 65342, 65342, 65342, 65
             -343, 65343, 65343, 65343, 65343, 65343, 65343, 65344, 65344, 65344, 65344, 65344, 65344, 65345, 65345, 65345, 65345, 653
             -45, 65345, 65345, 65346, 65346, 65346, 65346, 65346, 65346, 65346, 65347, 65347, 65347, 65347, 65347, 65347, 65347, 6534
             -8, 65348, 65348, 65348, 65348, 65348, 65348, 65349, 65349, 65349, 65349, 65349, 65349, 65349, 65350, 65350, 65350, 65350
             -, 65350, 65350, 65350, 65351, 65351, 65351, 65351, 65351, 65351, 65351, 65351, 65352, 65352, 65352, 65352, 65352,
  87          65352, 65352, 65353, 65353, 65353, 65353, 65353, 65353, 65353, 65354, 65354, 65354, 65354, 65354, 65354, 6
             -5354, 65354, 65355, 65355, 65355, 65355, 65355, 65355, 65355, 65356, 65356, 65356, 65356, 65356, 65356, 65356, 65356, 65
             -357, 65357, 65357, 65357, 65357, 65357, 65357, 65357, 65358, 65358, 65358, 65358, 65358, 65358, 65358, 65359, 65359, 653
             -59, 65359, 65359, 65359, 65359, 65359, 65360, 65360, 65360, 65360, 65360, 65360, 65360, 65360, 65361, 65361, 65361, 6536
             -1, 65361, 65361, 65361, 65361, 65362, 65362, 65362, 65362, 65362, 65362, 65362, 65362, 65362, 65363, 65363, 65363, 65363
             -, 65363, 65363, 65363, 65363, 65364, 65364, 65364, 65364, 65364, 65364, 65364, 65364, 65365, 65365, 65365, 65365,
  88          65365, 65365, 65365, 65365, 65365, 65366, 65366, 65366, 65366, 65366, 65366, 65366, 65366, 65367, 65367, 6
             -5367, 65367, 65367, 65367, 65367, 65367, 65367, 65368, 65368, 65368, 65368, 65368, 65368, 65368, 65368, 65368, 65369, 65
             -369, 65369, 65369, 65369, 65369, 65369, 65369, 65369, 65370, 65370, 65370, 65370, 65370, 65370, 65370, 65370, 65371, 653
             -71, 65371, 65371, 65371, 65371, 65371, 65371, 65371, 65371, 65372, 65372, 65372, 65372, 65372, 65372, 65372, 65372, 6537
             -2, 65373, 65373, 65373, 65373, 65373, 65373, 65373, 65373, 65373, 65374, 65374, 65374, 65374, 65374, 65374, 65374, 65374
             -, 65374, 65375, 65375, 65375, 65375, 65375, 65375, 65375, 65375, 65375, 65375, 65376, 65376, 65376, 65376, 65376,
  89          65376, 65376, 65376, 65376, 65376, 65377, 65377, 65377, 65377, 65377, 65377, 65377, 65377, 65377, 65378, 6
             -5378, 65378, 65378, 65378, 65378, 65378, 65378, 65378, 65378, 65379, 65379, 65379, 65379, 65379, 65379, 65379, 65379, 65
             -379, 65379, 65380, 65380, 65380, 65380, 65380, 65380, 65380, 65380, 65380, 65380, 65380, 65381, 65381, 65381, 65381, 653
             -81, 65381, 65381, 65381, 65381, 65381, 65382, 65382, 65382, 65382, 65382, 65382, 65382, 65382, 65382, 65382, 65383, 6538
             -3, 65383, 65383, 65383, 65383, 65383, 65383, 65383, 65383, 65383, 65384, 65384, 65384, 65384, 65384, 65384, 65384, 65384
             -, 65384, 65384, 65384, 65385, 65385, 65385, 65385, 65385, 65385, 65385, 65385, 65385, 65385, 65386, 65386, 65386,
  90          65386, 65386, 65386, 65386, 65386, 65386, 65386, 65386, 65387, 65387, 65387, 65387, 65387, 65387, 65387, 6
             -5387, 65387, 65387, 65387, 65387, 65388, 65388, 65388, 65388, 65388, 65388, 65388, 65388, 65388, 65388, 65388, 65389, 65
             -389, 65389, 65389, 65389, 65389, 65389, 65389, 65389, 65389, 65389, 65390, 65390, 65390, 65390, 65390, 65390, 65390, 653
             -90, 65390, 65390, 65390, 65390, 65391, 65391, 65391, 65391, 65391, 65391, 65391, 65391, 65391, 65391, 65391, 65391, 6539
             -2, 65392, 65392, 65392, 65392, 65392, 65392, 65392, 65392, 65392, 65392, 65393, 65393, 65393, 65393, 65393, 65393, 65393
             -, 65393, 65393, 65393, 65393, 65393, 65393, 65394, 65394, 65394, 65394, 65394, 65394, 65394, 65394, 65394, 65394,
  91          65394, 65394, 65395, 65395, 65395, 65395, 65395, 65395, 65395, 65395, 65395, 65395, 65395, 65395, 65396, 6
             -5396, 65396, 65396, 65396, 65396, 65396, 65396, 65396, 65396, 65396, 65396, 65396, 65397, 65397, 65397, 65397, 65397, 65
             -397, 65397, 65397, 65397, 65397, 65397, 65397, 65397, 65398, 65398, 65398, 65398, 65398, 65398, 65398, 65398, 65398, 653
C51 COMPILER V9.56.0.0   SUSONGXIAN                                                        04/28/2017 13:56:01 PAGE 4   

             -98, 65398, 65398, 65398, 65399, 65399, 65399, 65399, 65399, 65399, 65399, 65399, 65399, 65399, 65399, 65399, 65399, 6540
             -0, 65400, 65400, 65400, 65400, 65400, 65400, 65400, 65400, 65400, 65400, 65400, 65400, 65401, 65401, 65401, 65401, 65401
             -, 65401, 65401, 65401, 65401, 65401, 65401, 65401, 65401, 65401, 65402, 65402, 65402, 65402, 65402, 65402, 65402,
  92          65402, 65402, 65402, 65402, 65402, 65402, 65403, 65403, 65403, 65403, 65403, 65403, 65403, 65403, 65403, 6
             -5403, 65403, 65403, 65403, 65403, 65404, 65404, 65404, 65404, 65404, 65404, 65404, 65404, 65404, 65404, 65404, 65404, 65
             -404, 65404, 65404, 65405, 65405, 65405, 65405, 65405, 65405, 65405, 65405, 65405, 65405, 65405, 65405, 65405, 65405, 654
             -06, 65406, 65406, 65406, 65406, 65406, 65406, 65406, 65406, 65406, 65406, 65406, 65406, 65406, 65406, 65407, 65407, 6540
             -7, 65407, 65407, 65407, 65407, 65407, 65407, 65407, 65407, 65407, 65407, 65407, 65408, 65408, 65408, 65408, 65408, 65408
             -, 65408, 65408, 65408, 65408, 65408, 65408, 65408, 65408, 65408, 65409, 65409, 65409, 65409, 65409, 65409, 65409,
  93          65409, 65409, 65409, 65409, 65409, 65409, 65409, 65409, 65409, 65410, 65410, 65410, 65410, 65410, 65410, 6
             -5410, 65410, 65410, 65410, 65410, 65410, 65410, 65410, 65410, 65411, 65411, 65411, 65411, 65411, 65411, 65411, 65411, 65
             -411, 65411, 65411, 65411, 65411, 65411, 65411, 65411, 65412, 65412, 65412, 65412, 65412, 65412, 65412, 65412, 65412, 654
             -12, 65412, 65412, 65412, 65412, 65412, 65412, 65413, 65413, 65413, 65413, 65413, 65413, 65413, 65413, 65413, 65413, 6541
             -3, 65413, 65413, 65413, 65413, 65413, 65413, 65414, 65414, 65414, 65414, 65414, 65414, 65414, 65414, 65414, 65414, 65414
             -, 65414, 65414, 65414, 65414, 65414, 65415, 65415, 65415, 65415, 65415, 65415, 65415, 65415, 65415, 65415};*/
  94          //-----------------------------------------------------------------------------
  95          // 外部全局变量
  96          //-----------------------------------------------------------------------------
  97          extern xdata CANRECDATBUF CANRXBUF_ZKB;
  98          extern xdata unsigned char CANaddress1;
  99          extern xdata unsigned char CANINDEX;
 100          /***************************************************************************/
 101          void Watchdog_Init (void);
 102          void Initial(void);
 103          void PORT_Init (void);
 104          void OSCILLATOR_Init (void);
 105          void Timer01_Init(void);
 106          void init_para(void);
 107          void Board_Parameter_Setup(void);
 108          //void init_INT0 (void);
 109          //void init_INT1 (void);
 110          void Motor1_CTL(long int Vel1);     //T2输出，控制电机1;
 111          void DCmotor_CTL(void);
 112          //void init_T2 (void);
 113          void Uart0Send(unsigned char *buf, unsigned char bufsize );
 114          void delay1( unsigned int us);
 115          void Send_to_Motordriver_CTL(unsigned char command );
 116          unsigned int crc_chk(unsigned char *puchMsg, unsigned char length);
 117          void delay_ms(unsigned int ms);
 118          void send_to_motor(void);
 119          void RunLEDDIS(void);
 120          void DC_motorCTRL(void);
 121          void ServomotorCRTL(unsigned char comand);
 122          //void Dataacquisition();
 123          void SystemControl(void);
 124          //void ServomotorDataacquisition(unsigned char addressID);
 125          void Returntopoint(void);
 126          void UnactiveCANtransfer(void);
 127          void write_to_flash(void);
 128          void read_from_flash(void);
 129          void TRANFORSATATIONINFOR(void);
 130          void CANsetpraback(void);
 131          //void CurrentCollection(unsigned char addressID);
 132          void ServomotorINP(unsigned char addressID);
 133          //void ManualCANtransfer(void);
 134          void AUTORUNMODE1(unsigned char comand);
 135          void AUTORUNMODE2(unsigned char comand);
 136          void AUTORUNMODE3(unsigned char comand);
 137          unsigned char AUTOTaskassignment1(void);
 138          unsigned char AUTOTaskassignment2(void);
 139          unsigned char AUTOTaskassignment3(void);
 140          void UnactiveCANtransfer(void);
C51 COMPILER V9.56.0.0   SUSONGXIAN                                                        04/28/2017 13:56:01 PAGE 5   

 141          void Deviationremoval(void);
 142          void init_machine(void);
 143          void SAMPCBDataacquisition(unsigned char addressID);
 144          /**************************************************************************/
 145          
 146          void delay_ms(unsigned int ms)
 147          {
 148   1          unsigned int us = 1000;
 149   1          while(ms--)
 150   1          {
 151   2              delay1(us);
 152   2          }
 153   1      }
 154          
 155          //void Delay1ms()   //@11.0592MHz
 156          //{
 157          //  unsigned char i, j;
 158          
 159          //  _nop_();
 160          //  i = 2;
 161          //  j = 199;
 162          //  do
 163          //  {
 164          //    while (--j);
 165          //  } while (--i);
 166          //}
 167          
 168          //void delay_ms(unsigned int t)
 169          //{
 170          //  while(t--)
 171          //  {
 172          //    Delay1ms();
 173          //  }
 174          //}
 175          
 176          /**************************************************************************/
 177          void Watchdog_Init (void)
 178          {
 179   1          WDTCN &= ~0x80;                     // WDTCN.7 must be logic 0 when setting
 180   1          // the interval.
 181   1          WDTCN |= 0x07;                      // Set the WDTCN[2-0] to 110b
 182   1      }
 183          //------------------------------------------------------
 184          // 名    称：Initial
 185          // 功    能：初始化模块
 186          //------------------------------------------------------
 187          void Initial(void)
 188          {
 189   1          OSCILLATOR_Init ();
 190   1          Watchdog_Init ();
 191   1          PORT_Init ();
 192   1          Timer01_Init();
 193   1          //init_T2 ();
 194   1          //init_INT0();
 195   1          //init_INT1();
 196   1          SFRPAGE  = CONFIG_PAGE;
 197   1          repair_flag = P7 & 0x03 ;
 198   1          IDSET = P7 & 0x7F ;
 199   1          IDSET = IDSET >> 4;
 200   1          BPSSET = 0x00;       //CAN波特率设置
 201   1          init_para();
 202   1          PT2 = 1;
C51 COMPILER V9.56.0.0   SUSONGXIAN                                                        04/28/2017 13:56:01 PAGE 6   

 203   1          PT0 = 1;
 204   1          //E2PROM初始化
 205   1          WDTCN = 0xA5;  //看门狗复位
 206   1          EA = 1; //开中断
 207   1          motor1_ENB = 0;
 208   1      }
 209          void Timer01_Init(void)
 210          {
 211   1          char SFRPAGE_SAVE = SFRPAGE;        // Save Current SFR page
 212   1          SFRPAGE = TIMER01_PAGE;             // Set SFR page
 213   1          TMOD = (TMOD & 0x00) | 0x21; //T0工作于方式1，T1工作于方式2
 214   1          PCON = 0x00;    //电源和SMOD控制字
 215   1          TH1  = 0xfd;    //9600 bit band:TH1=0xfd;1200 bit:TH1=0xe8
 216   1          TL1  = 0xfd;    //T1常数设置bt=11059200/(32*12*(256-TH1))
 217   1          TF1  = 0;   //定时器1溢出标志位清零
 218   1          TR1  = 1;   //T1开始计数 bt=28800/(256-TH1)
 219   1          TH0  = 0xDC;      //Reset 10ms interrupt
 220   1          TL0  = 00;
 221   1          TF0  = 0;
 222   1          TR0  = 1;
 223   1          ET0 = 1;
 224   1          SCON0 = 0x50;   //串行通讯方式一：起始位(L)、8位数据位、无校验位、停止位(H)
 225   1      //    SCON0 = 0xD0;       // Serial Port Control Register
 226   1          //SCON = 0x40;    //串行通讯方式一：起始位(L)、8位数据位、无校验位、停止位(H)
 227   1          ES0 = 1;  //串行中断允许
 228   1          SFRPAGE = SFRPAGE_SAVE;             // Restore SFR page
 229   1      }
 230          /////////////////////////////
 231          //定时0中断,模式1,16位定时计数器, 时钟4分频 ,高优先级
 232          //T0=65536-1000us*11.0592/4=0xF533      时钟4分频下的1毫秒
 233          //T0=65536-1000us*11.0592/12=0xFC66     时钟12分频下的1毫秒
 234          //T0=65536-10000us*11.0592/12=0xDC00    时钟12分频下的10毫秒
 235          void Timer0_ISR (void) interrupt 1
 236          {
 237   1          unsigned char i;
 238   1          char SFRPAGE_SAVE = SFRPAGE;        // Save Current SFR page
 239   1          //SFRPAGE = TIMER01_PAGE;
 240   1          //TH0=0xDC;      //Reset 10ms interrupt
 241   1          //TL0=0x00;
 242   1          WDTCN = 0xA5;                    // Reset the WDT
 243   1          SFRPAGE = 0x0F;
 244   1          //  T0Counter1++;
 245   1          T0Counter2++;
 246   1          T0Counter3++;
 247   1          T0Counter5++;
 248   1          T0Counter6++;
 249   1          T0Counter8++;
 250   1          T0Counter7++;
 251   1          timer0_cn++;
 252   1          cmd_chk_cnt++;
 253   1          if( (timer0_cn >= 4) && (RecFlag1 == YES) ) //表示如果在接收数据，一帧数据已接受完毕
 254   1          {
 255   2              Receive_command_finished = YES;
 256   2              RecFlag1 = NO;
 257   2              for(i = 0 ; i < RecPointer1; i++)
 258   2              {
 259   3                  RxBuf1.buf[i] = Rec1[i];
 260   3                  Rec1[i] = 0x00;
 261   3              }
 262   2              strlen = RecPointer1;
 263   2              RecPointer1 = 0;
 264   2          }
C51 COMPILER V9.56.0.0   SUSONGXIAN                                                        04/28/2017 13:56:01 PAGE 7   

 265   1      
 266   1          //SFRPAGE = SFRPAGE_SAVE;             // Restore SFR page
 267   1          //SFRPAGE_SAVE = SFRPAGE;        // Save Current SFR page
 268   1          //
 269   1          SFRPAGE = 0x0F;
 270   1          if(MONITOR_INPUT2 == 0) //左闸门到达下限位
 271   1          {
 272   2              //DC_motor2=1;
 273   2              DC_motor1 = 1;
 274   2              LED4 = 0;
 275   2              //ShowTime=T0Counter6*10;
 276   2              //Step_FLAG=YES;
 277   2              CANTRASTEMINFOR[13] = CANTRASTEMINFOR[13] | 0x01;
 278   2          }
 279   1          else
 280   1          {
 281   2              LED4 = 1;
 282   2              CANTRASTEMINFOR[13] = CANTRASTEMINFOR[13] & 0xFE;
 283   2          }
 284   1          //
 285   1          SFRPAGE = 0x0F;
 286   1          if(MONITOR_INPUT3 == 0) //左闸门到达上限位
 287   1          {
 288   2              //DC_motor1=1;
 289   2              DC_motor2 = 1;
 290   2              //ShowTime=T0Counter6*10;
 291   2              //Step_FLAG=YES;
 292   2              CANTRASTEMINFOR[13] = CANTRASTEMINFOR[13] | 0x02;
 293   2          }
 294   1          else
 295   1          {
 296   2      
 297   2              CANTRASTEMINFOR[13] = CANTRASTEMINFOR[13] & 0xFD;
 298   2          }
 299   1          //
 300   1          SFRPAGE = 0x0F;
 301   1          if(MONITOR_INPUT1 == 0) //右闸门到达下限位
 302   1          {
 303   2              DC_motor3 = 1;
 304   2              //DC_motor4=1;
 305   2              //ShowTime=T0Counter6*10;
 306   2              //Step_FLAG=YES;
 307   2              LED5 = 0;
 308   2              CANTRASTEMINFOR[13] = CANTRASTEMINFOR[13] | 0x04;
 309   2          }
 310   1          else
 311   1          {
 312   2              LED5 = 1;
 313   2              CANTRASTEMINFOR[13] = CANTRASTEMINFOR[13] & 0xFB;
 314   2          }
 315   1          //
 316   1          SFRPAGE = 0x0F;
 317   1          if(MONITOR_INPUT4 == 0) //右闸门到达上限位
 318   1          {
 319   2              DC_motor4 = 1;
 320   2      //          DC_motor3=1;
 321   2              //ShowTime=T0Counter6*10;
 322   2              //Step_FLAG=YES;
 323   2              CANTRASTEMINFOR[13] = CANTRASTEMINFOR[13] | 0x08;
 324   2          }
 325   1          else
 326   1          {
C51 COMPILER V9.56.0.0   SUSONGXIAN                                                        04/28/2017 13:56:01 PAGE 8   

 327   2              CANTRASTEMINFOR[13] = CANTRASTEMINFOR[13] & 0xF7;
 328   2          }
 329   1      
 330   1          //SFRPAGE = SFRPAGE_SAVE;
 331   1          SFRPAGE = TIMER01_PAGE;
 332   1          TH0 = 0xDC;    //Reset 10ms interrupt
 333   1          TL0 = 0x00;
 334   1          SFRPAGE = SFRPAGE_SAVE;             // Restore SFR page
 335   1      }
 336          
 337          //-----------------------------------------------------------------------------
 338          // Port_Init ()
 339          //-----------------------------------------------------------------------------
 340          
 341          void PORT_Init (void)
 342          {
 343   1          // Configure the XBRn Registers
 344   1          char SFRPAGE_SAVE = SFRPAGE;        // Save Current SFR page
 345   1          SFRPAGE = CONFIG_PAGE;              // Set SFR page
 346   1          // Configure the XBRn Registers
 347   1      
 348   1          SFRPAGE = 0x0F;
 349   1          XBR0 = 0x04;  // XBAR0: Initial Reset Value  串口0
 350   1          XBR1 = 0x34;  // XBAR1: Initial Reset Value  T2定时器输出、外部中断1 和 外部中断0
 351   1          XBR2 = 0x40;  // XBAR2: Initial Reset Value  交叉总开关
 352   1          // XBR3 = 0x01;    // XBAR3: Initial Reset Value  T3定时器输出
 353   1          // Select Pin I/0
 354   1      
 355   1          // NOTE: Some peripheral I/O pins can function as either inputs or
 356   1          // outputs, depending on the configuration of the peripheral. By default,
 357   1          // the configuration utility will configure these I/O pins as push-pull
 358   1          // outputs.
 359   1          // Port configuration (1 = Push Pull Output)
 360   1          SFRPAGE = 0x0F;
 361   1          P0MDOUT = 0xF1; // 1111 1001b Output configuration for P0
 362   1          P1MDOUT = 0xFF; // Output configuration for P1
 363   1          P2MDOUT = 0x00; // Output configuration for P2
 364   1          P3MDOUT = 0x00; // Output configuration for P3
 365   1      
 366   1          P4MDOUT = 0xFF; // Output configuration for P4
 367   1          P5MDOUT = 0xFF; // Output configuration for P5
 368   1          P6MDOUT = 0x00; // Output configuration for P6
 369   1          P7MDOUT = 0x00; // Output configuration for P7
 370   1      
 371   1          P1MDIN = 0xFF;  // Input configuration for P1
 372   1          P2MDIN = 0xFF;  // Input configuration for P2
 373   1          P3MDIN = 0xFF;  // Input configuration for P3
 374   1      
 375   1          // View port pinout
 376   1      
 377   1          // The current Crossbar configuration results in the
 378   1          // following port pinout assignment:
 379   1          // Port 0
 380   1          // P0.0 = UART0 TX        (Push-Pull Output)(Digital)
 381   1          // P0.1 = UART0 RX        (Open-Drain Output/Input)(Digital)
 382   1          // P0.2 = UART1 TX        (Push-Pull Output)(Digital)
 383   1          // P0.3 = UART1 RX        (Open-Drain Output/Input)(Digital)
 384   1          // P0.4 = GP I/O          (Open-Drain Output/Input)(Digital)
 385   1          // P0.5 = GP I/O          (Open-Drain Output/Input)(Digital)
 386   1          // P0.6 = GP I/O          (Open-Drain Output/Input)(Digital)
 387   1          // P0.7 = GP I/O          (Open-Drain Output/Input)(Digital)
 388   1      
C51 COMPILER V9.56.0.0   SUSONGXIAN                                                        04/28/2017 13:56:01 PAGE 9   

 389   1          // Port 1
 390   1          // P1.0 = GP I/O          (Open-Drain Output/Input)(Digital)
 391   1          // P1.1 = GP I/O          (Open-Drain Output/Input)(Digital)
 392   1          // P1.2 = GP I/O          (Open-Drain Output/Input)(Digital)
 393   1          // P1.3 = GP I/O          (Open-Drain Output/Input)(Digital)
 394   1          // P1.4 = GP I/O          (Open-Drain Output/Input)(Digital)
 395   1          // P1.5 = GP I/O          (Open-Drain Output/Input)(Digital)
 396   1          // P1.6 = GP I/O          (Open-Drain Output/Input)(Digital)
 397   1          // P1.7 = GP I/O          (Open-Drain Output/Input)(Digital)
 398   1      
 399   1          // Port 2
 400   1          // P2.0 = GP I/O          (Open-Drain Output/Input)(Digital)
 401   1          // P2.1 = GP I/O          (Open-Drain Output/Input)(Digital)
 402   1          // P2.2 = GP I/O          (Open-Drain Output/Input)(Digital)
 403   1          // P2.3 = GP I/O          (Open-Drain Output/Input)(Digital)
 404   1          // P2.4 = GP I/O          (Open-Drain Output/Input)(Digital)
 405   1          // P2.5 = GP I/O          (Open-Drain Output/Input)(Digital)
 406   1          // P2.6 = GP I/O          (Open-Drain Output/Input)(Digital)
 407   1          // P2.7 = GP I/O          (Open-Drain Output/Input)(Digital)
 408   1      
 409   1          // Port 3
 410   1          // P3.0 = GP I/O          (Open-Drain Output/Input)(Digital)
 411   1          // P3.1 = GP I/O          (Open-Drain Output/Input)(Digital)
 412   1          // P3.2 = GP I/O          (Open-Drain Output/Input)(Digital)
 413   1          // P3.3 = GP I/O          (Open-Drain Output/Input)(Digital)
 414   1          // P3.4 = GP I/O          (Open-Drain Output/Input)(Digital)
 415   1          // P3.5 = GP I/O          (Open-Drain Output/Input)(Digital)
 416   1          // P3.6 = GP I/O          (Open-Drain Output/Input)(Digital)
 417   1          // P3.7 = GP I/O          (Open-Drain Output/Input)(Digital)
 418   1          SFRPAGE = 0x00;
 419   1          EMI0CF = 0x27;//27  // External Memory Configuration Register
 420   1          SFRPAGE = SFRPAGE_SAVE;             // Restore SFR page
 421   1      }
 422          //-----------------------------------------------------------------------------
 423          // OSCILLATOR_Init
 424          //-----------------------------------------------------------------------------
 425          //
 426          // Return Value : None
 427          // Parameters   : None
 428          //
 429          // This function initializes the system clock to use an external 22.1184MHz
 430          // crystal.
 431          //
 432          //-----------------------------------------------------------------------------
 433          void OSCILLATOR_Init (void)
 434          {
 435   1          int i;                              // Software timer
 436   1          char SFRPAGE_SAVE = SFRPAGE;        // Save Current SFR page
 437   1          SFRPAGE = CONFIG_PAGE;              // Set SFR page
 438   1          OSCXCN = 0x67;                      // Enable external crystal osc.
 439   1          for (i = 0; i < 256; i++);          // Wait at least 1ms
 440   1      
 441   1          while (!(OSCXCN & 0x80));           // Wait for crystal osc to settle
 442   1      
 443   1          CLKSEL = 0x01;
 444   1          // Select external crystal as SYSTEMCLOCK source
 445   1      
 446   1          SFRPAGE = SFRPAGE_SAVE;             // Restore SFRPAGE
 447   1      }
 448          
 449          //////////////////////////
 450          //初始化变量
C51 COMPILER V9.56.0.0   SUSONGXIAN                                                        04/28/2017 13:56:01 PAGE 10  

 451          //////////////////////////
 452          void init_para(void)
 453          {
 454   1          unsigned char i;
 455   1          for(i = 0; i < 8; i++)
 456   1          {
 457   2              CANRXBUF_ZKB.buf[i] = 0;
 458   2              CANTXBUF_ZKB.buf[i] = 0;
 459   2          }
 460   1          Board_Parameter_Setup();    //各驱动板参数初始化
 461   1          AUTOCMD_CHECK = 0;
 462   1          Runmode = 2;
 463   1          /***********************************/
 464   1          //初始化步进电机1参数
 465   1          /**********************************/
 466   1          Shaft1_Run_mode = 0x00;
 467   1          Shaft1_aim_pulse = 0;
 468   1          RE1 = 0;
 469   1          DE1 = 0;
 470   1          Servoparastation = 0;
 471   1          Servoparadisplace = 500000;
 472   1          Servoparaspeed = 50000;
 473   1          Servoparaaddtime = 100;
 474   1          Servoparasubtime = 100;
 475   1          /*for(i=0;i<5;i++)
 476   1          {
 477   1          station[i]=0;
 478   1          }*/
 479   1          for(i = 0; i < 107; i++)
 480   1          {
 481   2              Servopara[i] = 0;
 482   2          }
 483   1      
 484   1          for(i = 0; i < 17; i++)
 485   1          {
 486   2              CANTRASTEMINFOR[i] = 0;
 487   2          }
 488   1          read_from_flash();
 489   1          system_crtl.AUTOsystem_command = 0;
 490   1      
 491   1          system_crtl.AUTOsystem_alarm1 = 0;
 492   1          system_crtl.AUTOsystem_alarm2 = 0;
 493   1      
 494   1          Receive485_command_finished = YES;
 495   1      }
 496          void Board_Parameter_Setup(void)
 497          {
 498   1          switch(IDSET)
 499   1          {
 500   2          case 01:    //X 轴参数
 501   2              init_can1_1();   //初始化c8051f040自带CAN
 502   2              //Current_Shaft1_Code=0x01;
 503   2              /*Shaft1_ADD_Speed_Time_Base = 10;
 504   2              Shaft1_SUB_Speed_Time_Base = 10;
 505   2              Shaft1_Base_Speed_Value = 50;
 506   2              Shaft1_Velocity_Subsection_Parameter=248830;
 507   2              Shaft1_Add_Speed= 15;
 508   2              Shaft1_Speed_max=400;     //40*/
 509   2              break;
 510   2          case 02:    //Y 轴参数          {
 511   2              init_can1_1();   //初始化c8051f040自带CAN
 512   2              break;
C51 COMPILER V9.56.0.0   SUSONGXIAN                                                        04/28/2017 13:56:01 PAGE 11  

 513   2          case 03:    //Y 轴参数          {
 514   2              init_can1_1();   //初始化c8051f040自带CAN
 515   2              break;
 516   2          case 04:    //Y 轴参数          {
 517   2              init_can1_1();   //初始化c8051f040自带CAN
 518   2              break;
 519   2          default:
 520   2              break;
 521   2          }
 522   1      }
 523          
 524          
 525          /* 步进电机1驱动控制
 526          在此函数中，正转代表为电机离开原点运行；反转代表为电机背离原点运行
 527          */
 528          
 529          void DCmotor_CTL(void)
 530          {
 531   1          if(Step_FLAG == YES)
 532   1          {
 533   2              CANTRASTEMINFOR[14] = (unsigned char)((ShowTime & 0xFF00) >> 8);
 534   2              CANTRASTEMINFOR[15] = (unsigned char)(ShowTime & 0x00FF);
 535   2          }
 536   1      }
 537          
 538          
 539          //-----------------------------------------------------------
 540          // 名    称：Serial_Port_Interrupt
 541          // 功    能：串口中断服务程序
 542          //-----------------------------------------------------------
 543          //# pragma disable
 544          # pragma enable
*** WARNING C245 IN LINE 544 OF Susongxian.C: unknown #pragma, line ignored
 545          void Serial_Port_Interrupt(void) interrupt 4
 546          {
 547   1          char SFRPAGE_SAVE = SFRPAGE;        // Save Current SFR page
 548   1          unsigned char ndate;
 549   1      
 550   1          SFRPAGE = UART0_PAGE;              // Set SFR page
 551   1          if((CANcomand == 0) && (AUTO_FLAG == NO)) return;
 552   1          if(RI0 == 1 )
 553   1          {
 554   2              RI0 = 0;
 555   2              ndate = SBUF0;
 556   2              RecFlag1 = YES;
 557   2              Rec1[RecPointer1++] = ndate;
 558   2              timer0_cn = 0;
 559   2          }
 560   1          SFRPAGE = SFRPAGE_SAVE;             // Restore SFRPAGE
 561   1          return;
 562   1      }
 563          
 564          /*void init_T2 (void)
 565          {
 566          /////////////////////////////////////////////////////////////////////////////////////////////
 567          /// Timer2工作在电平切换输出方式
 568          /// 产生的方波步进电机的控制脉冲
 569          /// 使用系统时钟，自动重装载方式计时
 570          /// 方波频率：1MHz  0xFFFA；500kHz   0xFFF4
 571          /////////////////////////////////////////////////////////////////////////////////////////////
 572          char SFRPAGE_SAVE = SFRPAGE;        // Save Current SFR page
 573          SFRPAGE = 0x00;
C51 COMPILER V9.56.0.0   SUSONGXIAN                                                        04/28/2017 13:56:01 PAGE 12  

 574          TMR2CF  = 0x0A; //  00001010b;  // Timer 3 Configuration
 575          //  位7-5：000  // 保留
 576          //  位4-3：01 // SYSCLK
 577          //  位2  ：0  // 切换输出状态位；写时产生强制输出
 578          //  位1  ：1  // 电平切换输出在为定时器被分配的端口引脚可用
 579          //  位0  ：0  // 定时器向上计数，与TnEX 的状态无关
 580          RCAP2L  = 0x00;         // Timer 3 Reload Register Low Byte
 581          RCAP2H  = 0x00;         // Timer 3 Reload Register High Byte
 582          TMR2H   = 0x00;         // Timer 3 High Byte
 583          TMR2L   = 0x00;         // Timer 3 Low Byte
 584          TMR2CN  = 0x00; //  00001010b;  // Timer 3 Control Register
 585          //  位7  ：0  // 定时器上溢/下溢标志；本项目不用
 586          //  位6  ：0  // 定时器外部标志；本项目不用
 587          //  位5-4：00 // 保留
 588          //  位3  ：0  // TnEX上的跳变被忽略
 589          //  位2  ：0  // 定时器禁止
 590          //  位1  ：0  // 定时器功能
 591          //  位0  ：0  // 定时器工作在自动重装载方式
 592          SFRPAGE = SFRPAGE_SAVE;             // Restore SFRPAGE
 593          ET2=1;
 594          }*/
 595          /*void init_INT0 (void)
 596          {
 597          SFRPAGE  = CONFIG_PAGE;        //Port SFR's on Configuration page
 598          XBR1  |= 0x04;                 //配置INT0管脚
 599          SFRPAGE  = LEGACY_PAGE;
 600          EA=0;
 601          EX0 = 1;    //使能INT0
 602          PX0 = 1;    //高优先级
 603          IT0=1;      //下降沿触发中断
 604          EA=1;
 605          }
 606          //对应于X轴为左边的限位开关，对应于Y轴为上边的限位开关
 607          //外部中断INT0 ，高优先级
 608          void INT0_ISR (void) interrupt 0
 609          {
 610          unsigned char temp;
 611          temp=SFRPAGE;
 612          SFRPAGE  = LEGACY_PAGE;
 613          EX0 = 0 ;   //关外部中断0
 614          Pulse1_Cnt=0;        //在此处进行清零电机1,当回到原点位置时，清零步进脉冲计数。
 615          Shaft1_Run_mode=0x00;
 616          Motor1_Begin_Run_Sign =NO;
 617          IE0=0;      //INT0中断复位
 618          EX0 = 1 ;   //开外部中断0
 619          SFRPAGE=temp;
 620          }*/
 621          /*void init_INT0 (void)
 622          {
 623          SFRPAGE  = CONFIG_PAGE;        //Port SFR's on Configuration page
 624          XBR1  |= 0x04;                 //配置INT0管脚
 625          SFRPAGE  = LEGACY_PAGE;
 626          EA=0;
 627          EX0 = 1;    //使能INT0
 628          PX0 = 1;    //高优先级
 629          IT0=1;      //下降沿触发中断
 630          EA=1;
 631          }*/
 632          //对应于X轴为左边的限位开关，对应于Y轴为上边的限位开关
 633          //外部中断INT0 ，高优先级
 634          /*void INT0_ISR (void) interrupt 0
 635          {
C51 COMPILER V9.56.0.0   SUSONGXIAN                                                        04/28/2017 13:56:01 PAGE 13  

 636          unsigned char temp;
 637          temp=SFRPAGE;
 638          SFRPAGE  = LEGACY_PAGE;
 639          EX0 = 0 ;   //关外部中断0
 640          IE0=0;      //INT0中断复位
 641          EX0 = 1 ;   //开外部中断0
 642          SFRPAGE=temp;
 643          }*/
 644          
 645          /*void init_INT1 (void)
 646          {
 647          
 648            SFRPAGE  = CONFIG_PAGE; //Port SFR's on Configuration page
 649            XBR1  |= 0x10;          //配置INT0管脚
 650            SFRPAGE  = LEGACY_PAGE;
 651            EA=0;
 652            EX1 = 1;               //使能INT1
 653            PX1 = 1;               //高优先级
 654            IT1=1;                 //下降沿触发中断
 655            EA=1;
 656          }*/
 657          
 658          //外部中断INT1 ，高优先级
 659          //对应于X轴为右边的限位开关，对应于Y轴为下边的限位开关
 660          /*void INT1_ISR (void) interrupt 2
 661          {
 662          unsigned char temp;
 663          temp=SFRPAGE;
 664          SFRPAGE  = LEGACY_PAGE;
 665          EX1 = 0 ;           //关外部中断1
 666          
 667           IE1=0;               //INT1中断复位
 668            EX1 = 1 ;            //开外部中断1
 669              SFRPAGE=temp;
 670          }*/
 671          
 672          //仅配为RS485模式  与RS422的区别就是在发送程序中，增加了发送前，关闭接受端口；发送完即打开接受端口。
 673          //该串口发送函数里集成了CRC校验，专用于modbus发送
 674          void Uart0Send(unsigned char *buf, unsigned char bufsize )
 675          {
 676   1          unsigned char i = 0;
 677   1          unsigned int k = 0;
 678   1          unsigned int crc_z = 0;
 679   1          char SFRPAGE_SAVE = SFRPAGE;        // Save Current SFR page
 680   1      
 681   1          SFRPAGE = CONFIG_PAGE;
 682   1      
 683   1          RE1 = 1;
 684   1          DE1 = 1;
 685   1          crc_z = crc_chk(buf, bufsize); //crc校验结果
 686   1          k = crc_z & 0x00ff;
 687   1      
 688   1          buf[bufsize] = (unsigned char)(k); //+CRC_Hi
 689   1          bufsize++;
 690   1          k = crc_z & 0xff00;
 691   1          k = k >> 8;
 692   1          buf[bufsize] = (unsigned char)(k); //+CRC_Li
 693   1          bufsize++;
 694   1          i = 0;
 695   1          delay_ms(10);
 696   1          ES0 = 0;
 697   1          SFRPAGE = UART0_PAGE;
C51 COMPILER V9.56.0.0   SUSONGXIAN                                                        04/28/2017 13:56:01 PAGE 14  

 698   1          do
 699   1          {
 700   2      //        ACC = buf[i];
 701   2      //        TB80 = P;
 702   2              SBUF0 = buf[i];
 703   2              while(!TI0);
 704   2              TI0 = 0;
 705   2              i++;
 706   2          } while(i < bufsize);
 707   1          ES0 = 1;
 708   1          SFRPAGE = CONFIG_PAGE ;
 709   1          RE1 = 0;
 710   1          DE1 = 0;
 711   1          delay_ms(10);
 712   1      
 713   1          SFRPAGE = SFRPAGE_SAVE;             // Restore SFR page
 714   1      }
 715          //-----------------------------------------------------------------------------
 716          //自定义延时
 717          //延时时间约为(us N10)毫秒
 718          //-----------------------------------------------------------------------------
 719          void delay1( unsigned int us)
 720          {
 721   1          unsigned int i = us;
 722   1          while(i--) ;
 723   1      }
 724          //速度模式，内部脉冲指令，测试用
 725          void send_to_motor(void)
 726          {
 727   1          delay_ms(50);
 728   1          ES0 = 0;
 729   1          buf[0] = 0X01; //站点地址
 730   1          buf[1] = 0x10; //写
 731   1          buf[2] = 0x51; //寄存器地址高位
 732   1          buf[3] = 0x00; //寄存器地址低位
 733   1          buf[4] = 0x00; //所写内容高位
 734   1          buf[5] = 0x0A; //所写内容低位
 735   1          buf[6] = 0x14;
 736   1          buf[7] = 0x01;//INC增量方式！！！
 737   1          buf[8] = 0x00;
 738   1          buf[9] = 0x00;
 739   1          buf[10] = 0x00;
 740   1          buf[11] = Servomotor_displace.buf[0];
 741   1          buf[12] = Servomotor_displace.buf[1];
 742   1          buf[13] = Servomotor_displace.buf[2];
 743   1          buf[14] = Servomotor_displace.buf[3];
 744   1      
 745   1          buf[15] = Servomotor_speed.buf[0];
 746   1          buf[16] = Servomotor_speed.buf[1];
 747   1          buf[17] = Servomotor_speed.buf[2];
 748   1          buf[18] = Servomotor_speed.buf[3];
 749   1      
 750   1          buf[19] = Servomotor_addtime.buf[0];
 751   1          buf[20] = Servomotor_addtime.buf[1];
 752   1          buf[21] = Servomotor_addtime.buf[2];
 753   1          buf[22] = Servomotor_addtime.buf[3];
 754   1      
 755   1          buf[23] = Servomotor_subtime.buf[0];
 756   1          buf[24] = Servomotor_subtime.buf[1];
 757   1          buf[25] = Servomotor_subtime.buf[2];
 758   1          buf[26] = Servomotor_subtime.buf[3];
 759   1          Uart0Send(buf, 27);
C51 COMPILER V9.56.0.0   SUSONGXIAN                                                        04/28/2017 13:56:01 PAGE 15  

 760   1          ES0 = 1;
 761   1          cmd_chk_cnt = 0;
 762   1          while(cmd_chk_cnt < CMD_CHK_MAX);
 763   1          if(Receive_command_finished == YES) //暂时不做过多的检查和校验，后期补上，加强安全性
 764   1          {
 765   2              Receive_command_finished = NO;
 766   2          }
 767   1      }
 768          
 769          
 770          //-----------------------------------------------------------------------------
 771          // 发送给伺服电机驱动器的CONT信号指令参数指令
 772          //node_id:伺服控制器的地址；
 773          //command:cont 信号指令,与位地址相关
 774          //-----------------------------------------------------------------------------
 775          void Send_to_Motordriver_CTL(unsigned char command )
 776          {
 777   1          unsigned char buf[50];
 778   1      
 779   1          UINTUNION temp;
 780   1          temp.value = command;
 781   1      
 782   1          buf[0] = 0X01; //站点地址
 783   1          buf[1] = 0x10; //写
 784   1      
 785   1          buf[2] = 0x00; //寄存器地址高位   针对CONT输入信号地址
 786   1          buf[3] = 0x00; //寄存器地址低位
 787   1      
 788   1          buf[4] = 0x00; //记录数
 789   1          buf[5] = 0x02; //记录数
 790   1      
 791   1          buf[6] = 0x04; //字节数
 792   1      
 793   1          buf[7] = 0x00; //所写内容最高字节
 794   1          buf[8] = 0x00; //所写内容次高字节
 795   1      //    buf[9] = temp.buf[0]; //所写内容次低字节
 796   1      //    buf[10] = temp.buf[1]; //所写内容最低字节
 797   1          buf[9] = 0; //所写内容次低字节
 798   1          buf[10] = command; //所写内容最低字节
 799   1      
 800   1          Uart0Send(buf, 11);
 801   1      
 802   1          cmd_chk_cnt = 0;
 803   1          while(cmd_chk_cnt < CMD_CHK_MAX);
 804   1          if(Receive_command_finished == YES) //暂时不做过多的检查和校验，后期补上，加强安全性
 805   1          {
 806   2              Receive_command_finished = NO;
 807   2          }
 808   1      }
 809          //运行显示
 810          void RunLEDDIS(void)
 811          {
 812   1          if(T0Counter5 >= 20) //200ms时间定时
 813   1          {
 814   2              T0Counter5 = 0 ;
 815   2              LED2 = !LED2;
 816   2          }
 817   1      }
 818          //步进电机控制
 819          void DC_motorCTRL(void)
 820          {
 821   1          char SFRPAGE_SAVE = SFRPAGE;        // Save Current SFR page
C51 COMPILER V9.56.0.0   SUSONGXIAN                                                        04/28/2017 13:56:01 PAGE 16  

 822   1          switch(CANcomand)
 823   1          {
 824   2          case 0xD5:
 825   2              switch(CANINDEX)
 826   2              {
 827   3              case 0://左上翻
 828   3                  SFRPAGE = 0x0F;
 829   3                  if(DC_motor2 == 0)
 830   3                  {
 831   4                      DC_motor2 = 1;
 832   4                      delay_ms(1000);
 833   4                      DC_motor1 = 0;
 834   4                      T0Counter6 = 0;
 835   4                  }
 836   3                  else
 837   3                  {
 838   4                      DC_motor2 = 1;
 839   4                      DC_motor1 = 0;
 840   4                      T0Counter6 = 0;
 841   4                  }
 842   3                  SFRPAGE = SFRPAGE_SAVE;
 843   3                  break;
 844   3              case 1://左下翻
 845   3                  SFRPAGE = 0x0F;
 846   3                  if(DC_motor1 == 0)
 847   3                  {
 848   4                      DC_motor1 = 1;
 849   4                      delay_ms(1000);
 850   4                      DC_motor2 = 0;
 851   4                      T0Counter6 = 0;
 852   4                  }
 853   3                  else
 854   3                  {
 855   4                      DC_motor1 = 1;
 856   4                      DC_motor2 = 0;
 857   4                      T0Counter6 = 0;
 858   4                  }
 859   3                  SFRPAGE = SFRPAGE_SAVE;
 860   3                  break;
 861   3      
 862   3              default:
 863   3                  break;
 864   3              }
 865   2              Time_FLAG1 = NO;
 866   2              CANTRASTEMINFOR[14] = 0; //清除运行时间
 867   2              CANTRASTEMINFOR[15] = 0;
 868   2              Step_FLAG = NO;
 869   2              nCANcomand = 0;
 870   2              CANcomand = 0x00;
 871   2              T0Counter6 = 0;
 872   2              break;
 873   2          case 0xD6://停止
 874   2              switch(CANINDEX)
 875   2              {
 876   3              case 0://左上翻停止
 877   3                  SFRPAGE = 0x0F;
 878   3                  DC_motor1 = 1;
 879   3                  SFRPAGE = SFRPAGE_SAVE;
 880   3                  ShowTime = T0Counter6 * 10;
 881   3                  Step_FLAG = YES;
 882   3                  break;
 883   3              case 1://右上翻停止
C51 COMPILER V9.56.0.0   SUSONGXIAN                                                        04/28/2017 13:56:01 PAGE 17  

 884   3                  SFRPAGE = 0x0F;
 885   3                  DC_motor2 = 1;
 886   3                  SFRPAGE = SFRPAGE_SAVE;
 887   3                  ShowTime = T0Counter6 * 10;
 888   3                  Step_FLAG = YES;
 889   3                  break;
 890   3              default:
 891   3                  break;
 892   3              }
 893   2              nCANcomand = 0;
 894   2              CANcomand = 0x00;
 895   2              break;
 896   2          case 0xD7:
 897   2      
 898   2              switch(CANINDEX)
 899   2              {
 900   3              case 0://右上翻
 901   3                  SFRPAGE = 0x0F;
 902   3                  if(DC_motor4 == 0)
 903   3                  {
 904   4                      DC_motor4 = 1;
 905   4                      delay_ms(1000);
 906   4                      DC_motor3 = 0;
 907   4                      T0Counter6 = 0;
 908   4                  }
 909   3                  else
 910   3                  {
 911   4                      DC_motor4 = 1;
 912   4                      DC_motor3 = 0;
 913   4                      T0Counter6 = 0;
 914   4                  }
 915   3                  SFRPAGE = SFRPAGE_SAVE;
 916   3                  break;
 917   3              case 1://右下翻
 918   3                  SFRPAGE = 0x0F;
 919   3                  if(DC_motor3 == 0)
 920   3                  {
 921   4                      DC_motor3 = 1;
 922   4                      delay_ms(1000);
 923   4                      DC_motor4 = 0;
 924   4                      T0Counter6 = 0;
 925   4                  }
 926   3                  else
 927   3                  {
 928   4                      DC_motor3 = 1;
 929   4                      DC_motor4 = 0;
 930   4                      T0Counter6 = 0;
 931   4                  }
 932   3                  SFRPAGE = SFRPAGE_SAVE;
 933   3                  break;
 934   3      
 935   3              default:
 936   3                  break;
 937   3              }
 938   2              Time_FLAG1 = NO;
 939   2              CANTRASTEMINFOR[14] = 0; //清除运行时间
 940   2              CANTRASTEMINFOR[15] = 0;
 941   2      
 942   2              Step_FLAG = NO;
 943   2              nCANcomand = 0;
 944   2              CANcomand = 0x00;
 945   2              T0Counter6 = 0;
C51 COMPILER V9.56.0.0   SUSONGXIAN                                                        04/28/2017 13:56:01 PAGE 18  

 946   2              break;
 947   2          case 0xD8:
 948   2              switch(CANINDEX)
 949   2              {
 950   3              case 0:
 951   3                  SFRPAGE = 0x0F;
 952   3                  DC_motor3 = 1;
 953   3                  SFRPAGE = SFRPAGE_SAVE;
 954   3                  ShowTime = T0Counter6 * 10;
 955   3                  Step_FLAG = YES;
 956   3                  break;
 957   3              case 1:
 958   3                  SFRPAGE = 0x0F;
 959   3                  DC_motor4 = 1;
 960   3                  SFRPAGE = SFRPAGE_SAVE;
 961   3                  ShowTime = T0Counter6 * 10;
 962   3                  Step_FLAG = YES;
 963   3                  break;
 964   3              default:
 965   3                  break;
 966   3              }
 967   2              nCANcomand = 0;
 968   2              CANcomand = 0x00;
 969   2              break;
 970   2          default:
 971   2              break;
 972   2          }
 973   1          DCmotor_CTL();
 974   1      
 975   1      }
 976          /*******************************************************************************************************
 977          //伺服电机运行函数包括报警量采集
 978          /*******************************************************************************************************/
 979          void ServomotorCRTL(unsigned char comand)//伺服电机控制
 980          {
 981   1          unsigned char CALU_m_pra = 0;
 982   1          CALU_m_pra = CANINDEX * 16;
 983   1      
 984   1          switch(comand)
 985   1          {
 986   2          case 0xD0:
 987   2              Send_to_Motordriver_CTL(0x01);
 988   2              Servomotor_displace.displace = Servoparadisplace;
 989   2              Servomotor_speed.speed = Servoparaspeed;
 990   2              Servomotor_addtime.addtime = 1000;
 991   2              Servomotor_subtime.subtime = 1000;
 992   2              send_to_motor();
 993   2              Send_to_Motordriver_CTL(0x03);
 994   2              Send_to_Motordriver_CTL(0x01);
 995   2              CANcomand = 0x00;
 996   2              nCANcomand = 0;
 997   2              break;
 998   2          case 0xD2:
 999   2              Send_to_Motordriver_CTL(0x00);
1000   2              nCANcomand = 0;
1001   2              CANcomand = 0x00;
1002   2              break;
1003   2          case 0x11:
1004   2              Send_to_Motordriver_CTL(0x01);
1005   2              nCANcomand = 0;
1006   2              CANcomand = 0x00;
1007   2              break;
C51 COMPILER V9.56.0.0   SUSONGXIAN                                                        04/28/2017 13:56:01 PAGE 19  

1008   2          case 0xD3:
1009   2      
1010   2              Receive485_command_finished = NO;
1011   2              Servomotor_displace.buf[0] = Servopara[CALU_m_pra];
1012   2              Servomotor_displace.buf[1] = Servopara[CALU_m_pra + 1];
1013   2              Servomotor_displace.buf[2] = Servopara[CALU_m_pra + 2];
1014   2              Servomotor_displace.buf[3] = Servopara[CALU_m_pra + 3];
1015   2      
1016   2              Servomotor_speed.buf[0] = Servopara[CALU_m_pra + 4];
1017   2              Servomotor_speed.buf[1] = Servopara[CALU_m_pra + 5];
1018   2              Servomotor_speed.buf[2] = Servopara[CALU_m_pra + 6];
1019   2              Servomotor_speed.buf[3] = Servopara[CALU_m_pra + 7];
1020   2      
1021   2              Servomotor_addtime.buf[0] = Servopara[CALU_m_pra + 8];
1022   2              Servomotor_addtime.buf[1] = Servopara[CALU_m_pra + 9];
1023   2              Servomotor_addtime.buf[2] = Servopara[CALU_m_pra + 10];
1024   2              Servomotor_addtime.buf[3] = Servopara[CALU_m_pra + 11];
1025   2      
1026   2              Servomotor_subtime.buf[0] = Servopara[CALU_m_pra + 12];
1027   2              Servomotor_subtime.buf[1] = Servopara[CALU_m_pra + 13];
1028   2              Servomotor_subtime.buf[2] = Servopara[CALU_m_pra + 14];
1029   2              Servomotor_subtime.buf[3] = Servopara[CALU_m_pra + 15];
1030   2      
1031   2              CANTRASTEMINFOR[14] = 0;
1032   2              CANTRASTEMINFOR[15] = 0;
1033   2              Send_to_Motordriver_CTL(0x01);
1034   2              send_to_motor();
1035   2              Send_to_Motordriver_CTL(0x03);
1036   2              Send_to_Motordriver_CTL(0x01);
1037   2              T0Counter6 = 0;
1038   2              CANcomand = 0x00;
1039   2              nCANcomand = 0;
1040   2              Time_FLAG = NO;
1041   2              CANTRASTEMINFOR[12] = CANTRASTEMINFOR[12] | 0X01; //置运行标志
1042   2              Receive485_command_finished = YES;
1043   2              break;
1044   2          case 0xD4:
1045   2              Returntopoint();
1046   2              CANcomand = 0x00;
1047   2              nCANcomand = 0;
1048   2              break;
1049   2          default:
1050   2              break;
1051   2          }
1052   1          //上传命令反馈数据
1053   1      
1054   1      
1055   1      }
1056          /*******************************************************************************************************
1057          //自动运行1
1058          /*******************************************************************************************************/
1059          void AUTORUNMODE1(unsigned char comand)
1060          {
1061   1      
1062   1          switch(comand)
1063   1          {
1064   2          case 0xF0:
1065   2              Receive485_command_finished = NO;
1066   2              CANTRASTEMINFOR[14] = 0;
1067   2              CANTRASTEMINFOR[15] = 0;
1068   2              Send_to_Motordriver_CTL(0x01);
1069   2              Servomotor_displace.displace = Servoparadisplace;
C51 COMPILER V9.56.0.0   SUSONGXIAN                                                        04/28/2017 13:56:01 PAGE 20  

1070   2              Servomotor_speed.speed = 200000;
1071   2              Servomotor_addtime.addtime = 2000;
1072   2              Servomotor_subtime.subtime = 2000;
1073   2              send_to_motor();
1074   2              Send_to_Motordriver_CTL(0x03);
1075   2              Send_to_Motordriver_CTL(0x01);
1076   2              T0Counter6 = 0;
1077   2              Time_FLAG = NO;
1078   2              CANTRASTEMINFOR[12] = CANTRASTEMINFOR[12] | 0X01; //置运行标志
1079   2              Receive485_command_finished = YES;
1080   2              break;
1081   2      
1082   2          case 0xF1:
1083   2              Receive485_command_finished = NO;
1084   2              CANTRASTEMINFOR[14] = 0;
1085   2              CANTRASTEMINFOR[15] = 0;
1086   2              Send_to_Motordriver_CTL(0x01);
1087   2              Servomotor_displace.displace = Servoparadisplace;
1088   2              Servomotor_speed.speed = 200000;
1089   2              Servomotor_addtime.addtime = 2000;
1090   2              Servomotor_subtime.subtime = 2000;
1091   2              send_to_motor();
1092   2              Send_to_Motordriver_CTL(0x03);
1093   2              Send_to_Motordriver_CTL(0x01);
1094   2              T0Counter6 = 0;
1095   2              Time_FLAG = NO;
1096   2              START_FINISHFLAG = YES;
1097   2              CANTRASTEMINFOR[12] = CANTRASTEMINFOR[12] | 0X01; //置运行标志
1098   2              Receive485_command_finished = YES;
1099   2              break;
1100   2      
1101   2          case 0xFA:
1102   2              Send_to_Motordriver_CTL(0x00);
1103   2              break;
1104   2      
1105   2          default:
1106   2              break;
1107   2          }
1108   1          //Shaft1_CTL( Shaft1_Run_mode,Shaft1_aim_pulse);    //1号电机
1109   1      
1110   1      
1111   1      }
1112          /*******************************************************************************************************
1113          //自动运行2
1114          /*******************************************************************************************************/
1115          void AUTORUNMODE2(unsigned char comand)
1116          {
1117   1      
1118   1          char SFRPAGE_SAVE ;        // Save Current SFR page
1119   1      
1120   1          switch(comand)
1121   1          {
1122   2          case 0xF2:  //输送线向左推0.5米
1123   2              Receive485_command_finished = NO;
1124   2      //        Servomotor_displace.buf[0] = Servopara[0];
1125   2      //        Servomotor_displace.buf[1] = Servopara[1];
1126   2      //        Servomotor_displace.buf[2] = Servopara[2];
1127   2      //        Servomotor_displace.buf[3] = Servopara[3];
1128   2      
1129   2      //        Servomotor_speed.buf[0] = Servopara[4];
1130   2      //        Servomotor_speed.buf[1] = Servopara[5];
1131   2      //        Servomotor_speed.buf[2] = Servopara[6];
C51 COMPILER V9.56.0.0   SUSONGXIAN                                                        04/28/2017 13:56:01 PAGE 21  

1132   2      //        Servomotor_speed.buf[3] = Servopara[7];
1133   2      
1134   2      //        Servomotor_addtime.buf[0] = Servopara[8];
1135   2      //        Servomotor_addtime.buf[1] = Servopara[9];
1136   2      //        Servomotor_addtime.buf[2] = Servopara[10];
1137   2      //        Servomotor_addtime.buf[3] = Servopara[11];
1138   2      
1139   2      //        Servomotor_subtime.buf[0] = Servopara[12];
1140   2      //        Servomotor_subtime.buf[1] = Servopara[13];
1141   2      //        Servomotor_subtime.buf[2] = Servopara[14];
1142   2      //        Servomotor_subtime.buf[3] = Servopara[15];
1143   2      
1144   2              Servomotor_displace.displace = -1000;
1145   2              Servomotor_speed.speed = 50000;
1146   2              Servomotor_addtime.addtime = 200;
1147   2              Servomotor_subtime.subtime = 200;
1148   2      
1149   2              CANTRASTEMINFOR[14] = 0;
1150   2              CANTRASTEMINFOR[15] = 0;
1151   2              Send_to_Motordriver_CTL(0x01);
1152   2              send_to_motor();
1153   2              Send_to_Motordriver_CTL(0x03);
1154   2              Send_to_Motordriver_CTL(0x01);
1155   2              T0Counter6 = 0;
1156   2              Time_FLAG = NO;
1157   2              CANTRASTEMINFOR[12] = CANTRASTEMINFOR[12] | 0X01; //置运行标志
1158   2              Receive485_command_finished = YES;
1159   2              break;
1160   2      
1161   2          case 0xF3:  //输送线向右推0.5米
1162   2              Receive485_command_finished = NO;
1163   2      //        Servomotor_displace.buf[0] = Servopara[32];
1164   2      //        Servomotor_displace.buf[1] = Servopara[33];
1165   2      //        Servomotor_displace.buf[2] = Servopara[34];
1166   2      //        Servomotor_displace.buf[3] = Servopara[35];
1167   2      
1168   2      //        Servomotor_speed.buf[0] = Servopara[36];
1169   2      //        Servomotor_speed.buf[1] = Servopara[37];
1170   2      //        Servomotor_speed.buf[2] = Servopara[38];
1171   2      //        Servomotor_speed.buf[3] = Servopara[39];
1172   2      
1173   2      //        Servomotor_addtime.buf[0] = Servopara[40];
1174   2      //        Servomotor_addtime.buf[1] = Servopara[41];
1175   2      //        Servomotor_addtime.buf[2] = Servopara[42];
1176   2      //        Servomotor_addtime.buf[3] = Servopara[43];
1177   2      
1178   2      //        Servomotor_subtime.buf[0] = Servopara[44];
1179   2      //        Servomotor_subtime.buf[1] = Servopara[45];
1180   2      //        Servomotor_subtime.buf[2] = Servopara[46];
1181   2      //        Servomotor_subtime.buf[3] = Servopara[47];
1182   2      
1183   2              Servomotor_displace.displace = 1000;
1184   2              Servomotor_speed.speed = 50000;
1185   2              Servomotor_addtime.addtime = 200;
1186   2              Servomotor_subtime.subtime = 200;
1187   2      
1188   2              CANTRASTEMINFOR[14] = 0;
1189   2              CANTRASTEMINFOR[15] = 0;
1190   2              Send_to_Motordriver_CTL(0x01);
1191   2      
1192   2              send_to_motor();
1193   2              Send_to_Motordriver_CTL(0x03);
C51 COMPILER V9.56.0.0   SUSONGXIAN                                                        04/28/2017 13:56:01 PAGE 22  

1194   2              Send_to_Motordriver_CTL(0x01);
1195   2              T0Counter6 = 0;
1196   2              Time_FLAG = NO;
1197   2              CANTRASTEMINFOR[12] = CANTRASTEMINFOR[12] | 0X01; //置运行标志
1198   2              Receive485_command_finished = YES;
1199   2              break;
1200   2      
1201   2          case 0XF4:  //左闸门上行
1202   2              SFRPAGE_SAVE = SFRPAGE;
1203   2              SFRPAGE = 0x0F;
1204   2              if(DC_motor1 == 0)
1205   2              {
1206   3                  DC_motor1 = 1;
1207   3                  delay_ms(100);
1208   3                  DC_motor2 = 0;
1209   3                  T0Counter6 = 0;
1210   3              }
1211   2              else
1212   2              {
1213   3                  DC_motor1 = 1;
1214   3                  DC_motor2 = 0;
1215   3                  T0Counter6 = 0;
1216   3              }
1217   2              SFRPAGE = SFRPAGE_SAVE;
1218   2              break;
1219   2      
1220   2          case 0XF5:  //右闸门上行
1221   2              SFRPAGE_SAVE = SFRPAGE;
1222   2              SFRPAGE = 0x0F;
1223   2              if(DC_motor3 == 0)
1224   2              {
1225   3                  DC_motor3 = 1;
1226   3                  delay_ms(100);
1227   3                  DC_motor4 = 0;
1228   3                  T0Counter6 = 0;
1229   3              }
1230   2              else
1231   2              {
1232   3                  DC_motor3 = 1;
1233   3                  DC_motor4 = 0;
1234   3                  T0Counter6 = 0;
1235   3              }
1236   2              SFRPAGE = SFRPAGE_SAVE;
1237   2              break;
1238   2      
1239   2          case 0xF6:  //前进1米
1240   2              Receive485_command_finished = NO;
1241   2      //        Servomotor_displace.buf[0] = Servopara[16];
1242   2      //        Servomotor_displace.buf[1] = Servopara[17];
1243   2      //        Servomotor_displace.buf[2] = Servopara[18];
1244   2      //        Servomotor_displace.buf[3] = Servopara[19];
1245   2      
1246   2      //        Servomotor_speed.buf[0] = Servopara[20];
1247   2      //        Servomotor_speed.buf[1] = Servopara[21];
1248   2      //        Servomotor_speed.buf[2] = Servopara[22];
1249   2      //        Servomotor_speed.buf[3] = Servopara[23];
1250   2      
1251   2      //        Servomotor_addtime.buf[0] = Servopara[24];
1252   2      //        Servomotor_addtime.buf[1] = Servopara[25];
1253   2      //        Servomotor_addtime.buf[2] = Servopara[26];
1254   2      //        Servomotor_addtime.buf[3] = Servopara[27];
1255   2      
C51 COMPILER V9.56.0.0   SUSONGXIAN                                                        04/28/2017 13:56:01 PAGE 23  

1256   2      //        Servomotor_subtime.buf[0] = Servopara[28];
1257   2      //        Servomotor_subtime.buf[1] = Servopara[29];
1258   2      //        Servomotor_subtime.buf[2] = Servopara[30];
1259   2      //        Servomotor_subtime.buf[3] = Servopara[31];
1260   2      
1261   2              Servomotor_displace.displace = -2000;
1262   2              Servomotor_speed.speed = 50000;
1263   2              Servomotor_addtime.addtime = 200;
1264   2              Servomotor_subtime.subtime = 200;
1265   2      
1266   2              CANTRASTEMINFOR[14] = 0;
1267   2              CANTRASTEMINFOR[15] = 0;
1268   2              Send_to_Motordriver_CTL(0x01);
1269   2              send_to_motor();
1270   2              Send_to_Motordriver_CTL(0x03);
1271   2              Send_to_Motordriver_CTL(0x01);
1272   2              T0Counter6 = 0;
1273   2              Time_FLAG = NO;
1274   2              START_FINISHFLAG = YES;
1275   2              CANTRASTEMINFOR[12] = CANTRASTEMINFOR[12] | 0X01; //置运行标志
1276   2              Receive485_command_finished = YES;
1277   2              break;
1278   2      
1279   2          case 0xF7:  //前进1米
1280   2              Receive485_command_finished = NO;
1281   2      //        Servomotor_displace.buf[0] = Servopara[48];
1282   2      //        Servomotor_displace.buf[1] = Servopara[49];
1283   2      //        Servomotor_displace.buf[2] = Servopara[50];
1284   2      //        Servomotor_displace.buf[3] = Servopara[51];
1285   2      
1286   2      //        Servomotor_speed.buf[0] = Servopara[52];
1287   2      //        Servomotor_speed.buf[1] = Servopara[53];
1288   2      //        Servomotor_speed.buf[2] = Servopara[54];
1289   2      //        Servomotor_speed.buf[3] = Servopara[55];
1290   2      
1291   2      //        Servomotor_addtime.buf[0] = Servopara[56];
1292   2      //        Servomotor_addtime.buf[1] = Servopara[57];
1293   2      //        Servomotor_addtime.buf[2] = Servopara[58];
1294   2      //        Servomotor_addtime.buf[3] = Servopara[59];
1295   2      
1296   2      //        Servomotor_subtime.buf[0] = Servopara[60];
1297   2      //        Servomotor_subtime.buf[1] = Servopara[61];
1298   2      //        Servomotor_subtime.buf[2] = Servopara[62];
1299   2      //        Servomotor_subtime.buf[3] = Servopara[63];
1300   2      
1301   2              Servomotor_displace.displace = 2000;
1302   2              Servomotor_speed.speed = 50000;
1303   2              Servomotor_addtime.addtime = 200;
1304   2              Servomotor_subtime.subtime = 200;
1305   2      
1306   2              CANTRASTEMINFOR[14] = 0;
1307   2              CANTRASTEMINFOR[15] = 0;
1308   2              Send_to_Motordriver_CTL(0x01);
1309   2              send_to_motor();
1310   2              Send_to_Motordriver_CTL(0x03);
1311   2              Send_to_Motordriver_CTL(0x01);
1312   2              T0Counter6 = 0;
1313   2              Time_FLAG = NO;
1314   2              START_FINISHFLAG = YES;
1315   2              CANTRASTEMINFOR[12] = CANTRASTEMINFOR[12] | 0X01; //置运行标志
1316   2              Receive485_command_finished = YES;
1317   2              break;
C51 COMPILER V9.56.0.0   SUSONGXIAN                                                        04/28/2017 13:56:01 PAGE 24  

1318   2      
1319   2          case 0XF8:  //左闸门下行
1320   2              SFRPAGE_SAVE = SFRPAGE;
1321   2              SFRPAGE = 0x0F;
1322   2              if(DC_motor2 == 0)
1323   2              {
1324   3                  DC_motor2 = 1;
1325   3                  delay_ms(100);
1326   3                  DC_motor1 = 0;
1327   3                  T0Counter6 = 0;
1328   3              }
1329   2              else
1330   2              {
1331   3                  DC_motor2 = 1;
1332   3                  DC_motor1 = 0;
1333   3                  T0Counter6 = 0;
1334   3              }
1335   2              SFRPAGE = SFRPAGE_SAVE;
1336   2              break;
1337   2      
1338   2          case 0XF9:  //右闸门下行
1339   2              SFRPAGE_SAVE = SFRPAGE;
1340   2              SFRPAGE = 0x0F;
1341   2              if(DC_motor4 == 0)
1342   2              {
1343   3                  DC_motor4 = 1;
1344   3                  delay_ms(100);
1345   3                  DC_motor3 = 0;
1346   3                  T0Counter6 = 0;
1347   3              }
1348   2              else
1349   2              {
1350   3                  DC_motor4 = 1;
1351   3                  DC_motor3 = 0;
1352   3                  T0Counter6 = 0;
1353   3              }
1354   2              SFRPAGE = SFRPAGE_SAVE;
1355   2              break;
1356   2      
1357   2          case 0xFA:  //关闭伺服
1358   2              Send_to_Motordriver_CTL(0x00);
1359   2              break;
1360   2      
1361   2          case 0xFB:  //关闭所有直流电机
1362   2              SFRPAGE_SAVE = SFRPAGE;
1363   2              SFRPAGE = 0x0F;
1364   2              DC_motor1 = 1;
1365   2              DC_motor2 = 1;
1366   2              DC_motor3 = 1;
1367   2              DC_motor4 = 1;
1368   2              SFRPAGE_SAVE = SFRPAGE;
1369   2              break;
1370   2      
1371   2          case 0xFC:  //关闭所有直流电机
1372   2              SFRPAGE_SAVE = SFRPAGE;
1373   2              SFRPAGE = 0x0F;
1374   2              DC_motor1 = 1;
1375   2              DC_motor2 = 1;
1376   2              DC_motor3 = 1;
1377   2              DC_motor4 = 1;
1378   2              SFRPAGE_SAVE = SFRPAGE;
1379   2              break;
C51 COMPILER V9.56.0.0   SUSONGXIAN                                                        04/28/2017 13:56:01 PAGE 25  

1380   2      
1381   2              //added begin
1382   2              //
1383   2          case 0xFD:  //启动long slow run
1384   2              Receive485_command_finished = NO;
1385   2              //
1386   2              Servomotor_displace.displace = UNLIMITED_DISTANCE_LEFT;
1387   2              //
1388   2              Servomotor_speed.speed = UNLIMITED_SPEED;
1389   2              //
1390   2              Servomotor_addtime.addtime = UNLIMITED_ADDTIME;
1391   2              //
1392   2              Servomotor_subtime.subtime = UNLIMITED_SUBTIME;
1393   2              //
1394   2              CANTRASTEMINFOR[14] = 0;
1395   2              CANTRASTEMINFOR[15] = 0;
1396   2              Send_to_Motordriver_CTL(0x01);
1397   2              send_to_motor();
1398   2              Send_to_Motordriver_CTL(0x03);
1399   2              Send_to_Motordriver_CTL(0x01);
1400   2              T0Counter6 = 0;
1401   2              Time_FLAG = NO;
1402   2              CANTRASTEMINFOR[12] = CANTRASTEMINFOR[12] | 0X01; //置运行标志
1403   2              Receive485_command_finished = YES;
1404   2              break;
1405   2      
1406   2          case 0xFE:  //启动long slow run
1407   2              Receive485_command_finished = NO;
1408   2              //
1409   2              Servomotor_displace.displace = UNLIMITED_DISTANCE_RIGHT;
1410   2              //
1411   2              Servomotor_speed.speed = UNLIMITED_SPEED;
1412   2              //
1413   2              Servomotor_addtime.addtime = UNLIMITED_ADDTIME;
1414   2              //
1415   2              Servomotor_subtime.subtime = UNLIMITED_SUBTIME;
1416   2              //
1417   2              CANTRASTEMINFOR[14] = 0;
1418   2              CANTRASTEMINFOR[15] = 0;
1419   2              Send_to_Motordriver_CTL(0x01);
1420   2              send_to_motor();
1421   2              Send_to_Motordriver_CTL(0x03);
1422   2              Send_to_Motordriver_CTL(0x01);
1423   2              T0Counter6 = 0;
1424   2              Time_FLAG = NO;
1425   2              CANTRASTEMINFOR[12] = CANTRASTEMINFOR[12] | 0X01; //置运行标志
1426   2              Receive485_command_finished = YES;
1427   2              break;
1428   2      
1429   2          case 0xFF:  //停止long slow run
1430   2              Send_to_Motordriver_CTL(0x00);
1431   2              break;
1432   2              //added end
1433   2      
1434   2          default:
1435   2              break;
1436   2          }
1437   1          SFRPAGE = SFRPAGE_SAVE;
1438   1      }
1439          /*******************************************************************************************************
1440          //自动运行3
1441          /*******************************************************************************************************/
C51 COMPILER V9.56.0.0   SUSONGXIAN                                                        04/28/2017 13:56:01 PAGE 26  

1442          void AUTORUNMODE3(unsigned char comand)
1443          {
1444   1      
1445   1          char SFRPAGE_SAVE ;        // Save Current SFR page
1446   1          switch(comand)
1447   1          {
1448   2          case 0xE0:
1449   2              Deviationremoval();//偏差清除
1450   2              Send_to_Motordriver_CTL(0x00);//关闭使能
1451   2              break;
1452   2      
1453   2          case 0xE1:  //左右翻板复位（下行到下限位）
1454   2              if((CANTRASTEMINFOR[13] & 0x01) != 0x01)
1455   2              {
1456   3                  SFRPAGE = 0x0F;
1457   3                  if(DC_motor2 == 0)
1458   3                  {
1459   4                      DC_motor2 = 1;
1460   4                      delay_ms(1000);
1461   4                      DC_motor1 = 0;
1462   4                      T0Counter6 = 0;
1463   4                  }
1464   3                  else
1465   3                  {
1466   4                      DC_motor2 = 1;
1467   4                      DC_motor1 = 0;
1468   4                      T0Counter6 = 0;
1469   4                  }
1470   3                  SFRPAGE = SFRPAGE_SAVE;
1471   3              }
1472   2              if((CANTRASTEMINFOR[13] & 0x04) != 0x04)
1473   2              {
1474   3                  SFRPAGE = 0x0F;
1475   3                  if(DC_motor4 == 0)
1476   3                  {
1477   4                      DC_motor4 = 1;
1478   4                      delay_ms(1000);
1479   4                      DC_motor3 = 0;
1480   4                      T0Counter6 = 0;
1481   4                  }
1482   3                  else
1483   3                  {
1484   4                      DC_motor4 = 1;
1485   4                      DC_motor3 = 0;
1486   4                      T0Counter6 = 0;
1487   4                  }
1488   3                  SFRPAGE = SFRPAGE_SAVE;
1489   3              }
1490   2              break;
1491   2      
1492   2          case 0xE2:
1493   2              SFRPAGE_SAVE = SFRPAGE;
1494   2              SFRPAGE = 0x0F;
1495   2              DC_motor1 = 1;
1496   2              DC_motor2 = 1;
1497   2              DC_motor3 = 1;
1498   2              DC_motor4 = 1;
1499   2              SFRPAGE_SAVE = SFRPAGE;
1500   2              break;
1501   2      
1502   2          default:
1503   2              break;
C51 COMPILER V9.56.0.0   SUSONGXIAN                                                        04/28/2017 13:56:01 PAGE 27  

1504   2          }
1505   1      }
1506          //CRC校验
1507          unsigned int crc_chk(unsigned char *puchMsg, unsigned char length)
1508          {
1509   1          int j;
1510   1          unsigned int crc_reg = 0xFFFF;
1511   1          while(length--)
1512   1          {
1513   2              crc_reg ^= *puchMsg++;
1514   2              for(j = 0; j < 8; j++)
1515   2              {
1516   3                  if(crc_reg & 0x01)
1517   3                  {
1518   4                      crc_reg = (crc_reg >> 1) ^ 0xA001;
1519   4                  }
1520   3                  else
1521   3                  {
1522   4                      crc_reg = crc_reg >> 1;
1523   4                  }
1524   3              }
1525   2          }
1526   1          return crc_reg;
1527   1      }
1528          
1529          //
1530          void Returntopoint(void)
1531          {
1532   1          Send_to_Motordriver_CTL(0x01);//保持S-ON
1533   1          Send_to_Motordriver_CTL(0x05);//
1534   1          Send_to_Motordriver_CTL(0x01);//
1535   1          Time_FLAG = NO;
1536   1          CANTRASTEMINFOR[12] = CANTRASTEMINFOR[12] | 0X02; //置运行标志
1537   1      }
1538          
1539          //偏差清除
1540          void Deviationremoval(void)
1541          {
1542   1          Send_to_Motordriver_CTL(0x01);//保持S-ON
1543   1          Send_to_Motordriver_CTL(0x09);//
1544   1          Send_to_Motordriver_CTL(0x01);//
1545   1          Time_FLAG = NO;
1546   1      }
1547          /*void ServomotorDataacquisition(unsigned char addressID)
1548          {
1549          
1550            //if(ENABFLAG==YES)
1551            //{
1552            if(Time_FLAG==YES) return;
1553            delay_ms(50);
1554            buf[0]=addressID;//站点地址
1555            buf[1]=0x03;//读
1556            buf[2]=0x10;//寄存器地址高位
1557            buf[3]=0x03;//寄存器地址低位
1558            buf[4]=0x00;//所写内容高位
1559            buf[5]=0x06;//所写内容低位
1560            Uart0Send(buf,6);
1561            AUTO_FLAG=YES;
1562            cmd_chk_cnt=0;
1563            while(cmd_chk_cnt<CMD_CHK_MAX );
1564            if(Receive_command_finished==YES)
1565            {
C51 COMPILER V9.56.0.0   SUSONGXIAN                                                        04/28/2017 13:56:01 PAGE 28  

1566              //以后总传
1567              Receive_command_finished=NO;
1568              CANTRASTEMINFOR[0]=RxBuf1.buf[7];
1569              CANTRASTEMINFOR[1]=RxBuf1.buf[8];
1570              CANTRASTEMINFOR[2]=RxBuf1.buf[9];
1571              CANTRASTEMINFOR[3]=RxBuf1.buf[10];
1572              CANTRASTEMINFOR[4]=RxBuf1.buf[11];
1573              CANTRASTEMINFOR[5]=RxBuf1.buf[12];
1574              CANTRASTEMINFOR[6]=RxBuf1.buf[13];
1575              CANTRASTEMINFOR[7]=RxBuf1.buf[14];
1576            }
1577            AUTO_FLAG=NO;
1578          }*/
1579          /*void CurrentCollection(unsigned char addressID)
1580          {
1581          
1582            //if(ENABFLAG==YES)
1583            //{
1584            if(Time_FLAG1==YES) return;
1585            delay_ms(50);
1586            buf[0]=addressID;//站点地址
1587            buf[1]=0x03;//读
1588            buf[2]=0x00;
1589            buf[3]=0x00;
1590            buf[4]=0x00;
1591            buf[5]=0x08;
1592            Uart0Send(buf,6);
1593            AUTO_FLAG=YES;
1594            cmd_chk_cnt=0;
1595            while(cmd_chk_cnt<CMD_CHK_MAX);
1596            if(Receive_command_finished==YES)
1597            {
1598              //以后总传
1599              Receive_command_finished=NO;
1600              CANTRASTEMINFOR[8]=RxBuf1.buf[3];
1601              CANTRASTEMINFOR[9]=RxBuf1.buf[4];
1602              CANTRASTEMINFOR[10]=RxBuf1.buf[5];
1603              CANTRASTEMINFOR[11]=RxBuf1.buf[6];
1604          
1605            }
1606            AUTO_FLAG=NO;;
1607          
1608            //}
1609          }*/
1610          /*void Dataacquisition()//数据采集
1611          {
1612          
1613            if((CANcomand==0&&nCANcomand==0)||(nCANcomand==0xFE)||(CANcomand==0xFE)||(nCANcomand==0xFD)||(CANcomand==
             -0xFD)||(nCANcomand==0xFC)||(CANcomand==0xFC))
1614            {
1615              //if(T0Counter3>=20)  //200ms时间定时
1616              //{
1617              //T0Counter3=0;
1618              ServomotorINP(1);
1619              switch(Sampleperiod)
1620              {
1621              case 0:
1622                if(SAMPLE_FLAG==NO)//无完成标志采集
1623                {
1624                  ServomotorDataacquisition(1);//伺服电机数据采集
1625                }
1626                break;
C51 COMPILER V9.56.0.0   SUSONGXIAN                                                        04/28/2017 13:56:01 PAGE 29  

1627              case 1:
1628                CurrentCollection(2);
1629                break;
1630              default:
1631                break;
1632              }
1633              Sampleperiod=Sampleperiod+1;
1634              if(Sampleperiod>=2) {Sampleperiod=0;}
1635          
1636            }
1637            //}
1638          }*/
1639          void ServomotorINP(unsigned char addressID)//伺服电机定位运行结束确认查询函数
1640          {
1641   1      
1642   1          unsigned int ShowTime1;
1643   1          //if(ENABFLAG==YES)
1644   1          //{
1645   1          if(Time_FLAG == YES) return;
1646   1          delay_ms(50);
1647   1          buf[0] = addressID; //站点地址
1648   1          buf[1] = 0x03; //读
1649   1          buf[2] = 0x01; //寄存器地址高位
1650   1          buf[3] = 0x00; //寄存器地址低位
1651   1          buf[4] = 0x00; //所写内容高位
1652   1          buf[5] = 0x02; //所写内容低位
1653   1          Uart0Send(buf, 6);
1654   1          AUTO_FLAG = YES;
1655   1          cmd_chk_cnt = 0;
1656   1          while(cmd_chk_cnt < CMD_CHK_MAX );
1657   1          if(Receive_command_finished == YES)
1658   1          {
1659   2              Receive_command_finished = NO;
1660   2              ShowTime1 = T0Counter6;
1661   2              if((RxBuf1.buf[6] & 0x01) == 0x01)
1662   2              {
1663   3                  Time_FLAG = YES;
1664   3      
1665   3                  CANTRASTEMINFOR[14] = (unsigned char)((ShowTime1 & 0xFF00) >> 8);
1666   3                  CANTRASTEMINFOR[15] = (unsigned char)(ShowTime1 & 0x00FF);
1667   3                  CANTRASTEMINFOR[12] = CANTRASTEMINFOR[12] & 0XFE; //清除运行标志
1668   3              }
1669   2              if((RxBuf1.buf[6] & 0x02) == 0x02)
1670   2              {
1671   3                  CANTRASTEMINFOR[12] = CANTRASTEMINFOR[12] & 0XFD; //清除运行标志
1672   3              }
1673   2          }
1674   1          AUTO_FLAG = NO;
1675   1      }
1676          void SystemControl(void)//系统控制
1677          {
1678   1          switch(Runmode)
1679   1          {
1680   2          case 0:
1681   2              if(CANcomand == 0)CANcomand = nCANcomand;
1682   2              DC_motorCTRL();  //步进电机控制
1683   2              if(Receive485_command_finished == YES) //防止连续发控制命令
1684   2              {
1685   3                  ServomotorCRTL(CANcomand);//伺服电机控制
1686   3              }
1687   2              break;
1688   2      
C51 COMPILER V9.56.0.0   SUSONGXIAN                                                        04/28/2017 13:56:01 PAGE 30  

1689   2          case 1:
1690   2              if(CANcomand == 0)CANcomand = nCANcomand;
1691   2              /****************************/
1692   2              //检查命令的合法性
1693   2              /****************************/
1694   2              //if((system_crtl.AUTOsystem_command>1)&&(CANcomand!=0))//误操作退出
1695   2              //{
1696   2              //CANTRASTEMINFOR[40]=CANTRASTEMINFOR[40]|0x01;
1697   2              //}
1698   2              //else
1699   2              //{
1700   2              switch(nCANcomand)
1701   2              {
1702   3              case 0XFE:
1703   3                  AUTOnCANcomand = AUTOTaskassignment1(); //输送线动作
1704   3                  AUTORUNMODE1(AUTOnCANcomand);
1705   3                  break;
1706   3              case 0xFD://
1707   3                  AUTOnCANcomand = AUTOTaskassignment2(); //输送线推药品
1708   3                  //system_crtl.AUTOsystem_command=3;    //后退0.5米去掉
1709   3                  AUTORUNMODE2(AUTOnCANcomand);
1710   3                  break;
1711   3              case 0xFB://
1712   3                  AUTOnCANcomand = AUTOTaskassignment3(); //输送线复位
1713   3                  AUTORUNMODE3(AUTOnCANcomand);
1714   3                  break;
1715   3                  //added begin
1716   3                  //
1717   3              case 0xB2://
1718   3                  AUTOnCANcomand = AUTOTaskassignment2(); //start unlimit distance run
1719   3                  AUTORUNMODE2(AUTOnCANcomand);
1720   3                  break;
1721   3      
1722   3              case 0xB3://
1723   3                  AUTOnCANcomand = AUTOTaskassignment2(); //stop unlimit distance run
1724   3                  AUTORUNMODE2(AUTOnCANcomand);
1725   3                  break;
1726   3                  //added end
1727   3              default:
1728   3                  break;
1729   3                  // }
1730   3              }
1731   2              break;
1732   2          default:
1733   2              break;
1734   2          }
1735   1      
1736   1      }
1737          /********************************************************
1738          ////自动运行任务安排
1739          ********************************************************/
1740          unsigned char AUTOTaskassignment1(void)
1741          {
1742   1          unsigned char returnvalue = 0;
1743   1          switch(system_crtl.AUTOsystem_command)//做到每步运行检查判断给出命令
1744   1          {
1745   2          case 1:
1746   2              //检查命令执行可行性
1747   2              if(((CANTRASTEMINFOR[13] & 0X01) == 0x01) && (CANINDEX == 1)) //左翻板下翻&&主控制板运行翻板选择
1748   2              {
1749   3                  returnvalue = 0xF0; //伺服运行最远X值
1750   3                  CANTRASTEMINFOR[12] = CANTRASTEMINFOR[12] | 0X01; //置运行标志
C51 COMPILER V9.56.0.0   SUSONGXIAN                                                        04/28/2017 13:56:01 PAGE 31  

1751   3                  system_crtl.AUTOsystem_command = 2;
1752   3              }
1753   2              if(((CANTRASTEMINFOR[13] & 0X04) == 0x04) && (CANINDEX == 2)) //右翻板下翻&&主控制板运行翻板选择
1754   2              {
1755   3                  returnvalue = 0xF1; //伺服运行运行距离是输送线总长减去最近X轴位置
1756   3                  CANTRASTEMINFOR[12] = CANTRASTEMINFOR[12] | 0X01; //置运行标志
1757   3                  system_crtl.AUTOsystem_command = 2;
1758   3              }
1759   2              break;
1760   2      
1761   2          case 2:
1762   2              //检查命令执行可行性
1763   2              ServomotorINP(1);
1764   2              if(((CANTRASTEMINFOR[12] & 0X01) == 0x00)) //伺服运行结束
1765   2              {
1766   3                  returnvalue = 0xFA; //关伺服
1767   3                  system_crtl.AUTOsystem_command = 3;
1768   3                  //CANcomand=0x00;
1769   3                  //nCANcomand=0;
1770   3                  //nCANDate1=0;
1771   3              }
1772   2              break;
1773   2      
1774   2          case 3:
1775   2              system_crtl.AUTOsystem_command = 0;
1776   2              CANcomand = 0x00;
1777   2              nCANcomand = 0;
1778   2              //nCANDate1=0;
1779   2              //自动运行结束上报信息参数
1780   2              AUTOCMD_STATE = 0XC2;
1781   2              T0Counter8 = 51;
1782   2              AUTOCMD_TIME = 0;
1783   2              break;
1784   2      
1785   2          default:
1786   2              break;
1787   2          }
1788   1          return  returnvalue;
1789   1      
1790   1      }
1791          /********************************************************
1792          ////自动运行任务安排
1793          ********************************************************/
1794          unsigned char AUTOTaskassignment2(void)
1795          {
1796   1          unsigned char returnvalue = 0;
1797   1      
1798   1          switch(system_crtl.AUTOsystem_command)//做到每步运行检查判断给出命令
1799   1          {
1800   2          case 1: //地面输送线向左/右推0.5m
1801   2              switch(CANINDEX)
1802   2              {
1803   3              case 1:
1804   3                  returnvalue = 0xF2; //推0.5米
1805   3                  CANTRASTEMINFOR[12] = CANTRASTEMINFOR[12] | 0X01; //置运行标志
1806   3                  system_crtl.AUTOsystem_command = 2;
1807   3                  break;
1808   3      
1809   3              case 2:
1810   3                  returnvalue = 0xF3; //推0.5米
1811   3                  CANTRASTEMINFOR[12] = CANTRASTEMINFOR[12] | 0X01; //置运行标志
1812   3                  system_crtl.AUTOsystem_command = 2;
C51 COMPILER V9.56.0.0   SUSONGXIAN                                                        04/28/2017 13:56:01 PAGE 32  

1813   3                  break;
1814   3      
1815   3              default:
1816   3                  break;
1817   3              }
1818   2              break;
1819   2      
1820   2          case 2:
1821   2              ServomotorINP(1);
1822   2              if(((CANTRASTEMINFOR[12] & 0X01) == 0x00)) //伺服运行结束
1823   2              {
1824   3                  system_crtl.AUTOsystem_command = 3;
1825   3              }
1826   2              break;
1827   2      
1828   2          case 3:
1829   2              switch(CANINDEX)
1830   2              {
1831   3              case 1:
1832   3                  returnvalue = 0xF4;
1833   3                  system_crtl.AUTOsystem_command = 4;
1834   3                  T0Counter7 = 0; //故障计时清零
1835   3                  //added begin
1836   3                  init_msg_object_TX(2, 2); //向提升机构发送数据
1837   3                  FZSSXLeftFZ( 0x01);
1838   3                  //added end
1839   3                  break;
1840   3      
1841   3              case 2:
1842   3                  returnvalue = 0xF5;
1843   3                  system_crtl.AUTOsystem_command = 4;
1844   3                  T0Counter7 = 0; //故障计时清零
1845   3                  //added begin
1846   3                  init_msg_object_TX(3, 4); //向提升机构发送数据
1847   3                  FZSSXRightFZ( 0x01);
1848   3                  //added end
1849   3                  break;
1850   3      
1851   3              default:
1852   3                  break;
1853   3              }
1854   2              //added begin
1855   2              init_msg_object_TX(TX_MSGNUM_ZKB, (IDSET + 64));  //向主板发送数据
1856   2              //added end
1857   2              break;
1858   2      
1859   2          case 4:
1860   2              if(T0Counter7 >= TIMEVALUE_ALARM1)
1861   2              {
1862   3                  system_crtl.AUTOsystem_alarm1 = 1;
1863   3                  system_crtl.AUTOsystem_command = 11;
1864   3              }
1865   2              if((CANINDEX == 1) && ((CANTRASTEMINFOR[13] & 0x02) == 0x02)) //左传感器触发上翻结束
1866   2              {
1867   3                  system_crtl.AUTOsystem_command = 5;
1868   3              }
1869   2              if((CANINDEX == 2) && ((CANTRASTEMINFOR[13] & 0x08) == 0x08)) //右传感器触发上翻结束
1870   2              {
1871   3                  system_crtl.AUTOsystem_command = 5;
1872   3              }
1873   2              Alarm_cout = 0; //报警次数清零(cas5 运行报警次数，传感器检测）
1874   2              break;
C51 COMPILER V9.56.0.0   SUSONGXIAN                                                        04/28/2017 13:56:01 PAGE 33  

1875   2      
1876   2          case 5: //地面输送线向左/右前进1m
1877   2              switch(CANINDEX)
1878   2              {
1879   3              case 1:
1880   3                  returnvalue = 0xF6; //前进1米
1881   3                  CANTRASTEMINFOR[12] = CANTRASTEMINFOR[12] | 0X01; //置运行标志
1882   3                  system_crtl.AUTOsystem_command = 6;
1883   3                  break;
1884   3      
1885   3              case 2:
1886   3                  returnvalue = 0xF7; //前进1米
1887   3                  CANTRASTEMINFOR[12] = CANTRASTEMINFOR[12] | 0X01; //置运行标志
1888   3                  system_crtl.AUTOsystem_command = 6;
1889   3                  break;
1890   3      
1891   3              default:
1892   3                  break;
1893   3              }
1894   2              break;
1895   2      
1896   2          case 6: //以后加传感器检测传送带上检测药品一直转 直到没有药品为止
1897   2              SAMPCBDataacquisition(1);//暂时添加测试用
1898   2              ServomotorINP(1);
1899   2              if(((CANTRASTEMINFOR[12] & 0X01) == 0x00)) //伺服运行结束
1900   2              {
1901   3                  SAMPLE_FLAG = YES;
1902   3                  //暂时屏蔽
1903   3      //            CANTRASTEMINFOR[8] = 0;
1904   3      //            CANTRASTEMINFOR[9] = 0;
1905   3      //            SAMPCBDataacquisition(1);
1906   3                  SAMPLE_FLAG = NO;
1907   3                  if(CANINDEX == 0x01)
1908   3                  {
1909   4                      if(((CANTRASTEMINFOR[8] & 0x01) == 0x01) && (Alarm_cout < 3))//
1910   4                      {
1911   5                          Alarm_cout = Alarm_cout + 1;
1912   5                          system_crtl.AUTOsystem_command = 5;
1913   5                      }
1914   4                      else
1915   4                      {
1916   5                          returnvalue = 0xFA; //关伺服
1917   5                          system_crtl.AUTOsystem_command = 7;
1918   5                      }
1919   4                      //CANTRASTEMINFOR[8]=0;
1920   4                      //CANTRASTEMINFOR[9]=0;
1921   4                  }
1922   3                  if(CANINDEX == 0x02)
1923   3                  {
1924   4                      if(((CANTRASTEMINFOR[8] & 0x02) == 0x02) && (Alarm_cout < 3))//
1925   4                      {
1926   5                          Alarm_cout = Alarm_cout + 1;
1927   5                          system_crtl.AUTOsystem_command = 5;
1928   5                      }
1929   4                      else
1930   4                      {
1931   5                          returnvalue = 0xFA; //关伺服
1932   5                          system_crtl.AUTOsystem_command = 7;
1933   5                      }
1934   4                      //CANTRASTEMINFOR[8]=0;
1935   4                      //CANTRASTEMINFOR[9]=0;
1936   4                  }
C51 COMPILER V9.56.0.0   SUSONGXIAN                                                        04/28/2017 13:56:01 PAGE 34  

1937   3                  //returnvalue=0xFA;//关伺服
1938   3                  //system_crtl.AUTOsystem_command=7;
1939   3              }
1940   2              break;
1941   2      
1942   2          case 7:
1943   2              switch(CANINDEX)
1944   2              {
1945   3              case 1:
1946   3                  returnvalue = 0xF8; //左翻板下翻
1947   3                  system_crtl.AUTOsystem_command = 8;
1948   3                  T0Counter7 = 0; //故障计时清零
1949   3                  break;
1950   3      
1951   3              case 2:
1952   3                  returnvalue = 0xF9; //右翻板下翻
1953   3                  system_crtl.AUTOsystem_command = 9;
1954   3                  T0Counter7 = 0; //故障计时清零
1955   3                  break;
1956   3      
1957   3              default:
1958   3                  break;
1959   3              }
1960   2              break;
1961   2      
1962   2          case 8:
1963   2              //检查命令执行可行性
1964   2              if(T0Counter7 >= TIMEVALUE_ALARM1)
1965   2              {
1966   3                  system_crtl.AUTOsystem_alarm1 = 1;
1967   3                  system_crtl.AUTOsystem_command = 13;
1968   3              }
1969   2              if((CANTRASTEMINFOR[13] & 0x01) == 0x01) //下翻结束
1970   2              {
1971   3                  system_crtl.AUTOsystem_command = 10;
1972   3              }
1973   2              break;
1974   2      
1975   2          case 9:
1976   2              //检查命令执行可行性
1977   2              if(T0Counter7 >= TIMEVALUE_ALARM1)
1978   2              {
1979   3                  system_crtl.AUTOsystem_alarm1 = 1;
1980   3                  system_crtl.AUTOsystem_command = 13;
1981   3              }
1982   2              if((CANTRASTEMINFOR[13] & 0x04) == 0x04) //下翻结束
1983   2              {
1984   3                  system_crtl.AUTOsystem_command = 10;
1985   3              }
1986   2              break;
1987   2      
1988   2          case 10:
1989   2              //检查命令执行可行性
1990   2              // if((CANTRASTEMINFOR[13]&0x04)==0x04)//上翻结束
1991   2              //{
1992   2              INDEX_COMAND = CANINDEX;
1993   2              system_crtl.AUTOsystem_command = 0;
1994   2              CANcomand = 0x00;
1995   2              nCANcomand = 0;
1996   2              //nCANDate1=0;
1997   2              //自动运行结束上报信息参数
1998   2              AUTOCMD_STATE = 0XC3;
C51 COMPILER V9.56.0.0   SUSONGXIAN                                                        04/28/2017 13:56:01 PAGE 35  

1999   2              T0Counter8 = 51;
2000   2              AUTOCMD_TIME = 0;
2001   2              // }
2002   2              break;
2003   2      
2004   2          case 11:
2005   2              returnvalue = 0xFB; //关闭
2006   2              system_crtl.AUTOsystem_command = 12;
2007   2              break;
2008   2      
2009   2          case 12:
2010   2              INDEX_COMAND = CANINDEX;
2011   2              system_crtl.AUTOsystem_command = 0;
2012   2              CANcomand = 0x00;
2013   2              nCANcomand = 0;
2014   2              //nCANDate1=0;
2015   2              //自动运行结束上报信息参数
2016   2              AUTOCMD_STATE = 0XE0;
2017   2              T0Counter8 = 51;
2018   2              AUTOCMD_TIME = 0;
2019   2              break;
2020   2      
2021   2          case 13:
2022   2              returnvalue = 0xFC; //关闭
2023   2              system_crtl.AUTOsystem_command = 14;
2024   2              break;
2025   2      
2026   2          case 14:
2027   2              INDEX_COMAND = CANINDEX;
2028   2              system_crtl.AUTOsystem_command = 0;
2029   2              CANcomand = 0x00;
2030   2              nCANcomand = 0;
2031   2              //nCANDate1=0;
2032   2              //自动运行结束上报信息参数
2033   2              AUTOCMD_STATE = 0XE1;
2034   2              T0Counter8 = 51;
2035   2              AUTOCMD_TIME = 0;
2036   2              break;
2037   2      
2038   2              //added begin
2039   2          case 20:
2040   2              switch(CANINDEX)
2041   2              {
2042   3              case 1:
2043   3                  returnvalue = 0xFD; //
2044   3                  break;
2045   3      
2046   3              case 2:
2047   3                  returnvalue = 0xFE; //
2048   3                  break;
2049   3      
2050   3              default:
2051   3                  break;
2052   3              }
2053   2              system_crtl.AUTOsystem_command = 0;
2054   2              break;
2055   2      
2056   2          case 21:
2057   2              returnvalue = 0xFF; //
2058   2              system_crtl.AUTOsystem_command = 0;
2059   2              break;
2060   2              //added end
C51 COMPILER V9.56.0.0   SUSONGXIAN                                                        04/28/2017 13:56:01 PAGE 36  

2061   2      
2062   2          default:
2063   2              break;
2064   2          }
2065   1          return  returnvalue;
2066   1      }
2067          /********************************************************
2068          ////自动归零
2069          ********************************************************/
2070          unsigned char AUTOTaskassignment3(void)
2071          {
2072   1          unsigned char returnvalue = 0;
2073   1          switch(system_crtl.AUTOsystem_command)
2074   1          {
2075   2          case 1:
2076   2              returnvalue = 0xE1; //复位左右翻板
2077   2              system_crtl.AUTOsystem_command = 2;
2078   2              T0Counter7 = 0; //故障计时清零
2079   2              break;
2080   2      
2081   2          case 2:
2082   2              if(T0Counter7 >= TIMEVALUE_ALARM1)
2083   2              {
2084   3                  system_crtl.AUTOsystem_alarm1 = 1;
2085   3                  system_crtl.AUTOsystem_command = 3;
2086   3              }
2087   2              //暂时屏蔽了左闸门信号
2088   2      //        if(((CANTRASTEMINFOR[13] & 0x01) == 0x01) && ((CANTRASTEMINFOR[13] & 0x04) == 0x04))
2089   2              if(((CANTRASTEMINFOR[13] & 0x04) == 0x04))
2090   2              {
2091   3                  system_crtl.AUTOsystem_command = 4;
2092   3              }
2093   2              break;
2094   2      
2095   2          case 3:
2096   2              returnvalue = 0xE2; //停止电机
2097   2              system_crtl.AUTOsystem_command = 4;
2098   2              break ;
2099   2      
2100   2          case 4:
2101   2              system_crtl.AUTOsystem_command = 0;
2102   2              // returnvalue=0xE2;//关闭伺服使能
2103   2              CANcomand = 0x00;
2104   2              nCANcomand = 0;
2105   2              //nCANDate1=0;
2106   2              //自动运行结束上报信息参数
2107   2              AUTOCMD_STATE = 0XC4;
2108   2              T0Counter8 = 51;
2109   2              AUTOCMD_TIME = 0;
2110   2              break;
2111   2      
2112   2          default:
2113   2              break;
2114   2          }
2115   1          /*switch(system_crtl.AUTOsystem_command)//做到每步运行检查判断给出命令
2116   1          {
2117   1          case 1:
2118   1          if((CANTRASTEMINFOR[12]&0x01)==0x01)//如果伺服电机在运行执行偏差清除命令
2119   1          {
2120   1          returnvalue=0xE0;//偏差清除
2121   1          system_crtl.AUTOsystem_command=2;
2122   1          }
C51 COMPILER V9.56.0.0   SUSONGXIAN                                                        04/28/2017 13:56:01 PAGE 37  

2123   1          else
2124   1          {
2125   1          system_crtl.AUTOsystem_command=3;
2126   1          }
2127   1          break;
2128   1          case 2:
2129   1          if((CANTRASTEMINFOR[12]&0x01)==0x01)//等待偏差清除命令伺服结束
2130   1          {
2131   1          returnvalue=0xE1;//复位左右翻板
2132   1          system_crtl.AUTOsystem_command=3;
2133   1          }
2134   1          break;
2135   1          case 3:
2136   1          if(((CANTRASTEMINFOR[13]&0x01)==0x01)&&((CANTRASTEMINFOR[13]&0x04)==0x04))//如果左右翻板结束标志建立复
             -位结束
2137   1          {
2138   1          system_crtl.AUTOsystem_command=4;
2139   1          }
2140   1          break;
2141   1          case 4:
2142   1          system_crtl.AUTOsystem_command=0;
2143   1          // returnvalue=0xE2;//关闭伺服使能
2144   1          CANcomand=0x00;
2145   1          nCANcomand=0;
2146   1          //nCANDate1=0;
2147   1          //自动运行结束上报信息参数
2148   1          AUTOCMD_STATE=0XC4;
2149   1          T0Counter8=51;
2150   1          AUTOCMD_TIME=0;
2151   1          break;
2152   1          default:
2153   1          break;
2154   1          }*/
2155   1          return  returnvalue;
2156   1      }
2157          
2158          void CANsetpraback(void)
2159          {
2160   1          unsigned char i;
2161   1          unsigned char sum;
2162   1      
2163   1          switch(AUTOCMD_CHECK)
2164   1          {
2165   2          case 0xFC:
2166   2              CANTXBUF_ZKB.normal_buf.address1 = CANaddress1;
2167   2              CANTXBUF_ZKB.normal_buf.index = CANINDEX;
2168   2              CANTXBUF_ZKB.normal_buf.command = AUTOCMD_CHECK;
2169   2              CANTXBUF_ZKB.normal_buf.data1 = CANTRASTEMINFOR[12]; //伺服状态
2170   2              CANTXBUF_ZKB.normal_buf.data2 = CANTRASTEMINFOR[13]; //传感器状态
2171   2              CANTXBUF_ZKB.normal_buf.data3 = system_crtl.AUTOsystem_command; //模块运行情况
2172   2              CANTXBUF_ZKB.normal_buf.data4 = system_crtl.AUTOsystem_alarm1; //运行状态报警
2173   2              break;
2174   2      
2175   2          default:
2176   2              CANTXBUF_ZKB.normal_buf.address1 = CANaddress1;
2177   2              CANTXBUF_ZKB.normal_buf.index = CANINDEX;
2178   2              CANTXBUF_ZKB.normal_buf.command = CANcomand;
2179   2              CANTXBUF_ZKB.normal_buf.data1 = CANRXBUF_ZKB.buf[3];
2180   2              CANTXBUF_ZKB.normal_buf.data2 = CANRXBUF_ZKB.buf[4];
2181   2              CANTXBUF_ZKB.normal_buf.data3 = CANRXBUF_ZKB.buf[5];
2182   2              CANTXBUF_ZKB.normal_buf.data4 = CANRXBUF_ZKB.buf[6];
2183   2              break;
C51 COMPILER V9.56.0.0   SUSONGXIAN                                                        04/28/2017 13:56:01 PAGE 38  

2184   2          }
2185   1          sum = 0;
2186   1          i = 0;
2187   1          do
2188   1          {
2189   2              sum += CANTXBUF_ZKB.buf[i];
2190   2              i++;
2191   2          } while(i < 7);
2192   1          CANTXBUF_ZKB.normal_buf.checkout = sum;
2193   1          can1_transmit(TX_MSGNUM_ZKB, CANTXBUF_ZKB.buf);
2194   1      }
2195          
2196          /*void ManualCANtransfer(void)
2197          {
2198            unsigned char i;
2199            unsigned char sum;
2200            unsigned char mj;
2201            if(T0Counter3>=30)  //200ms时间定时
2202            {
2203              T0Counter3=0;
2204              for(mj=0;mj<4;mj++)
2205              {
2206                CANTXBUF_ZKB.normal_buf.address1=0X01;
2207                CANTXBUF_ZKB.normal_buf.index=mj;
2208                CANTXBUF_ZKB.normal_buf.command=0XC1;
2209                CANTXBUF_ZKB.normal_buf.data1=CANTRASTEMINFOR[4*mj+0];
2210                CANTXBUF_ZKB.normal_buf.data2=CANTRASTEMINFOR[4*mj+1];
2211                CANTXBUF_ZKB.normal_buf.data3=CANTRASTEMINFOR[4*mj+2];
2212                CANTXBUF_ZKB.normal_buf.data4=CANTRASTEMINFOR[4*mj+3];
2213                sum=0;
2214                i=0;
2215                do
2216                {
2217                  sum+=CANRXBUF_ZKB.buf[i];
2218                  i++;
2219                }while(i<7);
2220                CANTXBUF_ZKB.normal_buf.checkout=sum;
2221                can1_transmit(TX_MSGNUM_ZKB,CANTXBUF_ZKB.buf);
2222              }
2223              LED3=!LED3;
2224            }
2225          }*/
2226          void UnactiveCANtransfer(void)//CAN参数应答上传
2227          {
2228   1          switch(CANcomand)
2229   1          {
2230   2      
2231   2          case 0xA0:
2232   2              CANsetpraback();
2233   2              CANcomand = 0;
2234   2              nCANcomand = 0;
2235   2              CANINFOR_FLAG = NO;
2236   2              break;
2237   2          case 0xA1:
2238   2              CANsetpraback();
2239   2              CANcomand = 0;
2240   2              nCANcomand = 0;
2241   2              CANINFOR_FLAG = NO;
2242   2              break;
2243   2      
2244   2          case 0xA4:
2245   2              CANsetpraback();
C51 COMPILER V9.56.0.0   SUSONGXIAN                                                        04/28/2017 13:56:01 PAGE 39  

2246   2              CANcomand = 0;
2247   2              nCANcomand = 0;
2248   2              CANINFOR_FLAG = NO;
2249   2              break;
2250   2          case 0xA5:
2251   2              CANsetpraback();
2252   2              CANcomand = 0;
2253   2              nCANcomand = 0;
2254   2              CANINFOR_FLAG = NO;
2255   2              break;
2256   2          case 0xA6:
2257   2              CANsetpraback();
2258   2              CANcomand = 0;
2259   2              nCANcomand = 0;
2260   2              CANINFOR_FLAG = NO;
2261   2              break;
2262   2          case 0xA7:
2263   2              CANsetpraback();
2264   2              CANcomand = 0;
2265   2              nCANcomand = 0;
2266   2              CANINFOR_FLAG = NO;
2267   2              break;
2268   2          case 0xA8:
2269   2              CANsetpraback();
2270   2              CANcomand = 0;
2271   2              nCANcomand = 0;
2272   2              CANINFOR_FLAG = NO;
2273   2              break;
2274   2          case 0xA9:
2275   2              CANsetpraback();
2276   2              CANcomand = 0;
2277   2              nCANcomand = 0;
2278   2              CANINFOR_FLAG = NO;
2279   2              break;
2280   2          case 0xAA:
2281   2              CANsetpraback();
2282   2              CANcomand = 0;
2283   2              nCANcomand = 0;
2284   2              CANINFOR_FLAG = NO;
2285   2              break;
2286   2          case 0xAB:
2287   2              CANsetpraback();
2288   2              CANcomand = 0;
2289   2              nCANcomand = 0;
2290   2              CANINFOR_FLAG = NO;
2291   2              break;
2292   2          case 0xAC:
2293   2              CANsetpraback();
2294   2              CANcomand = 0;
2295   2              nCANcomand = 0;
2296   2              CANINFOR_FLAG = NO;
2297   2              break;
2298   2          case 0xC0://读取所有工位信息
2299   2              TRANFORSATATIONINFOR();
2300   2              CANcomand = 0;
2301   2              nCANcomand = 0;
2302   2              break;
2303   2      
2304   2          default:
2305   2              break;
2306   2          }
2307   1          switch(AUTOCMD_CHECK)
C51 COMPILER V9.56.0.0   SUSONGXIAN                                                        04/28/2017 13:56:01 PAGE 40  

2308   1          {
2309   2          case 0xFC://自动模式查询报警状态
2310   2              if(repair_flag != 0x00) //维修查询不上报
2311   2              {
2312   3                  CANsetpraback();
2313   3              }
2314   2              AUTOCMD_CHECK = 0;
2315   2              //CANcomand=0;
2316   2              //nCANcomand=0;
2317   2              CANINFOR_FLAG = NO;
2318   2              break;
2319   2          default:
2320   2              break;
2321   2          }
2322   1      }
2323          void ActiveCANtransfer(void)//CAN参数主动上传
2324          {
2325   1          unsigned char i = 0;
2326   1          unsigned char sum = 0;
2327   1          if(repair_flag == 0x00) return;
2328   1          if(T0Counter8 > 50)
2329   1          {
2330   2              T0Counter8 = 0;
2331   2              if(AUTOCMD_STATE != 0)
2332   2              {
2333   3                  CANTXBUF_ZKB.normal_buf.address1 = CANaddress1;
2334   3                  if(AUTOCMD_STATE == 0xc3)
2335   3                  {
2336   4                      CANTXBUF_ZKB.normal_buf.index = INDEX_COMAND;
2337   4                  }
2338   3                  else
2339   3                  {
2340   4                      CANTXBUF_ZKB.normal_buf.index = CANINDEX;
2341   4                  }
2342   3                  CANTXBUF_ZKB.normal_buf.command = AUTOCMD_STATE;
2343   3                  //CANTXBUF_ZKB.normal_buf.data1=CANTRASTEMINFOR[12];//伺服状态
2344   3                  CANTXBUF_ZKB.normal_buf.data1 = CANTRASTEMINFOR[8];
2345   3                  CANTXBUF_ZKB.normal_buf.data2 = CANTRASTEMINFOR[13]; //传感器状态
2346   3                  CANTXBUF_ZKB.normal_buf.data3 = system_crtl.AUTOsystem_command; //模块运行情况
2347   3                  CANTXBUF_ZKB.normal_buf.data4 = system_crtl.AUTOsystem_alarm1; //运行状态报警
2348   3                  sum = 0;
2349   3                  i = 0;
2350   3                  do
2351   3                  {
2352   4                      sum += CANTXBUF_ZKB.buf[i];
2353   4                      i++;
2354   4                  } while(i < 7);
2355   3                  CANTXBUF_ZKB.normal_buf.checkout = sum;
2356   3                  can1_transmit(TX_MSGNUM_ZKB, CANTXBUF_ZKB.buf);
2357   3                  AUTOCMD_TIME = AUTOCMD_TIME + 1;
2358   3                  //if(AUTOCMD_TIME>=3)
2359   3                  //{
2360   3                  AUTOCMD_STATE = 0;
2361   3                  AUTOCMD_TIME = 0;
2362   3                  AUTOCMD_TIME = 0;
2363   3                  //}
2364   3              }
2365   2              /*if((AUTOCMD_STATE==0Xc2)||(AUTOCMD_STATE==0Xc3)||(AUTOCMD_STATE==0Xc4)) {AUTOCMD_TIME=AUTOCMD_TI
             -ME+1; if(AUTOCMD_TIME>=4){AUTOCMD_STATE=0;AUTOCMD_TIME=0;}}else{AUTOCMD_TIME=0;}
2366   2              switch(AUTOCMD_STATE)
2367   2              {
2368   2              case 0XC2://上报传感器状态和伺服状态
C51 COMPILER V9.56.0.0   SUSONGXIAN                                                        04/28/2017 13:56:01 PAGE 41  

2369   2              CANTXBUF_ZKB.normal_buf.address1=CANaddress1;
2370   2              CANTXBUF_ZKB.normal_buf.index=CANINDEX;
2371   2              CANTXBUF_ZKB.normal_buf.command=0XC2;
2372   2              CANTXBUF_ZKB.normal_buf.data1=CANTRASTEMINFOR[12];//伺服状态
2373   2              CANTXBUF_ZKB.normal_buf.data2=CANTRASTEMINFOR[13];//传感器状态
2374   2              CANTXBUF_ZKB.normal_buf.data3=0X00;
2375   2              CANTXBUF_ZKB.normal_buf.data4=0X00;;
2376   2              sum=0;
2377   2              i=0;
2378   2              do
2379   2              {
2380   2              sum+=CANRXBUF_ZKB.buf[i];
2381   2              i++;
2382   2              }while(i<7);
2383   2              CANTXBUF_ZKB.normal_buf.checkout=sum;
2384   2              can1_transmit(TX_MSGNUM_ZKB,CANTXBUF_ZKB.buf);
2385   2              break;
2386   2              case 0XC3://上报传感器状态和伺服状态
2387   2              CANTXBUF_ZKB.normal_buf.address1=CANaddress1;
2388   2              CANTXBUF_ZKB.normal_buf.index=CANINDEX;
2389   2              CANTXBUF_ZKB.normal_buf.command=0XC3;
2390   2              CANTXBUF_ZKB.normal_buf.data1=CANTRASTEMINFOR[12];//伺服状态
2391   2              CANTXBUF_ZKB.normal_buf.data2=CANTRASTEMINFOR[13];//传感器状态
2392   2              CANTXBUF_ZKB.normal_buf.data3=0X00;
2393   2              CANTXBUF_ZKB.normal_buf.data4=0X00;;
2394   2              sum=0;
2395   2              i=0;
2396   2              do
2397   2              {
2398   2              sum+=CANRXBUF_ZKB.buf[i];
2399   2              i++;
2400   2              }while(i<7);
2401   2              CANTXBUF_ZKB.normal_buf.checkout=sum;
2402   2              can1_transmit(TX_MSGNUM_ZKB,CANTXBUF_ZKB.buf);
2403   2              break;
2404   2              default:
2405   2              break;
2406   2              }*/
2407   2          }
2408   1      }
2409          void TRANFORSATATIONINFOR(void)//读取所有工位信息
2410          {
2411   1          unsigned char i;
2412   1          unsigned char sum;
2413   1      
2414   1          CANTXBUF_ZKB.normal_buf.address1 = CANaddress1;
2415   1          CANTXBUF_ZKB.normal_buf.index = 0;
2416   1          CANTXBUF_ZKB.normal_buf.command = CANcomand;
2417   1          CANTXBUF_ZKB.normal_buf.data1 = Servopara[0];
2418   1          CANTXBUF_ZKB.normal_buf.data2 = Servopara[1];
2419   1          CANTXBUF_ZKB.normal_buf.data3 = Servopara[2];
2420   1          CANTXBUF_ZKB.normal_buf.data4 = Servopara[3];
2421   1          sum = 0;
2422   1          i = 0;
2423   1          do
2424   1          {
2425   2              sum += CANRXBUF_ZKB.buf[i];
2426   2              i++;
2427   2          } while(i < 7);
2428   1          CANTXBUF_ZKB.normal_buf.checkout = sum;
2429   1          can1_transmit(TX_MSGNUM_ZKB, CANTXBUF_ZKB.buf);
2430   1      
C51 COMPILER V9.56.0.0   SUSONGXIAN                                                        04/28/2017 13:56:01 PAGE 42  

2431   1          CANTXBUF_ZKB.normal_buf.address1 = CANaddress1;
2432   1          CANTXBUF_ZKB.normal_buf.index = 1;
2433   1          CANTXBUF_ZKB.normal_buf.command = CANcomand;
2434   1          CANTXBUF_ZKB.normal_buf.data1 = Servopara[4];
2435   1          CANTXBUF_ZKB.normal_buf.data2 = Servopara[5];
2436   1          CANTXBUF_ZKB.normal_buf.data3 = Servopara[6];
2437   1          CANTXBUF_ZKB.normal_buf.data4 = Servopara[7];
2438   1          sum = 0;
2439   1          i = 0;
2440   1          do
2441   1          {
2442   2              sum += CANRXBUF_ZKB.buf[i];
2443   2              i++;
2444   2          } while(i < 7);
2445   1          CANTXBUF_ZKB.normal_buf.checkout = sum;
2446   1          can1_transmit(TX_MSGNUM_ZKB, CANTXBUF_ZKB.buf);
2447   1          CANTXBUF_ZKB.normal_buf.address1 = CANaddress1;
2448   1          CANTXBUF_ZKB.normal_buf.index = 2;
2449   1          CANTXBUF_ZKB.normal_buf.command = CANcomand;
2450   1          CANTXBUF_ZKB.normal_buf.data1 = Servopara[8];
2451   1          CANTXBUF_ZKB.normal_buf.data2 = Servopara[9];
2452   1          CANTXBUF_ZKB.normal_buf.data3 = Servopara[10];
2453   1          CANTXBUF_ZKB.normal_buf.data4 = Servopara[11];
2454   1          sum = 0;
2455   1          i = 0;
2456   1          do
2457   1          {
2458   2              sum += CANRXBUF_ZKB.buf[i];
2459   2              i++;
2460   2          } while(i < 7);
2461   1          CANTXBUF_ZKB.normal_buf.checkout = sum;
2462   1          can1_transmit(TX_MSGNUM_ZKB, CANTXBUF_ZKB.buf);
2463   1          CANTXBUF_ZKB.normal_buf.address1 = CANaddress1;
2464   1          CANTXBUF_ZKB.normal_buf.index = 3;
2465   1          CANTXBUF_ZKB.normal_buf.command = CANcomand;
2466   1          CANTXBUF_ZKB.normal_buf.data1 = Servopara[12];
2467   1          CANTXBUF_ZKB.normal_buf.data2 = Servopara[13];
2468   1          CANTXBUF_ZKB.normal_buf.data3 = Servopara[14];
2469   1          CANTXBUF_ZKB.normal_buf.data4 = Servopara[15];
2470   1          sum = 0;
2471   1          i = 0;
2472   1          do
2473   1          {
2474   2              sum += CANRXBUF_ZKB.buf[i];
2475   2              i++;
2476   2          } while(i < 7);
2477   1          CANTXBUF_ZKB.normal_buf.checkout = sum;
2478   1          can1_transmit(TX_MSGNUM_ZKB, CANTXBUF_ZKB.buf);
2479   1      
2480   1      
2481   1      
2482   1      
2483   1      
2484   1          CANTXBUF_ZKB.normal_buf.address1 = CANaddress1;
2485   1          CANTXBUF_ZKB.normal_buf.index = 4;
2486   1          CANTXBUF_ZKB.normal_buf.command = CANcomand;
2487   1          CANTXBUF_ZKB.normal_buf.data1 = Servopara[16];
2488   1          CANTXBUF_ZKB.normal_buf.data2 = Servopara[17];
2489   1          CANTXBUF_ZKB.normal_buf.data3 = Servopara[18];
2490   1          CANTXBUF_ZKB.normal_buf.data4 = Servopara[19];
2491   1          sum = 0;
2492   1          i = 0;
C51 COMPILER V9.56.0.0   SUSONGXIAN                                                        04/28/2017 13:56:01 PAGE 43  

2493   1          do
2494   1          {
2495   2              sum += CANRXBUF_ZKB.buf[i];
2496   2              i++;
2497   2          } while(i < 7);
2498   1          CANTXBUF_ZKB.normal_buf.checkout = sum;
2499   1          can1_transmit(TX_MSGNUM_ZKB, CANTXBUF_ZKB.buf);
2500   1      
2501   1          CANTXBUF_ZKB.normal_buf.address1 = CANaddress1;
2502   1          CANTXBUF_ZKB.normal_buf.index = 5;
2503   1          CANTXBUF_ZKB.normal_buf.command = CANcomand;
2504   1          CANTXBUF_ZKB.normal_buf.data1 = Servopara[20];
2505   1          CANTXBUF_ZKB.normal_buf.data2 = Servopara[21];
2506   1          CANTXBUF_ZKB.normal_buf.data3 = Servopara[22];
2507   1          CANTXBUF_ZKB.normal_buf.data4 = Servopara[23];
2508   1          sum = 0;
2509   1          i = 0;
2510   1          do
2511   1          {
2512   2              sum += CANRXBUF_ZKB.buf[i];
2513   2              i++;
2514   2          } while(i < 7);
2515   1          CANTXBUF_ZKB.normal_buf.checkout = sum;
2516   1          can1_transmit(TX_MSGNUM_ZKB, CANTXBUF_ZKB.buf);
2517   1          CANTXBUF_ZKB.normal_buf.address1 = CANaddress1;
2518   1          CANTXBUF_ZKB.normal_buf.index = 6;
2519   1          CANTXBUF_ZKB.normal_buf.command = CANcomand;
2520   1          CANTXBUF_ZKB.normal_buf.data1 = Servopara[24];
2521   1          CANTXBUF_ZKB.normal_buf.data2 = Servopara[25];
2522   1          CANTXBUF_ZKB.normal_buf.data3 = Servopara[26];
2523   1          CANTXBUF_ZKB.normal_buf.data4 = Servopara[27];
2524   1          sum = 0;
2525   1          i = 0;
2526   1          do
2527   1          {
2528   2              sum += CANRXBUF_ZKB.buf[i];
2529   2              i++;
2530   2          } while(i < 7);
2531   1          CANTXBUF_ZKB.normal_buf.checkout = sum;
2532   1          can1_transmit(TX_MSGNUM_ZKB, CANTXBUF_ZKB.buf);
2533   1          CANTXBUF_ZKB.normal_buf.address1 = CANaddress1;
2534   1          CANTXBUF_ZKB.normal_buf.index = 7;
2535   1          CANTXBUF_ZKB.normal_buf.command = CANcomand;
2536   1          CANTXBUF_ZKB.normal_buf.data1 = Servopara[28];
2537   1          CANTXBUF_ZKB.normal_buf.data2 = Servopara[29];
2538   1          CANTXBUF_ZKB.normal_buf.data3 = Servopara[30];
2539   1          CANTXBUF_ZKB.normal_buf.data4 = Servopara[31];
2540   1          sum = 0;
2541   1          i = 0;
2542   1          do
2543   1          {
2544   2              sum += CANRXBUF_ZKB.buf[i];
2545   2              i++;
2546   2          } while(i < 7);
2547   1          CANTXBUF_ZKB.normal_buf.checkout = sum;
2548   1          can1_transmit(TX_MSGNUM_ZKB, CANTXBUF_ZKB.buf);
2549   1      
2550   1      
2551   1      
2552   1          CANTXBUF_ZKB.normal_buf.address1 = CANaddress1;
2553   1          CANTXBUF_ZKB.normal_buf.index = 8;
2554   1          CANTXBUF_ZKB.normal_buf.command = CANcomand;
C51 COMPILER V9.56.0.0   SUSONGXIAN                                                        04/28/2017 13:56:01 PAGE 44  

2555   1          CANTXBUF_ZKB.normal_buf.data1 = Servopara[32];
2556   1          CANTXBUF_ZKB.normal_buf.data2 = Servopara[33];
2557   1          CANTXBUF_ZKB.normal_buf.data3 = Servopara[34];
2558   1          CANTXBUF_ZKB.normal_buf.data4 = Servopara[35];
2559   1          sum = 0;
2560   1          i = 0;
2561   1          do
2562   1          {
2563   2              sum += CANRXBUF_ZKB.buf[i];
2564   2              i++;
2565   2          } while(i < 7);
2566   1          CANTXBUF_ZKB.normal_buf.checkout = sum;
2567   1          can1_transmit(TX_MSGNUM_ZKB, CANTXBUF_ZKB.buf);
2568   1      
2569   1          CANTXBUF_ZKB.normal_buf.address1 = CANaddress1;
2570   1          CANTXBUF_ZKB.normal_buf.index = 9;
2571   1          CANTXBUF_ZKB.normal_buf.command = CANcomand;
2572   1          CANTXBUF_ZKB.normal_buf.data1 = Servopara[36];
2573   1          CANTXBUF_ZKB.normal_buf.data2 = Servopara[37];
2574   1          CANTXBUF_ZKB.normal_buf.data3 = Servopara[38];
2575   1          CANTXBUF_ZKB.normal_buf.data4 = Servopara[39];
2576   1          sum = 0;
2577   1          i = 0;
2578   1          do
2579   1          {
2580   2              sum += CANRXBUF_ZKB.buf[i];
2581   2              i++;
2582   2          } while(i < 7);
2583   1          CANTXBUF_ZKB.normal_buf.checkout = sum;
2584   1          can1_transmit(TX_MSGNUM_ZKB, CANTXBUF_ZKB.buf);
2585   1          CANTXBUF_ZKB.normal_buf.address1 = CANaddress1;
2586   1          CANTXBUF_ZKB.normal_buf.index = 10;
2587   1          CANTXBUF_ZKB.normal_buf.command = CANcomand;
2588   1          CANTXBUF_ZKB.normal_buf.data1 = Servopara[40];
2589   1          CANTXBUF_ZKB.normal_buf.data2 = Servopara[41];
2590   1          CANTXBUF_ZKB.normal_buf.data3 = Servopara[42];
2591   1          CANTXBUF_ZKB.normal_buf.data4 = Servopara[43];
2592   1          sum = 0;
2593   1          i = 0;
2594   1          do
2595   1          {
2596   2              sum += CANRXBUF_ZKB.buf[i];
2597   2              i++;
2598   2          } while(i < 7);
2599   1          CANTXBUF_ZKB.normal_buf.checkout = sum;
2600   1          can1_transmit(TX_MSGNUM_ZKB, CANTXBUF_ZKB.buf);
2601   1          CANTXBUF_ZKB.normal_buf.address1 = CANaddress1;
2602   1          CANTXBUF_ZKB.normal_buf.index = 11;
2603   1          CANTXBUF_ZKB.normal_buf.command = CANcomand;
2604   1          CANTXBUF_ZKB.normal_buf.data1 = Servopara[44];
2605   1          CANTXBUF_ZKB.normal_buf.data2 = Servopara[45];
2606   1          CANTXBUF_ZKB.normal_buf.data3 = Servopara[46];
2607   1          CANTXBUF_ZKB.normal_buf.data4 = Servopara[47];
2608   1          sum = 0;
2609   1          i = 0;
2610   1          do
2611   1          {
2612   2              sum += CANRXBUF_ZKB.buf[i];
2613   2              i++;
2614   2          } while(i < 7);
2615   1          CANTXBUF_ZKB.normal_buf.checkout = sum;
2616   1          can1_transmit(TX_MSGNUM_ZKB, CANTXBUF_ZKB.buf);
C51 COMPILER V9.56.0.0   SUSONGXIAN                                                        04/28/2017 13:56:01 PAGE 45  

2617   1      
2618   1          CANTXBUF_ZKB.normal_buf.address1 = CANaddress1;
2619   1          CANTXBUF_ZKB.normal_buf.index = 12;
2620   1          CANTXBUF_ZKB.normal_buf.command = CANcomand;
2621   1          CANTXBUF_ZKB.normal_buf.data1 = Servopara[48];
2622   1          CANTXBUF_ZKB.normal_buf.data2 = Servopara[49];
2623   1          CANTXBUF_ZKB.normal_buf.data3 = Servopara[50];
2624   1          CANTXBUF_ZKB.normal_buf.data4 = Servopara[51];
2625   1          sum = 0;
2626   1          i = 0;
2627   1          do
2628   1          {
2629   2              sum += CANRXBUF_ZKB.buf[i];
2630   2              i++;
2631   2          } while(i < 7);
2632   1          CANTXBUF_ZKB.normal_buf.checkout = sum;
2633   1          can1_transmit(TX_MSGNUM_ZKB, CANTXBUF_ZKB.buf);
2634   1      
2635   1          CANTXBUF_ZKB.normal_buf.address1 = CANaddress1;
2636   1          CANTXBUF_ZKB.normal_buf.index = 13;
2637   1          CANTXBUF_ZKB.normal_buf.command = CANcomand;
2638   1          CANTXBUF_ZKB.normal_buf.data1 = Servopara[52];
2639   1          CANTXBUF_ZKB.normal_buf.data2 = Servopara[53];
2640   1          CANTXBUF_ZKB.normal_buf.data3 = Servopara[54];
2641   1          CANTXBUF_ZKB.normal_buf.data4 = Servopara[55];
2642   1          sum = 0;
2643   1          i = 0;
2644   1          do
2645   1          {
2646   2              sum += CANRXBUF_ZKB.buf[i];
2647   2              i++;
2648   2          } while(i < 7);
2649   1          CANTXBUF_ZKB.normal_buf.checkout = sum;
2650   1          can1_transmit(TX_MSGNUM_ZKB, CANTXBUF_ZKB.buf);
2651   1          CANTXBUF_ZKB.normal_buf.address1 = CANaddress1;
2652   1          CANTXBUF_ZKB.normal_buf.index = 14;
2653   1          CANTXBUF_ZKB.normal_buf.command = CANcomand;
2654   1          CANTXBUF_ZKB.normal_buf.data1 = Servopara[56];
2655   1          CANTXBUF_ZKB.normal_buf.data2 = Servopara[57];
2656   1          CANTXBUF_ZKB.normal_buf.data3 = Servopara[58];
2657   1          CANTXBUF_ZKB.normal_buf.data4 = Servopara[59];
2658   1          sum = 0;
2659   1          i = 0;
2660   1          do
2661   1          {
2662   2              sum += CANRXBUF_ZKB.buf[i];
2663   2              i++;
2664   2          } while(i < 7);
2665   1          CANTXBUF_ZKB.normal_buf.checkout = sum;
2666   1          can1_transmit(TX_MSGNUM_ZKB, CANTXBUF_ZKB.buf);
2667   1          CANTXBUF_ZKB.normal_buf.address1 = CANaddress1;
2668   1          CANTXBUF_ZKB.normal_buf.index = 15;
2669   1          CANTXBUF_ZKB.normal_buf.command = CANcomand;
2670   1          CANTXBUF_ZKB.normal_buf.data1 = Servopara[60];
2671   1          CANTXBUF_ZKB.normal_buf.data2 = Servopara[61];
2672   1          CANTXBUF_ZKB.normal_buf.data3 = Servopara[62];
2673   1          CANTXBUF_ZKB.normal_buf.data4 = Servopara[63];
2674   1          sum = 0;
2675   1          i = 0;
2676   1          do
2677   1          {
2678   2              sum += CANRXBUF_ZKB.buf[i];
C51 COMPILER V9.56.0.0   SUSONGXIAN                                                        04/28/2017 13:56:01 PAGE 46  

2679   2              i++;
2680   2          } while(i < 7);
2681   1          CANTXBUF_ZKB.normal_buf.checkout = sum;
2682   1          can1_transmit(TX_MSGNUM_ZKB, CANTXBUF_ZKB.buf);
2683   1      
2684   1          CANTXBUF_ZKB.normal_buf.address1 = CANaddress1;
2685   1          CANTXBUF_ZKB.normal_buf.index = 16;
2686   1          CANTXBUF_ZKB.normal_buf.command = CANcomand;
2687   1          CANTXBUF_ZKB.normal_buf.data1 = Servopara[64];
2688   1          CANTXBUF_ZKB.normal_buf.data2 = Servopara[65];
2689   1          CANTXBUF_ZKB.normal_buf.data3 = Servopara[66];
2690   1          CANTXBUF_ZKB.normal_buf.data4 = Servopara[67];
2691   1          sum = 0;
2692   1          i = 0;
2693   1          do
2694   1          {
2695   2              sum += CANRXBUF_ZKB.buf[i];
2696   2              i++;
2697   2          } while(i < 7);
2698   1          CANTXBUF_ZKB.normal_buf.checkout = sum;
2699   1          can1_transmit(TX_MSGNUM_ZKB, CANTXBUF_ZKB.buf);
2700   1      
2701   1          CANTXBUF_ZKB.normal_buf.address1 = CANaddress1;
2702   1          CANTXBUF_ZKB.normal_buf.index = 17;
2703   1          CANTXBUF_ZKB.normal_buf.command = CANcomand;
2704   1          CANTXBUF_ZKB.normal_buf.data1 = Servopara[68];
2705   1          CANTXBUF_ZKB.normal_buf.data2 = Servopara[69];
2706   1          CANTXBUF_ZKB.normal_buf.data3 = Servopara[70];
2707   1          CANTXBUF_ZKB.normal_buf.data4 = Servopara[71];
2708   1          sum = 0;
2709   1          i = 0;
2710   1          do
2711   1          {
2712   2              sum += CANRXBUF_ZKB.buf[i];
2713   2              i++;
2714   2          } while(i < 7);
2715   1          CANTXBUF_ZKB.normal_buf.checkout = sum;
2716   1          can1_transmit(TX_MSGNUM_ZKB, CANTXBUF_ZKB.buf);
2717   1          CANTXBUF_ZKB.normal_buf.address1 = CANaddress1;
2718   1          CANTXBUF_ZKB.normal_buf.index = 18;
2719   1          CANTXBUF_ZKB.normal_buf.command = CANcomand;
2720   1          CANTXBUF_ZKB.normal_buf.data1 = Servopara[72];
2721   1          CANTXBUF_ZKB.normal_buf.data2 = Servopara[73];
2722   1          CANTXBUF_ZKB.normal_buf.data3 = Servopara[74];
2723   1          CANTXBUF_ZKB.normal_buf.data4 = Servopara[75];
2724   1          sum = 0;
2725   1          i = 0;
2726   1          do
2727   1          {
2728   2              sum += CANRXBUF_ZKB.buf[i];
2729   2              i++;
2730   2          } while(i < 7);
2731   1          CANTXBUF_ZKB.normal_buf.checkout = sum;
2732   1          can1_transmit(TX_MSGNUM_ZKB, CANTXBUF_ZKB.buf);
2733   1          CANTXBUF_ZKB.normal_buf.address1 = CANaddress1;
2734   1          CANTXBUF_ZKB.normal_buf.index = 19;
2735   1          CANTXBUF_ZKB.normal_buf.command = CANcomand;
2736   1          CANTXBUF_ZKB.normal_buf.data1 = Servopara[76];
2737   1          CANTXBUF_ZKB.normal_buf.data2 = Servopara[77];
2738   1          CANTXBUF_ZKB.normal_buf.data3 = Servopara[78];
2739   1          CANTXBUF_ZKB.normal_buf.data4 = Servopara[79];
2740   1          sum = 0;
C51 COMPILER V9.56.0.0   SUSONGXIAN                                                        04/28/2017 13:56:01 PAGE 47  

2741   1          i = 0;
2742   1          do
2743   1          {
2744   2              sum += CANRXBUF_ZKB.buf[i];
2745   2              i++;
2746   2          } while(i < 7);
2747   1          CANTXBUF_ZKB.normal_buf.checkout = sum;
2748   1          can1_transmit(TX_MSGNUM_ZKB, CANTXBUF_ZKB.buf);
2749   1      
2750   1          CANTXBUF_ZKB.normal_buf.address1 = CANaddress1;
2751   1          CANTXBUF_ZKB.normal_buf.index = 20;
2752   1          CANTXBUF_ZKB.normal_buf.command = CANcomand;
2753   1          CANTXBUF_ZKB.normal_buf.data1 = Servopara[80];
2754   1          CANTXBUF_ZKB.normal_buf.data2 = Servopara[81];
2755   1          CANTXBUF_ZKB.normal_buf.data3 = Servopara[82];
2756   1          CANTXBUF_ZKB.normal_buf.data4 = Servopara[83];
2757   1          sum = 0;
2758   1          i = 0;
2759   1          do
2760   1          {
2761   2              sum += CANRXBUF_ZKB.buf[i];
2762   2              i++;
2763   2          } while(i < 7);
2764   1          CANTXBUF_ZKB.normal_buf.checkout = sum;
2765   1          can1_transmit(TX_MSGNUM_ZKB, CANTXBUF_ZKB.buf);
2766   1      
2767   1          CANTXBUF_ZKB.normal_buf.address1 = CANaddress1;
2768   1          CANTXBUF_ZKB.normal_buf.index = 21;
2769   1          CANTXBUF_ZKB.normal_buf.command = CANcomand;
2770   1          CANTXBUF_ZKB.normal_buf.data1 = Servopara[84];
2771   1          CANTXBUF_ZKB.normal_buf.data2 = Servopara[85];
2772   1          CANTXBUF_ZKB.normal_buf.data3 = Servopara[86];
2773   1          CANTXBUF_ZKB.normal_buf.data4 = Servopara[87];
2774   1          sum = 0;
2775   1          i = 0;
2776   1          do
2777   1          {
2778   2              sum += CANRXBUF_ZKB.buf[i];
2779   2              i++;
2780   2          } while(i < 7);
2781   1          CANTXBUF_ZKB.normal_buf.checkout = sum;
2782   1          can1_transmit(TX_MSGNUM_ZKB, CANTXBUF_ZKB.buf);
2783   1      
2784   1          CANTXBUF_ZKB.normal_buf.address1 = CANaddress1;
2785   1          CANTXBUF_ZKB.normal_buf.index = 22;
2786   1          CANTXBUF_ZKB.normal_buf.command = CANcomand;
2787   1          CANTXBUF_ZKB.normal_buf.data1 = Servopara[88];
2788   1          CANTXBUF_ZKB.normal_buf.data2 = Servopara[89];
2789   1          CANTXBUF_ZKB.normal_buf.data3 = Servopara[90];
2790   1          CANTXBUF_ZKB.normal_buf.data4 = Servopara[91];
2791   1          sum = 0;
2792   1          i = 0;
2793   1          do
2794   1          {
2795   2              sum += CANRXBUF_ZKB.buf[i];
2796   2              i++;
2797   2          } while(i < 7);
2798   1          CANTXBUF_ZKB.normal_buf.checkout = sum;
2799   1          can1_transmit(TX_MSGNUM_ZKB, CANTXBUF_ZKB.buf);
2800   1          CANTXBUF_ZKB.normal_buf.address1 = CANaddress1;
2801   1          CANTXBUF_ZKB.normal_buf.index = 23;
2802   1          CANTXBUF_ZKB.normal_buf.command = CANcomand;
C51 COMPILER V9.56.0.0   SUSONGXIAN                                                        04/28/2017 13:56:01 PAGE 48  

2803   1          CANTXBUF_ZKB.normal_buf.data1 = Servopara[92];
2804   1          CANTXBUF_ZKB.normal_buf.data2 = Servopara[93];
2805   1          CANTXBUF_ZKB.normal_buf.data3 = Servopara[94];
2806   1          CANTXBUF_ZKB.normal_buf.data4 = Servopara[95];
2807   1          sum = 0;
2808   1          i = 0;
2809   1          do
2810   1          {
2811   2              sum += CANRXBUF_ZKB.buf[i];
2812   2              i++;
2813   2          } while(i < 7);
2814   1          CANTXBUF_ZKB.normal_buf.checkout = sum;
2815   1          can1_transmit(TX_MSGNUM_ZKB, CANTXBUF_ZKB.buf);
2816   1          CANTXBUF_ZKB.normal_buf.address1 = CANaddress1;
2817   1          CANTXBUF_ZKB.normal_buf.index = 24;
2818   1          CANTXBUF_ZKB.normal_buf.command = CANcomand;
2819   1          CANTXBUF_ZKB.normal_buf.data1 = Servopara[96];
2820   1          CANTXBUF_ZKB.normal_buf.data2 = Servopara[97];
2821   1          CANTXBUF_ZKB.normal_buf.data3 = Servopara[98];
2822   1          CANTXBUF_ZKB.normal_buf.data4 = Servopara[99];
2823   1          sum = 0;
2824   1          i = 0;
2825   1          do
2826   1          {
2827   2              sum += CANRXBUF_ZKB.buf[i];
2828   2              i++;
2829   2          } while(i < 7);
2830   1          CANTXBUF_ZKB.normal_buf.checkout = sum;
2831   1          can1_transmit(TX_MSGNUM_ZKB, CANTXBUF_ZKB.buf);
2832   1          CANTXBUF_ZKB.normal_buf.address1 = CANaddress1;
2833   1          CANTXBUF_ZKB.normal_buf.index = 25;
2834   1          CANTXBUF_ZKB.normal_buf.command = CANcomand;
2835   1          CANTXBUF_ZKB.normal_buf.data1 = Servopara[100];
2836   1          CANTXBUF_ZKB.normal_buf.data2 = Servopara[101];
2837   1          CANTXBUF_ZKB.normal_buf.data3 = Servopara[102];
2838   1          CANTXBUF_ZKB.normal_buf.data4 = Servopara[103];
2839   1          sum = 0;
2840   1          i = 0;
2841   1          do
2842   1          {
2843   2              sum += CANRXBUF_ZKB.buf[i];
2844   2              i++;
2845   2          } while(i < 7);
2846   1          CANTXBUF_ZKB.normal_buf.checkout = sum;
2847   1          can1_transmit(TX_MSGNUM_ZKB, CANTXBUF_ZKB.buf);
2848   1          CANTXBUF_ZKB.normal_buf.address1 = CANaddress1;
2849   1          CANTXBUF_ZKB.normal_buf.index = 26;
2850   1          CANTXBUF_ZKB.normal_buf.command = CANcomand;
2851   1          CANTXBUF_ZKB.normal_buf.data1 = Servopara[104];
2852   1          CANTXBUF_ZKB.normal_buf.data2 = Servopara[105];
2853   1          CANTXBUF_ZKB.normal_buf.data3 = Servopara[106];
2854   1          CANTXBUF_ZKB.normal_buf.data4 = 0;
2855   1          sum = 0;
2856   1          i = 0;
2857   1          do
2858   1          {
2859   2              sum += CANRXBUF_ZKB.buf[i];
2860   2              i++;
2861   2          } while(i < 7);
2862   1          CANTXBUF_ZKB.normal_buf.checkout = sum;
2863   1          can1_transmit(TX_MSGNUM_ZKB, CANTXBUF_ZKB.buf);
2864   1      
C51 COMPILER V9.56.0.0   SUSONGXIAN                                                        04/28/2017 13:56:01 PAGE 49  

2865   1      
2866   1      
2867   1      
2868   1      
2869   1      
2870   1      }
2871          //////////////////////////
2872          //将定义的Flash缓冲区写入Flash
2873          //////////////////////////
2874          void write_to_flash(void)
2875          {
2876   1          unsigned char xdata *pwrite ;
2877   1          unsigned char i;
2878   1          char SFRPAGE_SAVE = SFRPAGE;        // Save Current SFR page
2879   1          EA = 0; //关中断
2880   1          SFRPAGE = LEGACY_PAGE;
2881   1          FLSCL = FLSCL | 0x01; //允许写擦除flash
2882   1          PSCTL = PSCTL | 0x07; //允许写擦除flash
2883   1          pwrite = 0x00;
2884   1          *pwrite = 0;  //擦除flash
2885   1          PSCTL = PSCTL & 0xFD; //禁止擦除
2886   1          i = 0;
2887   1          do {
2888   2              *pwrite++ = Servopara[i];
2889   2              i++;
2890   2          } while(i < 107);
2891   1          PSCTL = PSCTL & 0xFA; //禁止flash写
2892   1          FLSCL = FLSCL & 0xFE; //禁止写擦除flash
2893   1          EA = 1; //开中断
2894   1          SFRPAGE = SFRPAGE_SAVE;             // Restore SFR page
2895   1      }
2896          
2897          //////////////////////////
2898          //将Flash中保存的数据读入Flash缓冲区
2899          //////////////////////////
2900          void read_from_flash(void)
2901          {
2902   1          unsigned char code *pread ;
2903   1          unsigned char i;
2904   1          char SFRPAGE_SAVE = SFRPAGE;        // Save Current SFR page
2905   1          EA = 0;
2906   1          SFRPAGE = LEGACY_PAGE;
2907   1          PSCTL = PSCTL | 0x04; //指向flash地址0～0x7f
2908   1          pread = 0x00;
2909   1          i = 0;
2910   1          do {
2911   2              Servopara[i] = *pread++;
2912   2              i++;
2913   2          } while(i < 107);
2914   1          PSCTL = PSCTL & 0xFB; //恢复 64k flash
2915   1          EA = 1; // 允许全局中断
2916   1          SFRPAGE = SFRPAGE_SAVE;             // Restore SFR page
2917   1      }
2918          
2919          void init_machine(void)
2920          {
2921   1          CANaddress1 = 0x01;
2922   1          nCANcomand = 0xFB;
2923   1          CANINDEX = 0X00;
2924   1          system_crtl.AUTOsystem_command = 1;     //AUTOCMD_CHECK=1;
2925   1          T0Counter3 = 51; //尽快的定时发送清除状态类表
2926   1          Runmode = 1; //自动运行
C51 COMPILER V9.56.0.0   SUSONGXIAN                                                        04/28/2017 13:56:01 PAGE 50  

2927   1      }
2928          
2929          //
2930          void SAMPCBDataacquisition(unsigned char addressID)
2931          {
2932   1          //if(ENABFLAG==YES)
2933   1          //{
2934   1          //if(Time_FLAG==YES) return;
2935   1          delay_ms(50);
2936   1          buf[0] = 0xEF; //读
2937   1          buf[1] = 0xEF; //寄存器地址高位
2938   1          buf[2] = 0x04; //寄存器地址低位
2939   1          buf[3] = addressID; //所写内容高位
2940   1          buf[4] = 0x01; //所写内容低位
2941   1          buf[5] = 0x00; //所写内容低位
2942   1          buf[6] = 0xE4; //所写内容低位
2943   1          Uart0Send(buf, 7);
2944   1          AUTO_FLAG = YES;
2945   1          cmd_chk_cnt = 0;
2946   1          while(cmd_chk_cnt < CMD_CHK_MAX );
2947   1          if(Receive_command_finished == YES)
2948   1          {
2949   2              //以后总传
2950   2              Receive_command_finished = NO;
2951   2              CANTRASTEMINFOR[8] = RxBuf1.buf[5];
2952   2              CANTRASTEMINFOR[9] = CANTRASTEMINFOR[1] | RxBuf1.buf[6];
2953   2              LED3 = !LED3;
2954   2          }
2955   1          AUTO_FLAG = NO;
2956   1      }
2957          
2958          unsigned char tempbuf[] = {0x01, 0x10, 0, 0, 0, 2, 4, 0, 0, 0, 1}, aaa = 1;
2959          //unsigned int ttt=180;
2960          
2961          //左侧翻转输送线反转
2962          //发送对象：2
2963          //signal:1-start、2-stop
2964          void FZSSXLeftFZ(unsigned char signal)
2965          {
2966   1          unsigned char i, sum;
2967   1      
2968   1          //----------------向底层驱动板发送准备好指令---------------------------------
2969   1          CANTXBUF_ZKB.normal_buf.address1 = 0X01;
2970   1          CANTXBUF_ZKB.normal_buf.command = 0xB0;
2971   1          CANTXBUF_ZKB.normal_buf.index = signal;
2972   1          CANTXBUF_ZKB.normal_buf.data1 = 0X00;
2973   1          CANTXBUF_ZKB.normal_buf.data2 = 0X00;
2974   1          CANTXBUF_ZKB.normal_buf.data3 = 0X00;
2975   1          CANTXBUF_ZKB.normal_buf.data4 = 0X00;
2976   1          sum = 0;
2977   1          i = 0;
2978   1          do
2979   1          {
2980   2              sum += CANTXBUF_ZKB.buf[i];
2981   2              i++;
2982   2          } while(i < 7);
2983   1          CANTXBUF_ZKB.normal_buf.checkout = sum;
2984   1          can1_transmit(2, CANTXBUF_ZKB.buf);
2985   1      }
2986          
2987          //右侧翻转输送线反转
2988          //发送对象：4
C51 COMPILER V9.56.0.0   SUSONGXIAN                                                        04/28/2017 13:56:01 PAGE 51  

2989          //signal:1-start、2-stop
2990          void FZSSXRightFZ(unsigned char signal)
2991          {
2992   1          unsigned char i, sum;
2993   1      
2994   1          //----------------向底层驱动板发送准备好指令---------------------------------
2995   1          CANTXBUF_ZKB.normal_buf.address1 = 0X01;
2996   1          CANTXBUF_ZKB.normal_buf.command = 0xB0;
2997   1          CANTXBUF_ZKB.normal_buf.index = signal;
2998   1          CANTXBUF_ZKB.normal_buf.data1 = 0X00;
2999   1          CANTXBUF_ZKB.normal_buf.data2 = 0X00;
3000   1          CANTXBUF_ZKB.normal_buf.data3 = 0X00;
3001   1          CANTXBUF_ZKB.normal_buf.data4 = 0X00;
3002   1          sum = 0;
3003   1          i = 0;
3004   1          do
3005   1          {
3006   2              sum += CANTXBUF_ZKB.buf[i];
3007   2              i++;
3008   2          } while(i < 7);
3009   1          CANTXBUF_ZKB.normal_buf.checkout = sum;
3010   1          can1_transmit(3, CANTXBUF_ZKB.buf);
3011   1      }
3012          
3013          
3014          //////////////////////////
3015          //         主程序
3016          //////////////////////////
3017          unsigned char i = 0, sum = 0;
3018          void main (void)
3019          {
3020   1          SFRPAGE = CONFIG_PAGE;
3021   1          Initial();
3022   1          init_machine();
3023   1      
3024   1          while(1)
3025   1          {
3026   2              SystemControl();              //系统控制（控制信息来源，can\RS485\中断信号）
3027   2              UnactiveCANtransfer();        //CAN参数应答上传
3028   2              ActiveCANtransfer();          //CAN参数主动上传
3029   2      
3030   2              //Dataacquisition();            //数据采集
3031   2              /*if((CANINFOR_FLAG==NO)&&(Runmode==0x00))//CAN主动连续上传
3032   2              {
3033   2              EIE2 &= 0xDF;
3034   2              ManualCANtransfer();            //手动单机调试系统信息上传
3035   2              EIE2 |= 0x20;
3036   2              }*/
3037   2              RunLEDDIS();                  //运行显示
3038   2          }
3039   1      }
3040          
3041          
3042          
3043          
3044          
3045          
3046          
3047          


MODULE INFORMATION:   STATIC OVERLAYABLE
C51 COMPILER V9.56.0.0   SUSONGXIAN                                                        04/28/2017 13:56:01 PAGE 52  

   CODE SIZE        =   7514    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    281    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     14      78
   IDATA SIZE       =   ----    ----
   BIT SIZE         =     11    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
