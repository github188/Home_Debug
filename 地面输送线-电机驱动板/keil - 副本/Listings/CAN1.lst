C51 COMPILER V9.56.0.0   CAN1                                                              04/28/2017 13:56:00 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE CAN1
OBJECT MODULE PLACED IN .\Objects\CAN1.obj
COMPILER INVOKED BY: C:\Keil_C51\C51\BIN\C51.EXE CAN1.C OPTIMIZE(8,SPEED) BROWSE INCDIR(..\keil) DEBUG OBJECTEXTEND PRIN
                    -T(.\Listings\CAN1.lst) TABS(2) OBJECT(.\Objects\CAN1.obj)

line level    source

   1          //------------------------------------------------------------------------------
   2          // CAN1.c
   3          //------------------------------------------------------------------------------
   4          #include <c8051f040.h>                          // SFR declarations
   5          #include "Susongxian.h"
   6          #include "can1.h"
   7          
   8          // CAN Protocol Register Index for CAN0ADR, from TABLE 18.1 of the C8051F040
   9          // datasheet
  10          ////////////////////////////////////////////////////////////////////////////////
  11          #define CANCTRL            0x00                 //Control Register
  12          #define CANSTAT            0x01                 //Status register
  13          #define ERRCNT             0x02                 //Error Counter Register
  14          #define BITREG             0x03                 //Bit Timing Register
  15          #define INTREG             0x04                 //Interrupt Low Byte Register
  16          #define CANTSTR            0x05                 //Test register
  17          #define BRPEXT             0x06                 //BRP Extension         Register
  18          ////////////////////////////////////////////////////////////////////////////////
  19          //IF1 Interface Registers
  20          ////////////////////////////////////////////////////////////////////////////////
  21          #define IF1CMDRQST         0x08                 //IF1 Command Rest      Register
  22          #define IF1CMDMSK          0x09                 //IF1 Command Mask      Register
  23          #define IF1MSK1            0x0A                 //IF1 Mask1             Register
  24          #define IF1MSK2            0x0B                 //IF1 Mask2             Register
  25          #define IF1ARB1            0x0C                 //IF1 Arbitration 1     Register
  26          #define IF1ARB2            0x0D                 //IF1 Arbitration 2     Register
  27          #define IF1MSGC            0x0E                 //IF1 Message Control   Register
  28          #define IF1DATA1           0x0F                 //IF1 Data A1           Register
  29          #define IF1DATA2           0x10                 //IF1 Data A2           Register
  30          #define IF1DATB1           0x11                 //IF1 Data B1           Register
  31          #define IF1DATB2           0x12                 //IF1 Data B2           Register
  32          ////////////////////////////////////////////////////////////////////////////////
  33          //IF2 Interface Registers
  34          ////////////////////////////////////////////////////////////////////////////////
  35          #define IF2CMDRQST         0x20                 //IF2 Command Rest      Register
  36          #define IF2CMDMSK          0x21                 //IF2 Command Mask      Register
  37          #define IF2MSK1            0x22                 //IF2 Mask1             Register
  38          #define IF2MSK2            0x23                 //IF2 Mask2             Register
  39          #define IF2ARB1            0x24                 //IF2 Arbitration 1     Register
  40          #define IF2ARB2            0x25                 //IF2 Arbitration 2     Register
  41          #define IF2MSGC            0x26                 //IF2 Message Control   Register
  42          #define IF2DATA1           0x27                 //IF2 Data A1           Register
  43          #define IF2DATA2           0x28                 //IF2 Data A2           Register
  44          #define IF2DATB1           0x29                 //IF2 Data B1           Register
  45          #define IF2DATB2           0x2A                 //IF2 Data B2           Register
  46          ////////////////////////////////////////////////////////////////////////////////
  47          //Message Handler Registers
  48          ////////////////////////////////////////////////////////////////////////////////
  49          #define TRANSREQ1          0x40                 //Transmission Rest1 Register
  50          #define TRANSREQ2          0x41                 //Transmission Rest2 Register
  51          #define NEWDAT1            0x48                 //New Data 1            Register
  52          #define NEWDAT2            0x49                 //New Data 2            Register
  53          #define INTPEND1           0x50                 //Interrupt Pending 1   Register
  54          #define INTPEND2           0x51                 //Interrupt Pending 2   Register
C51 COMPILER V9.56.0.0   CAN1                                                              04/28/2017 13:56:00 PAGE 2   

  55          #define MSGVAL1            0x58                 //Message Valid 1       Register
  56          #define MSGVAL2            0x59                 //Message Valid 2       Register
  57          //-----------------------------------------------------------------------------
  58          // C8051F040的SFR定义
  59          //-----------------------------------------------------------------------------
  60          sfr16 CAN0DAT = 0xD8;
  61          
  62          //-----------------------------------------------------------------------------
  63          // 全局变量
  64          //-----------------------------------------------------------------------------
  65          xdata  CANRECDATBUF CANRXBUF_ZKB;
  66          //xdata  CANRECDATBUF CANRXBUF_X;
  67          //xdata  CANRECDATBUF CANRXBUF_Y;
  68          //xdata  CANRECDATBUF CANRXBUF_Z;
  69          //xdata  CANRECDATBUF CANRXBUF_H;
  70          /*bit CANRefresh_ZKB=NO;
  71          bit CANRefresh_X=NO;
  72          bit CANRefresh_Y=NO;
  73          bit CANRefresh_Z=NO;
  74          bit CANRefresh_H=NO; */
  75          xdata unsigned char CANaddress1 = 0;
  76          xdata unsigned char CANINDEX = 0;
  77          //-----------------------------------------------------------------------------
  78          // 外部全局变量
  79          //-----------------------------------------------------------------------------
  80          extern xdata unsigned char Runmode;
  81          extern xdata unsigned  char station[5];
  82          extern xdata unsigned  char Servopara[107];
  83          extern xdata unsigned  char CANTRASTEMINFOR[17];
  84          /*CANTRASTEMINFOR[13]标志位：
  85          **bit0:左闸门下限传感器信号
  86          **bit1:左闸门上限传感器信号
  87          **bit2:右闸门下限传感器信号
  88          **bit3:右闸门上限传感器信号
  89          */
  90          /*CANTRASTEMINFOR[12]标志位：
  91          **bit0:伺服运行中标志
  92          **bit1:伺服归位中运行标志
  93          */
  94          extern xdata unsigned char T0Counter2;
  95          extern xdata unsigned char  T0Counter3;
  96          extern xdata unsigned char IDSET, BPSSET;
  97          extern xdata unsigned char Shaft1_Run_mode;
  98          extern xdata unsigned long  Shaft1_aim_pulse;
  99          extern xdata unsigned long  Pulse1_Cnt;
 100          extern bit Receive485_command_finished;
 101          extern bit CANINFOR_FLAG;
 102          //extern bit Step_FLAG;
 103          extern xdata unsigned  char Servoparastation;
 104          extern xdata unsigned  long Servoparadisplace;
 105          extern xdata unsigned  long Servoparaspeed;
 106          extern xdata unsigned  long Servoparaaddtime;
 107          extern xdata unsigned  long Servoparasubtime;
 108          extern xdata systemcrtl system_crtl;
 109          extern xdata unsigned char  nCANcomand;    //CAN命令字
 110          extern xdata unsigned char  CANcomand;    //CAN命令字
 111          extern xdata unsigned char  nCANDate1;
 112          extern xdata unsigned char  AUTOCMD_STATE;
 113          extern xdata unsigned char AUTOCMD_CHECK;
 114          extern void delay_ms(unsigned int ms);
 115          extern void write_to_flash(void);
 116          ////-----------------------------------------------------------------------------
C51 COMPILER V9.56.0.0   CAN1                                                              04/28/2017 13:56:00 PAGE 3   

 117          //// 函数原型
 118          ////-----------------------------------------------------------------------------
 119          //void clear_msg_objects (void);
 120          //void init_msg_object_TX (char MsgNum, unsigned int id);
 121          //void init_msg_object_RX (char MsgNum, unsigned int id);
 122          //void start_CAN (void);
 123          //void can1_transmit(char MsgNum, unsigned char *buf);
 124          //void can1_receive (char MsgNum, unsigned char *buf);
 125          //void init_can1_1 (void);
 126          //外部函数
 127          ////////////////////////////////////////////////////////////////////////////////
 128          void init_can1_1 (void)
 129          {
 130   1          ////////////////////////////////////////////////////////////////////////////////
 131   1          // Configure CAN communications
 132   1          //
 133   1          // IF1 used for procedures calles by main program
 134   1          // IF2 used for interrupt service procedure can1_receive
 135   1          //
 136   1          ////////////////////////////////////////////////////////////////////////////////
 137   1          char SFRPAGE_SAVE = SFRPAGE;        // Save Current SFR page
 138   1          SFRPAGE  = CONFIG_PAGE;        //Port SFR's on Configuration page
 139   1          XBR3     |= 0x80;     // Configure CAN TX pin (CTX) as push-pull digital output
 140   1          EA = 0;
 141   1          // Clear CAN RAM
 142   1          clear_msg_objects();
 143   1          // Initialize message object to transmit data
 144   1          init_msg_object_TX(TX_MSGNUM_ZKB, (IDSET + 64));        // 发出本地数据
 145   1          // Initialize message object to receive data
 146   1          init_msg_object_RX(RX_MSGNUM_ZKB, IDSET);               // 接收主控板动作指令数据
 147   1          //init_msg_object_RX(RX_MSGNUM_Y_Shaft,98);               // 接收Y轴动作OK反馈指令数据
 148   1          //init_msg_object_RX(RX_MSGNUM_ZKB_Union,Address_Union);  // 接收主控板始发包或结束包数据
 149   1          //init_msg_object_RX(RX_MSGNUM_ZKB_1,35);                 // 接收主控板动作指令数据
 150   1          // Enable CAN interrupts in CIP-51
 151   1          EIE2 |= 0x20;
 152   1          // 设置CAN中断优先级高
 153   1          EIP2 |= 0x20;
 154   1          //Function call to start CAN
 155   1          start_CAN();
 156   1          //Global enable 8051 interrupts
 157   1          EA = 1;
 158   1          SFRPAGE = SFRPAGE_SAVE;             // Restore SFR page
 159   1      }
 160          
 161          
 162          
 163          //Clear Message Objects
 164          void clear_msg_objects (void)
 165          {
 166   1          unsigned char i;
 167   1          char SFRPAGE_SAVE = SFRPAGE;        // Save Current SFR page
 168   1          SFRPAGE  = CAN0_PAGE;
 169   1          CAN0ADR  = IF1CMDMSK;    // Point to Command Mask Register 1
 170   1          CAN0DATL = 0xFF;         // Set direction to WRITE all IF registers to Msg Obj
 171   1          for (i = 1; i < 33; i++)
 172   1          {
 173   2              CAN0ADR = IF1CMDRQST; // Write blank (reset) IF registers to each msg obj
 174   2              CAN0DATL = i;
 175   2          }
 176   1          SFRPAGE = SFRPAGE_SAVE;             // Restore SFR page
 177   1      }
 178          
C51 COMPILER V9.56.0.0   CAN1                                                              04/28/2017 13:56:00 PAGE 4   

 179          //Initialize Message Object for RX
 180          void init_msg_object_RX (char MsgNum, unsigned int id)
 181          {
 182   1          unsigned int temp;
 183   1          char SFRPAGE_SAVE = SFRPAGE;        // Save Current SFR page
 184   1          SFRPAGE  = CAN0_PAGE;
 185   1          CAN0ADR  = IF2CMDMSK;  // Point to Command Mask 1
 186   1          CAN0DAT  = 0x00BB;     // Set to WRITE, and alter all Msg Obj except ID MASK
 187   1      
 188   1          CAN0ADR  = IF2ARB1;    // Point to arbitration1 register
 189   1          CAN0DAT  = 0x0000;     // Set arbitration1 ID to "0"
 190   1          temp = id << 2;
 191   1          temp &= 0x1fff;
 192   1          temp |= 0x8000;
 193   1          CAN0DAT  = temp;     // Arb2 high byte:Set MsgVal bit, no extended ID,
 194   1          // Dir = RECEIVE
 195   1          CAN0DAT  = 0x1488;//0x488;    // Msg Cntrl: set RXIE,
 196   1          // remote frame function disabled,
 197   1          //接收产生中断
 198   1          CAN0ADR  = IF2CMDRQST; // Point to Command Request reg.
 199   1          CAN0DATL = MsgNum;     // Select Msg Obj passed into function parameter list
 200   1          // --initiates write to Msg Obj
 201   1          // 3-6 CAN clock cycles to move IF register contents to the Msg Obj in CAN RAM
 202   1          SFRPAGE = SFRPAGE_SAVE;             // Restore SFR page
 203   1      }
 204          
 205          //Initialize Message Object for TX
 206          void init_msg_object_TX (char MsgNum, unsigned int id)
 207          {
 208   1          unsigned int temp;
 209   1          char SFRPAGE_SAVE = SFRPAGE;        // Save Current SFR page
 210   1          SFRPAGE = CAN0_PAGE;
 211   1          CAN0ADR = IF1CMDMSK;  // Point to Command Mask 1
 212   1          CAN0DAT = 0x00B3;     // Set to WRITE, & alter all Msg Obj except ID MASK bits
 213   1          CAN0ADR = IF1ARB1;    // Point to arbitration1 register
 214   1          CAN0DAT = 0x0000;     // Set arbitration1 ID to highest priority
 215   1          temp = id << 2;
 216   1          temp &= 0x1fff;
 217   1          temp |= 0xa000;
 218   1          CAN0DAT = temp;     // Autoincrement to Arb2 high byte:
 219   1          // Set MsgVal bit, no extended ID, Dir = WRITE
 220   1          CAN0DAT = 0x1088;//0x0088;     // Msg Cntrl: DLC = 8,
 221   1          //remote frame function not enabled,
 222   1          //发送不产生中断
 223   1          CAN0ADR = IF1CMDRQST; // Point to Command Request reg.
 224   1          CAN0DAT = MsgNum;     // Select Msg Obj passed into function parameter list
 225   1          // --initiates write to Msg Obj
 226   1          // 3-6 CAN clock cycles to move IF reg contents to the Msg Obj in CAN RAM.
 227   1          SFRPAGE = SFRPAGE_SAVE;             // Restore SFR page
 228   1      }
 229          
 230          void start_CAN (void)
 231          {
 232   1          /* Calculation of the CAN bit timing :
 233   1      
 234   1            System clock        f_sys = 11.0592 MHz.
 235   1            System clock period t_sys = 1/f_sys = 90.422454 ns.
 236   1            CAN time quantum       tq = t_sys (at BRP = 0)
 237   1      
 238   1            Desired bit rate is 1 MBit/s, desired bit time is 1000 ns.
 239   1            Actual bit time = 11 tq = 994.642ns
 240   1            Actual bit rate is 1.00539 MBit/s = Desired bit rate+0.5381%
C51 COMPILER V9.56.0.0   CAN1                                                              04/28/2017 13:56:00 PAGE 5   

 241   1      
 242   1              CAN bus length = 10 m, with 5 ns/m signal delay time.
 243   1              Propagation delay time : 2*(transceiver loop delay + bus line delay) = 400 ns
 244   1              (maximum loop delay between CAN nodes)
 245   1      
 246   1              Prop_Seg = 5 tq = 452 ns ( >= 400 ns).
 247   1              Sync_Seg = 1 tq
 248   1      
 249   1                Phase_seg1 + Phase_Seg2 = (11-6) tq = 5 tq
 250   1                Phase_seg1 <= Phase_Seg2,  =>  Phase_seg1 = 2 tq and Phase_Seg2 = 3 tq
 251   1                SJW = (min(Phase_Seg1, 4) tq = 2 tq
 252   1      
 253   1                TSEG1 = (Prop_Seg + Phase_Seg1 - 1) = 6
 254   1                TSEG2 = (Phase_Seg2 - 1)            = 2
 255   1                SJW_p = (SJW - 1)                   = 1
 256   1      
 257   1                  Bit Timing Register = BRP + SJW_p*0x0040 = TSEG1*0x0100 + TSEG2*0x1000 = 2640
 258   1      
 259   1                  Clock tolerance df :
 260   1      
 261   1                    A: df < min(Phase_Seg1, Phase_Seg2) / (2 * (13*bit_time - Phase_Seg2))
 262   1                    B: df < SJW / (20 * bit_time)
 263   1      
 264   1                    A: df < 2/(2*(13*11-3)) = 1/(141-3) = 1/138 = 0.7246%
 265   1                    B: df < 2/(20*11)                   = 1/110 = 0.9091%
 266   1      
 267   1                      Actual clock tolerance is 0.7246% - 0.5381% = 0.1865% (no problem for quartz)
 268   1      
 269   1                      注：SJW越长，抗噪能力越强，且Prop_Seg+Phase_Seg1越长，抗噪能力越强。SJW不能大于
 270   1                      Phase_Seg1和Phase_Seg2中如何一个值。
 271   1                      详见c8051f040.pdf
 272   1            */
 273   1          char SFRPAGE_SAVE = SFRPAGE;        // Save Current SFR page
 274   1          SFRPAGE  = CAN0_PAGE;
 275   1          CAN0CN  |= 0x41;       // Configuration Change Enable CCE and INIT
 276   1          CAN0ADR  = BITREG   ;  // Point to Bit Timing register
 277   1      
 278   1          if(BPSSET == 3)
 279   1          {
 280   2              CAN0DAT  = 0x2640; // (at BRP = 0) bps=1.00539MHz
 281   2          }
 282   1          else if(BPSSET == 2)
 283   1          {
 284   2              CAN0DAT  = 0x2641; // (at BRP = 1) bps=502693Hz
 285   2          }
 286   1          else if(BPSSET == 1)
 287   1          {
 288   2              CAN0DAT  = 0x2643; // (at BRP = 3) bps=251347Hz
 289   2          }
 290   1          else
 291   1          {
 292   2              CAN0DAT  = 0x2647; // (at BRP = 7) bps=125673Hz
 293   2          }
 294   1      
 295   1          CAN0CN = 0x0A; //模块中断开启//错误中断开启
 296   1          // Clear CCE and INIT bits, starts CAN state machine
 297   1          SFRPAGE = SFRPAGE_SAVE;             // Restore SFR page
 298   1      }
 299          
 300          
 301          void can1_transmit(char MsgNum, unsigned char *buf )
 302          {
C51 COMPILER V9.56.0.0   CAN1                                                              04/28/2017 13:56:00 PAGE 6   

 303   1          unsigned char i;
 304   1          char SFRPAGE_SAVE = SFRPAGE;        // Save Current SFR page
 305   1          SFRPAGE  = CAN0_PAGE;  // IF1 already set up for TX
 306   1      
 307   1          T0Counter2 = 0;
 308   1          CAN0ADR = TRANSREQ1;
 309   1          while ((CAN0DAT & (0x0001 << (MsgNum - 1)) ) != 0) //消息号1~16没有发送完，等待
 310   1          {
 311   2              if(T0Counter2 >= 3)
 312   2              {
 313   3                  return; //延时30ms  超时退出
 314   3              }
 315   2          }
 316   1          EA = 0;
 317   1          CAN0ADR  = IF1CMDMSK;  // Point to Command Mask 1
 318   1          CAN0DAT  = 0x0087;     // Config to WRITE to CAN RAM, write data bytes,
 319   1          // set TXrqst/NewDat, Clr IntPnd
 320   1          CAN0ADR  = IF1DATA1;   // Point to 1st byte of Data Field
 321   1          for(i = 0 ; i < 8 ; i += 2)
 322   1          {
 323   2              CAN0DATH = buf[i + 1];
 324   2              CAN0DATL = buf[i];
 325   2          }
 326   1          CAN0ADR  = IF1CMDRQST; // Point to Command Request Reg.
 327   1          CAN0DATL = MsgNum;     // Move new data for TX to Msg Obj "MsgNum"
 328   1          EA = 1;
 329   1          SFRPAGE = SFRPAGE_SAVE;             // Restore SFR page
 330   1      }
 331          
 332          
 333          // Receive Data from the IF2 buffer
 334          void can1_receive (char MsgNum, unsigned char *buf)
 335          {
 336   1          unsigned char i;
 337   1          char SFRPAGE_SAVE = SFRPAGE;        // Save Current SFR page
 338   1          SFRPAGE  = CAN0_PAGE;
 339   1          CAN0ADR  = IF2CMDMSK;  // Point to Command Mask 1
 340   1          CAN0DATL  = 0x0F;
 341   1          EA = 0;
 342   1          CAN0ADR  = IF2CMDRQST;// Point to Command Request Reg.
 343   1          CAN0DATL = MsgNum;    // Move new data for RX from Msg Obj "MsgNum"
 344   1          // Move new data to a
 345   1      
 346   1          CAN0ADR  = IF2DATA1;  // Point to 1st byte of Data Field
 347   1          for(i = 0 ; i < 8 ; i += 2)
 348   1          {
 349   2              buf[i + 1] = CAN0DATH ;
 350   2              buf[i] = CAN0DATL ;
 351   2          }
 352   1          EA = 1;
 353   1          SFRPAGE = SFRPAGE_SAVE;             // Restore SFR page
 354   1      }
 355          
 356          ////////////////////////////////////////////////////////////////////////////////
 357          //Interrupt Service Routine
 358          ////////////////////////////////////////////////////////////////////////////////
 359          void ISRname (void) interrupt 19
 360          {
 361   1          unsigned char status;
 362   1          unsigned int  intstate;
 363   1          unsigned char temp;
 364   1          temp = SFRPAGE;
C51 COMPILER V9.56.0.0   CAN1                                                              04/28/2017 13:56:00 PAGE 7   

 365   1          SFRPAGE  = CAN0_PAGE;
 366   1          status = CAN0STA;
 367   1          if ((status & 0x10) != 0)
 368   1          {   // RxOk is set, interrupt caused by reception
 369   2              CAN0STA = (CAN0STA & 0xEF) | 0x07;     // Reset RxOk, set LEC to NoChange
 370   2              /* read message number from CAN INTREG */
 371   2              CAN0ADR  = INTPEND1;
 372   2              intstate = CAN0DAT;
 373   2              if( intstate & (0x0001 << (RX_MSGNUM_ZKB - 1)) )  // 接收主控板动作指令
 374   2              {
 375   3                  can1_receive (RX_MSGNUM_ZKB, CANRXBUF_ZKB.buf);
 376   3                  switch(CANRXBUF_ZKB.buf[1])
 377   3                  {
 378   4                  case 0xA0://88
 379   4                      CANaddress1 = CANRXBUF_ZKB.buf[0];
 380   4                      nCANcomand = CANRXBUF_ZKB.buf[1];
 381   4                      CANINDEX = CANRXBUF_ZKB.buf[2];
 382   4                      Servoparadisplace = CANRXBUF_ZKB.buf[3];
 383   4                      Servoparadisplace = Servoparadisplace << 8;
 384   4                      Servoparadisplace = Servoparadisplace + CANRXBUF_ZKB.buf[4];
 385   4                      Servoparadisplace = Servoparadisplace << 8;
 386   4                      Servoparadisplace = Servoparadisplace + CANRXBUF_ZKB.buf[5];
 387   4                      Servoparadisplace = Servoparadisplace << 8;;
 388   4                      Servoparadisplace = Servoparadisplace + CANRXBUF_ZKB.buf[6];
 389   4                      Runmode = 0; //手动运行模式
 390   4                      CANINFOR_FLAG = YES;
 391   4                      break;
 392   4      
 393   4                  case 0xA1://9A
 394   4                      CANaddress1 = CANRXBUF_ZKB.buf[0];
 395   4                      nCANcomand = CANRXBUF_ZKB.buf[1];
 396   4                      CANINDEX = CANRXBUF_ZKB.buf[2];
 397   4                      Servoparaspeed = CANRXBUF_ZKB.buf[3];
 398   4                      Servoparaspeed = Servoparaspeed << 8;
 399   4                      Servoparaspeed = Servoparaspeed + CANRXBUF_ZKB.buf[4];
 400   4                      Servoparaspeed = Servoparaspeed << 8;
 401   4                      Servoparaspeed = Servoparaspeed + CANRXBUF_ZKB.buf[5];
 402   4                      Servoparaspeed = Servoparaspeed << 8;;
 403   4                      Servoparaspeed = Servoparaspeed + CANRXBUF_ZKB.buf[6];
 404   4                      Runmode = 0; //手动运行模式
 405   4                      CANINFOR_FLAG = YES;
 406   4                      break;
 407   4      
 408   4                  case 0xA4:
 409   4                      CANaddress1 = CANRXBUF_ZKB.buf[0];
 410   4                      nCANcomand = CANRXBUF_ZKB.buf[1];
 411   4                      CANINDEX = CANRXBUF_ZKB.buf[2];
 412   4                      Servopara[CANINDEX * 16 + 0] = CANRXBUF_ZKB.buf[3];
 413   4                      Servopara[CANINDEX * 16 + 1] = CANRXBUF_ZKB.buf[4];
 414   4                      Servopara[CANINDEX * 16 + 2] = CANRXBUF_ZKB.buf[5];
 415   4                      Servopara[CANINDEX * 16 + 3] = CANRXBUF_ZKB.buf[6];
 416   4                      Runmode = 0; //手动运行模式
 417   4                      CANINFOR_FLAG = YES;
 418   4                      break;
 419   4      
 420   4                  case 0xA5:
 421   4                      CANaddress1 = CANRXBUF_ZKB.buf[0];
 422   4                      nCANcomand = CANRXBUF_ZKB.buf[1];
 423   4                      CANINDEX = CANRXBUF_ZKB.buf[2];
 424   4                      Servopara[CANINDEX * 16 + 4] = CANRXBUF_ZKB.buf[3];
 425   4                      Servopara[CANINDEX * 16 + 5] = CANRXBUF_ZKB.buf[4];
 426   4                      Servopara[CANINDEX * 16 + 6] = CANRXBUF_ZKB.buf[5];
C51 COMPILER V9.56.0.0   CAN1                                                              04/28/2017 13:56:00 PAGE 8   

 427   4                      Servopara[CANINDEX * 16 + 7] = CANRXBUF_ZKB.buf[6];
 428   4                      Runmode = 0; //手动运行模式
 429   4                      CANINFOR_FLAG = YES;
 430   4                      break;
 431   4      
 432   4                  case 0xA6:
 433   4                      CANaddress1 = CANRXBUF_ZKB.buf[0];
 434   4                      nCANcomand = CANRXBUF_ZKB.buf[1];
 435   4                      CANINDEX = CANRXBUF_ZKB.buf[2];
 436   4                      Servopara[CANINDEX * 16 + 8] = CANRXBUF_ZKB.buf[3];
 437   4                      Servopara[CANINDEX * 16 + 9] = CANRXBUF_ZKB.buf[4];
 438   4                      Servopara[CANINDEX * 16 + 10] = CANRXBUF_ZKB.buf[5];
 439   4                      Servopara[CANINDEX * 16 + 11] = CANRXBUF_ZKB.buf[6];
 440   4                      Runmode = 0; //手动运行模式
 441   4                      CANINFOR_FLAG = YES;
 442   4                      break;
 443   4      
 444   4                  case 0xA7:
 445   4                      CANaddress1 = CANRXBUF_ZKB.buf[0];
 446   4                      nCANcomand = CANRXBUF_ZKB.buf[1];
 447   4                      CANINDEX = CANRXBUF_ZKB.buf[2];
 448   4                      Servopara[CANINDEX * 16 + 12] = CANRXBUF_ZKB.buf[3];
 449   4                      Servopara[CANINDEX * 16 + 13] = CANRXBUF_ZKB.buf[4];
 450   4                      Servopara[CANINDEX * 16 + 14] = CANRXBUF_ZKB.buf[5];
 451   4                      Servopara[CANINDEX * 16 + 15] = CANRXBUF_ZKB.buf[6];
 452   4                      Runmode = 0; //手动运行模式
 453   4                      CANINFOR_FLAG = YES;
 454   4                      break;
 455   4      
 456   4                  case 0xA8:
 457   4                      CANaddress1 = CANRXBUF_ZKB.buf[0];
 458   4                      nCANcomand = CANRXBUF_ZKB.buf[1];
 459   4                      CANINDEX = CANRXBUF_ZKB.buf[2];
 460   4                      Servopara[CANINDEX * 9 + 80] = CANRXBUF_ZKB.buf[3];
 461   4                      Servopara[CANINDEX * 9 + 81] = CANRXBUF_ZKB.buf[4];
 462   4                      Servopara[CANINDEX * 9 + 82] = CANRXBUF_ZKB.buf[5];
 463   4                      Servopara[CANINDEX * 9 + 83] = CANRXBUF_ZKB.buf[6];
 464   4                      Runmode = 0; //手动运行模式
 465   4                      CANINFOR_FLAG = YES;
 466   4                      break;
 467   4      
 468   4                  case 0xA9:
 469   4                      CANaddress1 = CANRXBUF_ZKB.buf[0];
 470   4                      nCANcomand = CANRXBUF_ZKB.buf[1];
 471   4                      CANINDEX = CANRXBUF_ZKB.buf[2];
 472   4                      Servopara[CANINDEX * 9 + 84] = CANRXBUF_ZKB.buf[5];
 473   4                      Servopara[CANINDEX * 9 + 85] = CANRXBUF_ZKB.buf[6];
 474   4                      Runmode = 0; //手动运行模式
 475   4                      CANINFOR_FLAG = YES;
 476   4                      break;
 477   4      
 478   4                  case 0xAA:
 479   4                      CANaddress1 = CANRXBUF_ZKB.buf[0];
 480   4                      nCANcomand = CANRXBUF_ZKB.buf[1];
 481   4                      CANINDEX = CANRXBUF_ZKB.buf[2];
 482   4                      Servopara[CANINDEX * 9 + 86] = CANRXBUF_ZKB.buf[5];
 483   4                      Servopara[CANINDEX * 9 + 87] = CANRXBUF_ZKB.buf[6];
 484   4                      Runmode = 0; //手动运行模式
 485   4                      CANINFOR_FLAG = YES;
 486   4                      break;
 487   4      
 488   4                  case 0xAB:
C51 COMPILER V9.56.0.0   CAN1                                                              04/28/2017 13:56:00 PAGE 9   

 489   4                      CANaddress1 = CANRXBUF_ZKB.buf[0];
 490   4                      nCANcomand = CANRXBUF_ZKB.buf[1];
 491   4                      CANINDEX = CANRXBUF_ZKB.buf[2];
 492   4                      Servopara[CANINDEX * 9 + 88] = CANRXBUF_ZKB.buf[6];
 493   4                      Runmode = 0; //手动运行模式
 494   4                      CANINFOR_FLAG = YES;
 495   4                      break;
 496   4      
 497   4                  case 0xAC://
 498   4                      CANaddress1 = CANRXBUF_ZKB.buf[0];
 499   4                      nCANcomand = CANRXBUF_ZKB.buf[1];
 500   4                      CANINDEX = CANRXBUF_ZKB.buf[2];
 501   4                      write_to_flash();
 502   4                      Runmode = 0; //手动运行模式
 503   4                      break;
 504   4                  case 0xC0://读取所有工位信息
 505   4                      CANaddress1 = CANRXBUF_ZKB.buf[0];
 506   4                      nCANcomand = CANRXBUF_ZKB.buf[1];
 507   4                      CANINDEX = CANRXBUF_ZKB.buf[2];
 508   4                      Runmode = 0; //手动运行模式
 509   4                      break;
 510   4      
 511   4                  case 0xC2://输送线自动命令结束主动上传信息返回
 512   4                      //CANaddress1=CANRXBUF_ZKB.buf[0];
 513   4                      //nCANcomand=CANRXBUF_ZKB.buf[1];
 514   4                      //CANINDEX=CANRXBUF_ZKB.buf[2];
 515   4                      Runmode = 1;
 516   4                      //返回信息处理
 517   4                      //CANaddress1=0;
 518   4                      //nCANcomand=0;
 519   4                      //CANINDEX=0;
 520   4                      AUTOCMD_STATE = 0;
 521   4                      break;
 522   4      
 523   4                  case 0xC3://
 524   4                      //CANaddress1=CANRXBUF_ZKB.buf[0];
 525   4                      //nCANcomand=CANRXBUF_ZKB.buf[1];
 526   4                      //CANINDEX=CANRXBUF_ZKB.buf[2];
 527   4                      Runmode = 1;
 528   4                      //返回信息处理
 529   4                      //CANaddress1=0;
 530   4                      //nCANcomand=0;
 531   4                      //CANINDEX=0;
 532   4                      AUTOCMD_STATE = 0;
 533   4                      break;
 534   4      
 535   4                  case 0xD0://0X66
 536   4                      CANaddress1 = CANRXBUF_ZKB.buf[0];
 537   4                      nCANcomand = CANRXBUF_ZKB.buf[1];
 538   4                      CANINDEX = CANRXBUF_ZKB.buf[2];
 539   4                      Runmode = 0; //手动运行模式
 540   4                      break;
 541   4      
 542   4                  case 0x11://0X55
 543   4                      CANaddress1 = CANRXBUF_ZKB.buf[0];
 544   4                      nCANcomand = CANRXBUF_ZKB.buf[1];
 545   4                      CANINDEX = CANRXBUF_ZKB.buf[2];
 546   4                      Runmode = 0; //手动运行模式
 547   4                      break;
 548   4      
 549   4                  case 0xD2://0X55
 550   4                      CANaddress1 = CANRXBUF_ZKB.buf[0];
C51 COMPILER V9.56.0.0   CAN1                                                              04/28/2017 13:56:00 PAGE 10  

 551   4                      nCANcomand = CANRXBUF_ZKB.buf[1];
 552   4                      CANINDEX = CANRXBUF_ZKB.buf[2];
 553   4                      Runmode = 0; //手动运行模式
 554   4                      break;
 555   4      
 556   4                  case 0xD3:
 557   4                      CANaddress1 = CANRXBUF_ZKB.buf[0];
 558   4                      nCANcomand = CANRXBUF_ZKB.buf[1];
 559   4                      CANINDEX = CANRXBUF_ZKB.buf[2];
 560   4                      Runmode = 0; //手动运行模式
 561   4                      break;
 562   4      
 563   4                  case 0xD4://原点复归
 564   4                      CANaddress1 = CANRXBUF_ZKB.buf[0];
 565   4                      nCANcomand = CANRXBUF_ZKB.buf[1];
 566   4                      CANINDEX = CANRXBUF_ZKB.buf[2];
 567   4                      Runmode = 0; //手动运行模式
 568   4                      break;
 569   4      
 570   4                  case 0xD5://测试
 571   4                      CANaddress1 = CANRXBUF_ZKB.buf[0];
 572   4                      nCANcomand = CANRXBUF_ZKB.buf[1];
 573   4                      CANINDEX = CANRXBUF_ZKB.buf[2];
 574   4                      Runmode = 0; //手动运行模式
 575   4                      break;
 576   4      
 577   4                  case 0xD6://0X66
 578   4                      CANaddress1 = CANRXBUF_ZKB.buf[0];
 579   4                      nCANcomand = CANRXBUF_ZKB.buf[1];
 580   4                      CANINDEX = CANRXBUF_ZKB.buf[2];
 581   4                      Runmode = 0; //手动运行模式
 582   4                      break;
 583   4      
 584   4                  case 0xD7://测试
 585   4                      CANaddress1 = CANRXBUF_ZKB.buf[0];
 586   4                      nCANcomand = CANRXBUF_ZKB.buf[1];
 587   4                      CANINDEX = CANRXBUF_ZKB.buf[2];
 588   4                      Runmode = 0; //手动运行模式
 589   4                      break;
 590   4      
 591   4                  case 0xD8://0X66
 592   4                      CANaddress1 = CANRXBUF_ZKB.buf[0];
 593   4                      nCANcomand = CANRXBUF_ZKB.buf[1];
 594   4                      CANINDEX = CANRXBUF_ZKB.buf[2];
 595   4                      Runmode = 0; //手动运行模式
 596   4                      break;
 597   4      
 598   4                  case 0xFE:
 599   4                      if(system_crtl.AUTOsystem_command != 0) //误操作退出
 600   4                      {
 601   5                          //CANTRASTEMINFOR[40]=CANTRASTEMINFOR[40]|0x01;
 602   5                      }
 603   4                      else
 604   4                      {
 605   5                          CANaddress1 = CANRXBUF_ZKB.buf[0];
 606   5                          nCANcomand = CANRXBUF_ZKB.buf[1];
 607   5                          CANINDEX = CANRXBUF_ZKB.buf[2];
 608   5                          //
 609   5                          Servoparadisplace = CANRXBUF_ZKB.buf[3];
 610   5                          Servoparadisplace = Servoparadisplace << 8;
 611   5                          Servoparadisplace = Servoparadisplace + CANRXBUF_ZKB.buf[4];
 612   5                          Servoparadisplace = Servoparadisplace << 8;
C51 COMPILER V9.56.0.0   CAN1                                                              04/28/2017 13:56:00 PAGE 11  

 613   5                          Servoparadisplace = Servoparadisplace + CANRXBUF_ZKB.buf[5];
 614   5                          Servoparadisplace = Servoparadisplace << 8;;
 615   5                          Servoparadisplace = Servoparadisplace + CANRXBUF_ZKB.buf[6];
 616   5                          //
 617   5                          system_crtl.AUTOsystem_command = 1;
 618   5                          //清除运行标志
 619   5                          CANTRASTEMINFOR[12] = CANTRASTEMINFOR[12] & 0X02; //
 620   5                          //CANTRASTEMINFOR[13]=0x00;
 621   5                          CANTRASTEMINFOR[14] = 0x00;
 622   5                          T0Counter3 = 51; //尽快的定时发送清除状态类表
 623   5                          Runmode = 1; //自动运行
 624   5                      }
 625   4                      break;
 626   4      
 627   4                  case 0xFD:
 628   4                      if(system_crtl.AUTOsystem_command != 0) //误操作退出
 629   4                      {
 630   5                          //CANTRASTEMINFOR[40]=CANTRASTEMINFOR[40]|0x01;
 631   5                      }
 632   4                      else
 633   4                      {
 634   5                          CANaddress1 = CANRXBUF_ZKB.buf[0];
 635   5                          nCANcomand = CANRXBUF_ZKB.buf[1];
 636   5                          CANINDEX = CANRXBUF_ZKB.buf[2];
 637   5                          system_crtl.AUTOsystem_command = 1;
 638   5                          //清除运行标志
 639   5                          CANTRASTEMINFOR[12] = CANTRASTEMINFOR[12] & 0X02; //
 640   5                          //CANTRASTEMINFOR[13]=0x00;
 641   5                          CANTRASTEMINFOR[14] = 0x00;
 642   5                          T0Counter3 = 51; //尽快的定时发送清除状态类表
 643   5                          Runmode = 1; //自动运行
 644   5                      }
 645   4                      break;
 646   4      
 647   4                  case 0xFC://0X66
 648   4                      //CANaddress1=CANRXBUF_ZKB.buf[0];
 649   4                      AUTOCMD_CHECK = CANRXBUF_ZKB.buf[1]; //AUTOCMD_CHECK查询命令规避其他运行中的命令
 650   4                      //CANINDEX=CANRXBUF_ZKB.buf[2];
 651   4                      Runmode = 1;
 652   4                      break;
 653   4      
 654   4                  case 0xFB://0X66
 655   4                      //CANaddress1=CANRXBUF_ZKB.buf[0];
 656   4                      if(system_crtl.AUTOsystem_command != 0) //误操作退出
 657   4                      {
 658   5                          ;//故障报警
 659   5                      }
 660   4                      else
 661   4                      {
 662   5                          CANaddress1 = CANRXBUF_ZKB.buf[0];
 663   5                          nCANcomand = CANRXBUF_ZKB.buf[1];
 664   5                          CANINDEX = CANRXBUF_ZKB.buf[2];
 665   5                          system_crtl.AUTOsystem_command = 1;
 666   5                          //AUTOCMD_CHECK=1;
 667   5      
 668   5                          T0Counter3 = 51; //尽快的定时发送清除状态类表
 669   5                          Runmode = 1; //自动运行
 670   5                      }
 671   4                      break;
 672   4      
 673   4                      //added begin
 674   4                      //新增0XB2指令，启动地面输送线无限长、慢速运行
C51 COMPILER V9.56.0.0   CAN1                                                              04/28/2017 13:56:00 PAGE 12  

 675   4                  case 0xB2:
 676   4                      if(system_crtl.AUTOsystem_command != 0) //误操作退出
 677   4                      {
 678   5                      }
 679   4                      else
 680   4                      {
 681   5                          CANaddress1 = CANRXBUF_ZKB.buf[0];
 682   5                          nCANcomand = CANRXBUF_ZKB.buf[1];
 683   5                          CANINDEX = CANRXBUF_ZKB.buf[2];
 684   5                          system_crtl.AUTOsystem_command = 20;
 685   5      
 686   5                          T0Counter3 = 51; //尽快的定时发送清除状态类表
 687   5                          Runmode = 1; //自动运行
 688   5                      }
 689   4                      break;
 690   4      
 691   4                      //新增0XB3指令，停止地面输送线无限长、慢速运行
 692   4                  case 0xB3:
 693   4                      if(system_crtl.AUTOsystem_command != 0) //误操作退出
 694   4                      {
 695   5                      }
 696   4                      else
 697   4                      {
 698   5                          CANaddress1 = CANRXBUF_ZKB.buf[0];
 699   5                          nCANcomand = CANRXBUF_ZKB.buf[1];
 700   5                          CANINDEX = CANRXBUF_ZKB.buf[2];
 701   5                          system_crtl.AUTOsystem_command = 21;
 702   5      
 703   5                          T0Counter3 = 51; //尽快的定时发送清除状态类表
 704   5                          Runmode = 1; //自动运行
 705   5                      }
 706   4                      break;
 707   4                      //added end
 708   4      
 709   4                  default:
 710   4                      break;
 711   4                  }
 712   3              }
 713   2      
 714   2              /*if( intstate&(0x0001<<(RX_MSGNUM_ZKB_1-1)) )        // 接收主控板动作指令
 715   2              {
 716   2                 {
 717   2                   can1_receive (RX_MSGNUM_ZKB_1,CANRXBUF_ZKB.buf);
 718   2                   CANRefresh_ZKB=YES;
 719   2                 }
 720   2              }
 721   2      
 722   2              if( intstate&(0x0001<<(RX_MSGNUM_ZKB_Union-1)) )  // 接收主控板公共通道数据
 723   2              {
 724   2                 {
 725   2                   can1_receive (RX_MSGNUM_ZKB_Union,CANRXBUF_ZKB.buf);
 726   2                   CANRefresh_ZKB=YES;
 727   2                 }
 728   2              }
 729   2      
 730   2              if( intstate&(0x0001<<(RX_MSGNUM_Y_Shaft-1)) )    // 接收Y轴通道数据
 731   2              {
 732   2                 {
 733   2                   can1_receive (RX_MSGNUM_Y_Shaft,CANRXBUF_Y.buf);
 734   2                   CANRefresh_Y=YES;
 735   2                 }
 736   2              }*/
C51 COMPILER V9.56.0.0   CAN1                                                              04/28/2017 13:56:00 PAGE 13  

 737   2      
 738   2              LED8 = YES; //故障指示灭
 739   2          }
 740   1          if ((status & 0x08) != 0)
 741   1          {   // TxOk is set, interrupt caused by transmision
 742   2              CAN0STA = (CAN0STA & 0xF7) | 0x07;    // Reset TxOk, set LEC to NoChange
 743   2          }
 744   1          if (((status & 0x07) != 0) && ((status & 0x07) != 7))
 745   1          {   // Error interrupt, LEC changed
 746   2              /* error handling ? */
 747   2              CAN0STA = CAN0STA | 0x07;            // Set LEC to NoChange
 748   2              if( (status & 0x80) != 0) //总线关闭
 749   2              {
 750   3                  CAN0CN  &= 0xFE;        //恢复正常模式
 751   3              }
 752   2      
 753   2              LED8 = NO ; //故障指示
 754   2          }
 755   1          SFRPAGE = temp;
 756   1      }
 757          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2483    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     10    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      10
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
